/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.10.0 (NJsonSchema v9.10.49.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resolveTenantId(input: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class ApartmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @apartmentCode (optional) 
     * @apartmentName (optional) 
     * @apTypeID (optional) 
     * @buildingID (optional) 
     * @floor_id (optional) 
     * @status (optional) 
     * @auth_status (optional) 
     * @max_tenant (optional) 
     * @approve (optional) 
     * @return Success
     */
    apartmentSearch(apartmentCode: string | null | undefined, apartmentName: string | null | undefined, apTypeID: string | null | undefined, buildingID: string | null | undefined, floor_id: string | null | undefined, status: string | null | undefined, auth_status: string | null | undefined, max_tenant: number | null | undefined, approve: string | null | undefined): Observable<ApSearchDTO[]> {
        let url_ = this.baseUrl + "/api/Apartment/ApartmentSearch?";
        if (apartmentCode !== undefined)
            url_ += "apartmentCode=" + encodeURIComponent("" + apartmentCode) + "&"; 
        if (apartmentName !== undefined)
            url_ += "apartmentName=" + encodeURIComponent("" + apartmentName) + "&"; 
        if (apTypeID !== undefined)
            url_ += "apTypeID=" + encodeURIComponent("" + apTypeID) + "&"; 
        if (buildingID !== undefined)
            url_ += "buildingID=" + encodeURIComponent("" + buildingID) + "&"; 
        if (floor_id !== undefined)
            url_ += "floor_id=" + encodeURIComponent("" + floor_id) + "&"; 
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        if (auth_status !== undefined)
            url_ += "auth_status=" + encodeURIComponent("" + auth_status) + "&"; 
        if (max_tenant !== undefined)
            url_ += "max_tenant=" + encodeURIComponent("" + max_tenant) + "&"; 
        if (approve !== undefined)
            url_ += "approve=" + encodeURIComponent("" + approve) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentSearch(<any>response_);
                } catch (e) {
                    return <Observable<ApSearchDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApSearchDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentSearch(response: HttpResponseBase): Observable<ApSearchDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ApSearchDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApSearchDTO[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @return Success
     */
    apartmentByID(apartmentID: string | null | undefined): Observable<ApartmentDTO> {
        let url_ = this.baseUrl + "/api/Apartment/ApartmentByID?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentByID(<any>response_);
                } catch (e) {
                    return <Observable<ApartmentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApartmentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentByID(response: HttpResponseBase): Observable<ApartmentDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApartmentDTO.fromJS(resultData200) : new ApartmentDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApartmentDTO>(<any>null);
    }

    /**
     * @dto (optional) 
     * @return Success
     */
    apartmentInsert(dto: ApartmentDTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Apartment/ApartmentInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentInsert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentInsert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @dto (optional) 
     * @return Success
     */
    apartmentUpdate(dto: ApartmentDTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Apartment/ApartmentUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentUpdate(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @return Success
     */
    apartmentDelete(apartmentID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Apartment/ApartmentDelete?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @checkerID (optional) 
     * @return Success
     */
    apartmentApprove(apartmentID: string | null | undefined, checkerID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Apartment/ApartmentApprove?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        if (checkerID !== undefined)
            url_ += "checkerID=" + encodeURIComponent("" + checkerID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentApprove(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentApprove(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @checkerID (optional) 
     * @return Success
     */
    apartmentDeny(apartmentID: string | null | undefined, checkerID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Apartment/ApartmentDeny?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        if (checkerID !== undefined)
            url_ += "checkerID=" + encodeURIComponent("" + checkerID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentDeny(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentDeny(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentDeny(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @listInput (optional) 
     * @return Success
     */
    apartment_ExportExcel(listInput: CustomApartmentDTO[] | null | undefined): Observable<CustomApartmentDTO[]> {
        let url_ = this.baseUrl + "/api/Apartment/Apartment_ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartment_ExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartment_ExportExcel(<any>response_);
                } catch (e) {
                    return <Observable<CustomApartmentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomApartmentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartment_ExportExcel(response: HttpResponseBase): Observable<CustomApartmentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CustomApartmentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomApartmentDTO[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @return Success
     */
    apartment_GetAuthStatusName(apartmentID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Apartment/Apartment_GetAuthStatusName?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartment_GetAuthStatusName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartment_GetAuthStatusName(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartment_GetAuthStatusName(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @return Success
     */
    apartment_FindNewID(apartmentID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Apartment/Apartment_FindNewID?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartment_FindNewID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartment_FindNewID(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartment_FindNewID(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }
}

@Injectable()
export class Apartment_ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<Apartment_DTO[]> {
        let url_ = this.baseUrl + "/api/Apartment_/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Apartment_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Apartment_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Apartment_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Apartment_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Apartment_DTO[]>(<any>null);
    }
}

@Injectable()
export class ApartmentResidentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @apartmentID (optional) 
     * @return Success
     */
    apartmentResident_ResidentByApartment(apartmentID: string | null | undefined): Observable<ResidentDTO[]> {
        let url_ = this.baseUrl + "/api/ApartmentResident/ApartmentResident_ResidentByApartment?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentResident_ResidentByApartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentResident_ResidentByApartment(<any>response_);
                } catch (e) {
                    return <Observable<ResidentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResidentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentResident_ResidentByApartment(response: HttpResponseBase): Observable<ResidentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ResidentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResidentDTO[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @return Success
     */
    apartmentResident_FreeResidentByApartment(apartmentID: string | null | undefined): Observable<ResidentDTO[]> {
        let url_ = this.baseUrl + "/api/ApartmentResident/ApartmentResident_FreeResidentByApartment?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentResident_FreeResidentByApartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentResident_FreeResidentByApartment(<any>response_);
                } catch (e) {
                    return <Observable<ResidentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResidentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentResident_FreeResidentByApartment(response: HttpResponseBase): Observable<ResidentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ResidentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResidentDTO[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @filter (optional) 
     * @return Success
     */
    apartmentResident_SearchFreeResident(apartmentID: string | null | undefined, filter: string | null | undefined): Observable<ResidentDTO[]> {
        let url_ = this.baseUrl + "/api/ApartmentResident/ApartmentResident_SearchFreeResident?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentResident_SearchFreeResident(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentResident_SearchFreeResident(<any>response_);
                } catch (e) {
                    return <Observable<ResidentDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResidentDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentResident_SearchFreeResident(response: HttpResponseBase): Observable<ResidentDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ResidentDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResidentDTO[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @residentID (optional) 
     * @makerID (optional) 
     * @return Success
     */
    apartmentResident_Insert(apartmentID: string | null | undefined, residentID: string | null | undefined, makerID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ApartmentResident/ApartmentResident_Insert?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        if (residentID !== undefined)
            url_ += "residentID=" + encodeURIComponent("" + residentID) + "&"; 
        if (makerID !== undefined)
            url_ += "makerID=" + encodeURIComponent("" + makerID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentResident_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentResident_Insert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentResident_Insert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @apartmentID (optional) 
     * @residentID (optional) 
     * @return Success
     */
    apartmentResident_Delete(apartmentID: string | null | undefined, residentID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ApartmentResident/ApartmentResident_Delete?";
        if (apartmentID !== undefined)
            url_ += "apartmentID=" + encodeURIComponent("" + apartmentID) + "&"; 
        if (residentID !== undefined)
            url_ += "residentID=" + encodeURIComponent("" + residentID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentResident_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentResident_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentResident_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }
}

@Injectable()
export class ApartmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    approve(body: ApartmentApproveRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Apartments/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: ApartmentCreateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Apartments/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @aPARTMENT_ID (optional) 
     * @return Success
     */
    delete(aPARTMENT_ID: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Apartments/Delete?";
        if (aPARTMENT_ID !== undefined)
            url_ += "APARTMENT_ID=" + encodeURIComponent("" + aPARTMENT_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @aPARTMENT_ID (optional) 
     * @return Success
     */
    getByID(aPARTMENT_ID: string | null | undefined): Observable<ApartmentTableDTO> {
        let url_ = this.baseUrl + "/api/Apartments/GetByID?";
        if (aPARTMENT_ID !== undefined)
            url_ += "APARTMENT_ID=" + encodeURIComponent("" + aPARTMENT_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<ApartmentTableDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApartmentTableDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<ApartmentTableDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApartmentTableDTO.fromJS(resultData200) : new ApartmentTableDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApartmentTableDTO>(<any>null);
    }

    /**
     * @aPARTMENT_CODE (optional) 
     * @aPARTMENT_NAME (optional) 
     * @aPARTMENTTYPE_ID (optional) 
     * @bUILDING_ID (optional) 
     * @fLOOR_ID (optional) 
     * @rECORD_STATUS (optional) 
     * @aUTH_STATUS (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    pagingSearch(aPARTMENT_CODE: string | null | undefined, aPARTMENT_NAME: string | null | undefined, aPARTMENTTYPE_ID: string | null | undefined, bUILDING_ID: string | null | undefined, fLOOR_ID: string | null | undefined, rECORD_STATUS: string | null | undefined, aUTH_STATUS: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfApartmentPagingSearchDTO> {
        let url_ = this.baseUrl + "/api/Apartments/PagingSearch?";
        if (aPARTMENT_CODE !== undefined)
            url_ += "APARTMENT_CODE=" + encodeURIComponent("" + aPARTMENT_CODE) + "&"; 
        if (aPARTMENT_NAME !== undefined)
            url_ += "APARTMENT_NAME=" + encodeURIComponent("" + aPARTMENT_NAME) + "&"; 
        if (aPARTMENTTYPE_ID !== undefined)
            url_ += "APARTMENTTYPE_ID=" + encodeURIComponent("" + aPARTMENTTYPE_ID) + "&"; 
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        if (fLOOR_ID !== undefined)
            url_ += "FLOOR_ID=" + encodeURIComponent("" + fLOOR_ID) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPagingSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPagingSearch(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApartmentPagingSearchDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApartmentPagingSearchDTO>><any>_observableThrow(response_);
        }));
    }

    protected processPagingSearch(response: HttpResponseBase): Observable<PagedResultDtoOfApartmentPagingSearchDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfApartmentPagingSearchDTO.fromJS(resultData200) : new PagedResultDtoOfApartmentPagingSearchDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApartmentPagingSearchDTO>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: ApartmentUpdateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Apartments/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class ApartmentTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @apTypeCode (optional) 
     * @apTypeName (optional) 
     * @userID (optional) 
     * @return Success
     */
    apartmentTypeSearch(apTypeCode: string | null | undefined, apTypeName: string | null | undefined, userID: number | null | undefined): Observable<ApartmentTypeDTO[]> {
        let url_ = this.baseUrl + "/api/ApartmentType/ApartmentTypeSearch?";
        if (apTypeCode !== undefined)
            url_ += "apTypeCode=" + encodeURIComponent("" + apTypeCode) + "&"; 
        if (apTypeName !== undefined)
            url_ += "apTypeName=" + encodeURIComponent("" + apTypeName) + "&"; 
        if (userID !== undefined)
            url_ += "userID=" + encodeURIComponent("" + userID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentTypeSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentTypeSearch(<any>response_);
                } catch (e) {
                    return <Observable<ApartmentTypeDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApartmentTypeDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentTypeSearch(response: HttpResponseBase): Observable<ApartmentTypeDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ApartmentTypeDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApartmentTypeDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apartmentTypeGetAll(): Observable<ApartmentTypeDTO[]> {
        let url_ = this.baseUrl + "/api/ApartmentType/ApartmentTypeGetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentTypeGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentTypeGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ApartmentTypeDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApartmentTypeDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentTypeGetAll(response: HttpResponseBase): Observable<ApartmentTypeDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ApartmentTypeDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApartmentTypeDTO[]>(<any>null);
    }

    /**
     * @apartmentTypeID (optional) 
     * @return Success
     */
    apartmentTypeByID(apartmentTypeID: string | null | undefined): Observable<ApartmentTypeDTO> {
        let url_ = this.baseUrl + "/api/ApartmentType/ApartmentTypeByID?";
        if (apartmentTypeID !== undefined)
            url_ += "apartmentTypeID=" + encodeURIComponent("" + apartmentTypeID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentTypeByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentTypeByID(<any>response_);
                } catch (e) {
                    return <Observable<ApartmentTypeDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApartmentTypeDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentTypeByID(response: HttpResponseBase): Observable<ApartmentTypeDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApartmentTypeDTO.fromJS(resultData200) : new ApartmentTypeDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApartmentTypeDTO>(<any>null);
    }

    /**
     * @dto (optional) 
     * @return Success
     */
    apartmentTypeInsert(dto: ApartmentTypeDTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ApartmentType/ApartmentTypeInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentTypeInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentTypeInsert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentTypeInsert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @dto (optional) 
     * @return Success
     */
    apartmentTypeUpdate(dto: ApartmentTypeDTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ApartmentType/ApartmentTypeUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentTypeUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentTypeUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentTypeUpdate(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @apartmentTypeID (optional) 
     * @return Success
     */
    apartmentTypeDelete(apartmentTypeID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ApartmentType/ApartmentTypeDelete?";
        if (apartmentTypeID !== undefined)
            url_ += "ApartmentTypeID=" + encodeURIComponent("" + apartmentTypeID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentTypeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentTypeDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentTypeDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @apartmentTypeID (optional) 
     * @checkerID (optional) 
     * @return Success
     */
    apartmentTypeApprove(apartmentTypeID: string | null | undefined, checkerID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ApartmentType/ApartmentTypeApprove?";
        if (apartmentTypeID !== undefined)
            url_ += "ApartmentTypeID=" + encodeURIComponent("" + apartmentTypeID) + "&"; 
        if (checkerID !== undefined)
            url_ += "checkerID=" + encodeURIComponent("" + checkerID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentTypeApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentTypeApprove(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentTypeApprove(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @listInput (optional) 
     * @return Success
     */
    apartmentType_ExportExcel(listInput: ApartmentTypeDTO[] | null | undefined): Observable<ApartmentTypeDTO[]> {
        let url_ = this.baseUrl + "/api/ApartmentType/ApartmentType_ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentType_ExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentType_ExportExcel(<any>response_);
                } catch (e) {
                    return <Observable<ApartmentTypeDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApartmentTypeDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentType_ExportExcel(response: HttpResponseBase): Observable<ApartmentTypeDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ApartmentTypeDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApartmentTypeDTO[]>(<any>null);
    }

    /**
     * @apartmentTypeID (optional) 
     * @return Success
     */
    apartmentType_GetAuthStatusName(apartmentTypeID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ApartmentType/ApartmentType_GetAuthStatusName?";
        if (apartmentTypeID !== undefined)
            url_ += "apartmentTypeID=" + encodeURIComponent("" + apartmentTypeID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApartmentType_GetAuthStatusName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApartmentType_GetAuthStatusName(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApartmentType_GetAuthStatusName(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @entityTypeFullName (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @entityTypeFullName (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class BaoDuongServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @bdId (optional) 
     * @return Success
     */
    bD_GetById(bdId: string | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_GetById?";
        if (bdId !== undefined)
            url_ += "bdId=" + encodeURIComponent("" + bdId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_GetById(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_GetById(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @bdCode (optional) 
     * @return Success
     */
    bD_GetByCode(bdCode: string | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_GetByCode?";
        if (bdCode !== undefined)
            url_ += "bdCode=" + encodeURIComponent("" + bdCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_GetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_GetByCode(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_GetByCode(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    bD_Insert(model: BD_DTO | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Insert(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Insert(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    bD_Update(model: BD_DTO | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Update(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Update(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @bdId (optional) 
     * @return Success
     */
    bD_Delete(bdId: string | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Delete?";
        if (bdId !== undefined)
            url_ += "bdId=" + encodeURIComponent("" + bdId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Delete(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Delete(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    bD_Search(filterInput: BD_DTO | null | undefined): Observable<PagedResultDtoOfBD_DTO> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBD_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBD_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Search(response: HttpResponseBase): Observable<PagedResultDtoOfBD_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBD_DTO.fromJS(resultData200) : new PagedResultDtoOfBD_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBD_DTO>(<any>null);
    }

    /**
     * @listInput (optional) 
     * @return Success
     */
    bD_ExportData(listInput: BD_DTO[] | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_ExportData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_ExportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_ExportData(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_ExportData(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @bdId (optional) 
     * @return Success
     */
    bD_Approve_Insert(bdId: string | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Approve_Insert?";
        if (bdId !== undefined)
            url_ += "bdId=" + encodeURIComponent("" + bdId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Approve_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Approve_Insert(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Approve_Insert(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @bdId (optional) 
     * @return Success
     */
    bD_Approve_Delete(bdId: string | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Approve_Delete?";
        if (bdId !== undefined)
            url_ += "bdId=" + encodeURIComponent("" + bdId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Approve_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Approve_Delete(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Approve_Delete(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @bdCode (optional) 
     * @return Success
     */
    bD_Approve_Update(bdCode: string | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Approve_Update?";
        if (bdCode !== undefined)
            url_ += "bdCode=" + encodeURIComponent("" + bdCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Approve_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Approve_Update(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Approve_Update(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @bdId (optional) 
     * @return Success
     */
    bD_Deny_Insert(bdId: string | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Deny_Insert?";
        if (bdId !== undefined)
            url_ += "bdId=" + encodeURIComponent("" + bdId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Deny_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Deny_Insert(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Deny_Insert(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @bdId (optional) 
     * @return Success
     */
    bD_Deny_Delete(bdId: string | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Deny_Delete?";
        if (bdId !== undefined)
            url_ += "bdId=" + encodeURIComponent("" + bdId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Deny_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Deny_Delete(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Deny_Delete(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @bdCode (optional) 
     * @return Success
     */
    bD_Deny_Update(bdCode: string | null | undefined): Observable<BD_DTO[]> {
        let url_ = this.baseUrl + "/api/BaoDuong/BD_Deny_Update?";
        if (bdCode !== undefined)
            url_ += "bdCode=" + encodeURIComponent("" + bdCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBD_Deny_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBD_Deny_Update(<any>response_);
                } catch (e) {
                    return <Observable<BD_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BD_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processBD_Deny_Update(response: HttpResponseBase): Observable<BD_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BD_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BD_DTO[]>(<any>null);
    }

    /**
     * @bdCode (optional) 
     * @return Success
     */
    isUpdating(bdCode: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/BaoDuong/isUpdating?";
        if (bdCode !== undefined)
            url_ += "bdCode=" + encodeURIComponent("" + bdCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUpdating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUpdating(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsUpdating(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    getAll(filterInput: BD_DTO | null | undefined): Observable<PagedResultDtoOfBD_DTO> {
        let url_ = this.baseUrl + "/api/BaoDuong/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBD_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBD_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfBD_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBD_DTO.fromJS(resultData200) : new PagedResultDtoOfBD_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBD_DTO>(<any>null);
    }
}

@Injectable()
export class BranchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @search (optional) 
     * @branchCode (optional) 
     * @branchName (optional) 
     * @branchStatus (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    branchSearch(search: string | null | undefined, branchCode: string | null | undefined, branchName: string | null | undefined, branchStatus: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGroup03BranchDTO> {
        let url_ = this.baseUrl + "/api/Branch/BranchSearch?";
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        if (branchCode !== undefined)
            url_ += "BranchCode=" + encodeURIComponent("" + branchCode) + "&"; 
        if (branchName !== undefined)
            url_ += "BranchName=" + encodeURIComponent("" + branchName) + "&"; 
        if (branchStatus !== undefined)
            url_ += "BranchStatus=" + encodeURIComponent("" + branchStatus) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBranchSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBranchSearch(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGroup03BranchDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGroup03BranchDTO>><any>_observableThrow(response_);
        }));
    }

    protected processBranchSearch(response: HttpResponseBase): Observable<PagedResultDtoOfGroup03BranchDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGroup03BranchDTO.fromJS(resultData200) : new PagedResultDtoOfGroup03BranchDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGroup03BranchDTO>(<any>null);
    }

    /**
     * @bRANCH_ID (optional) 
     * @return Success
     */
    branchDelete(bRANCH_ID: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Branch/BranchDelete?";
        if (bRANCH_ID !== undefined)
            url_ += "BRANCH_ID=" + encodeURIComponent("" + bRANCH_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBranchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBranchDelete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processBranchDelete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @branchId (optional) 
     * @return Success
     */
    branchById(branchId: string | null | undefined): Observable<CM_BRANCH_DTO> {
        let url_ = this.baseUrl + "/api/Branch/BranchById?";
        if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBranchById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBranchById(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processBranchById(response: HttpResponseBase): Observable<CM_BRANCH_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_BRANCH_DTO.fromJS(resultData200) : new CM_BRANCH_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_DTO>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    branchInsert(input: CM_BRANCH_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Branch/BranchInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBranchInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBranchInsert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processBranchInsert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    branchUpdate(input: CM_BRANCH_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Branch/BranchUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBranchUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBranchUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processBranchUpdate(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    cM_Branch_GetFatherBranchByBranchType(input: string | null | undefined): Observable<CM_BRANCH_DTO[]> {
        let url_ = this.baseUrl + "/api/Branch/CM_Branch_GetFatherBranchByBranchType?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_Branch_GetFatherBranchByBranchType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_Branch_GetFatherBranchByBranchType(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_Branch_GetFatherBranchByBranchType(response: HttpResponseBase): Observable<CM_BRANCH_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_BRANCH_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_DTO[]>(<any>null);
    }
}

@Injectable()
export class BuildingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    approve(body: BuildingApproveRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Buildings/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: BuildingCreateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Buildings/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @bUILDING_ID (optional) 
     * @return Success
     */
    delete(bUILDING_ID: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Buildings/Delete?";
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @bUILDING_ID (optional) 
     * @return Success
     */
    getByID(bUILDING_ID: string | null | undefined): Observable<BuildingTableDTO> {
        let url_ = this.baseUrl + "/api/Buildings/GetByID?";
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<BuildingTableDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingTableDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<BuildingTableDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BuildingTableDTO.fromJS(resultData200) : new BuildingTableDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingTableDTO>(<any>null);
    }

    /**
     * @bUILDING_CODE (optional) 
     * @bUILDING_NAME (optional) 
     * @rECORD_STATUS (optional) 
     * @aUTH_STATUS (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    pagingSearch(bUILDING_CODE: string | null | undefined, bUILDING_NAME: string | null | undefined, rECORD_STATUS: string | null | undefined, aUTH_STATUS: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBuildingPagingSearchDTO> {
        let url_ = this.baseUrl + "/api/Buildings/PagingSearch?";
        if (bUILDING_CODE !== undefined)
            url_ += "BUILDING_CODE=" + encodeURIComponent("" + bUILDING_CODE) + "&"; 
        if (bUILDING_NAME !== undefined)
            url_ += "BUILDING_NAME=" + encodeURIComponent("" + bUILDING_NAME) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPagingSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPagingSearch(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBuildingPagingSearchDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBuildingPagingSearchDTO>><any>_observableThrow(response_);
        }));
    }

    protected processPagingSearch(response: HttpResponseBase): Observable<PagedResultDtoOfBuildingPagingSearchDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBuildingPagingSearchDTO.fromJS(resultData200) : new PagedResultDtoOfBuildingPagingSearchDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBuildingPagingSearchDTO>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: BuildingUpdateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Buildings/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @tenantId (optional) 
     * @userId (optional) 
     * @minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChiTietBanKiemKeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @bkk_ID (optional) 
     * @return Success
     */
    chiTietKiemKe_Get(bkk_ID: string | null | undefined): Observable<CHI_TIET_BAN_KIEM_KE_DTO[]> {
        let url_ = this.baseUrl + "/api/ChiTietBanKiemKe/ChiTietKiemKe_Get?";
        if (bkk_ID !== undefined)
            url_ += "bkk_ID=" + encodeURIComponent("" + bkk_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietKiemKe_Get(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietKiemKe_Get(<any>response_);
                } catch (e) {
                    return <Observable<CHI_TIET_BAN_KIEM_KE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CHI_TIET_BAN_KIEM_KE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietKiemKe_Get(response: HttpResponseBase): Observable<CHI_TIET_BAN_KIEM_KE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CHI_TIET_BAN_KIEM_KE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CHI_TIET_BAN_KIEM_KE_DTO[]>(<any>null);
    }

    /**
     * @dv_QL (optional) 
     * @bkk_ID (optional) 
     * @ngay_TAO (optional) 
     * @ma_TB (optional) 
     * @tt_SAU (optional) 
     * @return Success
     */
    cTBKK_XacNhanKK(dv_QL: string | null | undefined, bkk_ID: string | null | undefined, ngay_TAO: moment.Moment | null | undefined, ma_TB: string | null | undefined, tt_SAU: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ChiTietBanKiemKe/CTBKK_XacNhanKK?";
        if (dv_QL !== undefined)
            url_ += "dv_QL=" + encodeURIComponent("" + dv_QL) + "&"; 
        if (bkk_ID !== undefined)
            url_ += "bkk_ID=" + encodeURIComponent("" + bkk_ID) + "&"; 
        if (ngay_TAO !== undefined)
            url_ += "ngay_TAO=" + encodeURIComponent(ngay_TAO ? "" + ngay_TAO.toJSON() : "") + "&"; 
        if (ma_TB !== undefined)
            url_ += "ma_TB=" + encodeURIComponent("" + ma_TB) + "&"; 
        if (tt_SAU !== undefined)
            url_ += "tt_SAU=" + encodeURIComponent("" + tt_SAU) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCTBKK_XacNhanKK(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCTBKK_XacNhanKK(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCTBKK_XacNhanKK(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @maKK (optional) 
     * @maDV (optional) 
     * @return Success
     */
    taoChiTietKiemKe(maKK: string | null | undefined, maDV: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ChiTietBanKiemKe/TaoChiTietKiemKe?";
        if (maKK !== undefined)
            url_ += "maKK=" + encodeURIComponent("" + maKK) + "&"; 
        if (maDV !== undefined)
            url_ += "maDV=" + encodeURIComponent("" + maDV) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaoChiTietKiemKe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaoChiTietKiemKe(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTaoChiTietKiemKe(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    chiTietKiemKeInsert(input: CHI_TIET_BAN_KIEM_KE_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/ChiTietBanKiemKe/ChiTietKiemKeInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietKiemKeInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietKiemKeInsert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietKiemKeInsert(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @idKK (optional) 
     * @idTB (optional) 
     * @return Success
     */
    chiTietKiemKe_GetByIdKK_IdDV(idKK: string | null | undefined, idTB: string | null | undefined): Observable<CHI_TIET_BAN_KIEM_KE_DTO[]> {
        let url_ = this.baseUrl + "/api/ChiTietBanKiemKe/ChiTietKiemKe_GetByIdKK_IdDV?";
        if (idKK !== undefined)
            url_ += "idKK=" + encodeURIComponent("" + idKK) + "&"; 
        if (idTB !== undefined)
            url_ += "idTB=" + encodeURIComponent("" + idTB) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietKiemKe_GetByIdKK_IdDV(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietKiemKe_GetByIdKK_IdDV(<any>response_);
                } catch (e) {
                    return <Observable<CHI_TIET_BAN_KIEM_KE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CHI_TIET_BAN_KIEM_KE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietKiemKe_GetByIdKK_IdDV(response: HttpResponseBase): Observable<CHI_TIET_BAN_KIEM_KE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CHI_TIET_BAN_KIEM_KE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CHI_TIET_BAN_KIEM_KE_DTO[]>(<any>null);
    }

    /**
     * @dv_QL (optional) 
     * @bkk_ID (optional) 
     * @ngay_TAO (optional) 
     * @ten_TB (optional) 
     * @tt_SAU (optional) 
     * @return Success
     */
    cTBKK_XacNhanKK_Ten(dv_QL: string | null | undefined, bkk_ID: string | null | undefined, ngay_TAO: moment.Moment | null | undefined, ten_TB: string | null | undefined, tt_SAU: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ChiTietBanKiemKe/CTBKK_XacNhanKK_Ten?";
        if (dv_QL !== undefined)
            url_ += "dv_QL=" + encodeURIComponent("" + dv_QL) + "&"; 
        if (bkk_ID !== undefined)
            url_ += "bkk_ID=" + encodeURIComponent("" + bkk_ID) + "&"; 
        if (ngay_TAO !== undefined)
            url_ += "ngay_TAO=" + encodeURIComponent(ngay_TAO ? "" + ngay_TAO.toJSON() : "") + "&"; 
        if (ten_TB !== undefined)
            url_ += "ten_TB=" + encodeURIComponent("" + ten_TB) + "&"; 
        if (tt_SAU !== undefined)
            url_ += "tt_SAU=" + encodeURIComponent("" + tt_SAU) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCTBKK_XacNhanKK_Ten(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCTBKK_XacNhanKK_Ten(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCTBKK_XacNhanKK_Ten(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @kK_ID (optional) 
     * @return Success
     */
    exportExcel(kK_ID: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/ChiTietBanKiemKe/ExportExcel?";
        if (kK_ID !== undefined)
            url_ += "KK_ID=" + encodeURIComponent("" + kK_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class ChiTietThietBiVatTuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @tbvt_ma (optional) 
     * @return Success
     */
    getById(tbvt_ma: string | null | undefined): Observable<ThietBiVatTu> {
        let url_ = this.baseUrl + "/api/ChiTietThietBiVatTu/GetById?";
        if (tbvt_ma !== undefined)
            url_ += "tbvt_ma=" + encodeURIComponent("" + tbvt_ma) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ThietBiVatTu>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThietBiVatTu>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ThietBiVatTu> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ThietBiVatTu.fromJS(resultData200) : new ThietBiVatTu();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThietBiVatTu>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    insert(input: ThietBiVatTu | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ChiTietThietBiVatTu/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: ThietBiVatTu | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ChiTietThietBiVatTu/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @tbvt_ma (optional) 
     * @return Success
     */
    delete(tbvt_ma: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ChiTietThietBiVatTu/Delete?";
        if (tbvt_ma !== undefined)
            url_ += "tbvt_ma=" + encodeURIComponent("" + tbvt_ma) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class ContractsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    approve(body: ContractApproveRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Contracts/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: ContractCreateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Contracts/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @bUILDING_ID (optional) 
     * @return Success
     */
    delete(bUILDING_ID: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Contracts/Delete?";
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @bUILDING_ID (optional) 
     * @return Success
     */
    getByID(bUILDING_ID: string | null | undefined): Observable<ContractTableDTO> {
        let url_ = this.baseUrl + "/api/Contracts/GetByID?";
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<ContractTableDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContractTableDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<ContractTableDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContractTableDTO.fromJS(resultData200) : new ContractTableDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContractTableDTO>(<any>null);
    }

    /**
     * @rECORD_STATUS (optional) 
     * @aUTH_STATUS (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    pagingSearch(rECORD_STATUS: string | null | undefined, aUTH_STATUS: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfContractPagingSearchDTO> {
        let url_ = this.baseUrl + "/api/Contracts/PagingSearch?";
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPagingSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPagingSearch(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContractPagingSearchDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContractPagingSearchDTO>><any>_observableThrow(response_);
        }));
    }

    protected processPagingSearch(response: HttpResponseBase): Observable<PagedResultDtoOfContractPagingSearchDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfContractPagingSearchDTO.fromJS(resultData200) : new PagedResultDtoOfContractPagingSearchDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContractPagingSearchDTO>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: ContractUpdateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Contracts/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class CTBDServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    chiTietBaoDuong_Insert(input: ChiTietBaoDuong_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Insert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Insert(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    chiTietBaoDuong_Update(input: ChiTietBaoDuong_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Update(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    chiTietBaoDuong_Delete(input: ChiTietBaoDuong_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Delete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Delete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @return Success
     */
    chiTietBaoDuong_GetById(id: string): Observable<ChiTietBaoDuong_DTO> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_GetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_GetById(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietBaoDuong_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietBaoDuong_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_GetById(response: HttpResponseBase): Observable<ChiTietBaoDuong_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChiTietBaoDuong_DTO.fromJS(resultData200) : new ChiTietBaoDuong_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietBaoDuong_DTO>(<any>null);
    }

    /**
     * @name (optional) 
     * @bdID (optional) 
     * @return Success
     */
    chiTietBaoDuong_Search(name: string | null | undefined, bdID: string | null | undefined): Observable<PagedResultDtoOfChiTietBaoDuong_DTO> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Search?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (bdID !== undefined)
            url_ += "bdID=" + encodeURIComponent("" + bdID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfChiTietBaoDuong_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfChiTietBaoDuong_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Search(response: HttpResponseBase): Observable<PagedResultDtoOfChiTietBaoDuong_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfChiTietBaoDuong_DTO.fromJS(resultData200) : new PagedResultDtoOfChiTietBaoDuong_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfChiTietBaoDuong_DTO>(<any>null);
    }

    /**
     * @return Success
     */
    chiTietBaoDuong_ByBD_ID(id: string): Observable<PagedResultDtoOfChiTietBaoDuong_DTO> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_ByBD_ID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_ByBD_ID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_ByBD_ID(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfChiTietBaoDuong_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfChiTietBaoDuong_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_ByBD_ID(response: HttpResponseBase): Observable<PagedResultDtoOfChiTietBaoDuong_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfChiTietBaoDuong_DTO.fromJS(resultData200) : new PagedResultDtoOfChiTietBaoDuong_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfChiTietBaoDuong_DTO>(<any>null);
    }

    /**
     * @return Success
     */
    chiTietBaoDuong_GetApprove_ByBD_ID(id: string): Observable<PagedResultDtoOfChiTietBaoDuong_DTO> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_GetApprove_ByBD_ID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_GetApprove_ByBD_ID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_GetApprove_ByBD_ID(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfChiTietBaoDuong_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfChiTietBaoDuong_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_GetApprove_ByBD_ID(response: HttpResponseBase): Observable<PagedResultDtoOfChiTietBaoDuong_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfChiTietBaoDuong_DTO.fromJS(resultData200) : new PagedResultDtoOfChiTietBaoDuong_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfChiTietBaoDuong_DTO>(<any>null);
    }

    /**
     * @ctbdId (optional) 
     * @return Success
     */
    chiTietBaoDuong_Approve_Insert(ctbdId: string | null | undefined): Observable<ChiTietBaoDuong_DTO[]> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Approve_Insert?";
        if (ctbdId !== undefined)
            url_ += "ctbdId=" + encodeURIComponent("" + ctbdId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Approve_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Approve_Insert(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Approve_Insert(response: HttpResponseBase): Observable<ChiTietBaoDuong_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChiTietBaoDuong_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietBaoDuong_DTO[]>(<any>null);
    }

    /**
     * @ctbdCode (optional) 
     * @return Success
     */
    chiTietBaoDuong_Approve_Delete(ctbdCode: string | null | undefined): Observable<ChiTietBaoDuong_DTO[]> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Approve_Delete?";
        if (ctbdCode !== undefined)
            url_ += "ctbdCode=" + encodeURIComponent("" + ctbdCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Approve_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Approve_Delete(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Approve_Delete(response: HttpResponseBase): Observable<ChiTietBaoDuong_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChiTietBaoDuong_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietBaoDuong_DTO[]>(<any>null);
    }

    /**
     * @ctbdCode (optional) 
     * @return Success
     */
    chiTietBaoDuong_Approve_Update(ctbdCode: string | null | undefined): Observable<ChiTietBaoDuong_DTO[]> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Approve_Update?";
        if (ctbdCode !== undefined)
            url_ += "ctbdCode=" + encodeURIComponent("" + ctbdCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Approve_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Approve_Update(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Approve_Update(response: HttpResponseBase): Observable<ChiTietBaoDuong_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChiTietBaoDuong_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietBaoDuong_DTO[]>(<any>null);
    }

    /**
     * @ctbdId (optional) 
     * @reason (optional) 
     * @return Success
     */
    chiTietBaoDuong_Deny_Insert(ctbdId: string | null | undefined, reason: string | null | undefined): Observable<ChiTietBaoDuong_DTO[]> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Deny_Insert?";
        if (ctbdId !== undefined)
            url_ += "ctbdId=" + encodeURIComponent("" + ctbdId) + "&"; 
        if (reason !== undefined)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Deny_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Deny_Insert(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Deny_Insert(response: HttpResponseBase): Observable<ChiTietBaoDuong_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChiTietBaoDuong_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietBaoDuong_DTO[]>(<any>null);
    }

    /**
     * @ctbdCode (optional) 
     * @reason (optional) 
     * @return Success
     */
    chiTietBaoDuong_Deny_Delete(ctbdCode: string | null | undefined, reason: string | null | undefined): Observable<ChiTietBaoDuong_DTO[]> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Deny_Delete?";
        if (ctbdCode !== undefined)
            url_ += "ctbdCode=" + encodeURIComponent("" + ctbdCode) + "&"; 
        if (reason !== undefined)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Deny_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Deny_Delete(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Deny_Delete(response: HttpResponseBase): Observable<ChiTietBaoDuong_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChiTietBaoDuong_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietBaoDuong_DTO[]>(<any>null);
    }

    /**
     * @ctbdCode (optional) 
     * @reason (optional) 
     * @return Success
     */
    chiTietBaoDuong_Deny_Update(ctbdCode: string | null | undefined, reason: string | null | undefined): Observable<ChiTietBaoDuong_DTO[]> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Deny_Update?";
        if (ctbdCode !== undefined)
            url_ += "ctbdCode=" + encodeURIComponent("" + ctbdCode) + "&"; 
        if (reason !== undefined)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Deny_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Deny_Update(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietBaoDuong_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Deny_Update(response: HttpResponseBase): Observable<ChiTietBaoDuong_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChiTietBaoDuong_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietBaoDuong_DTO[]>(<any>null);
    }

    /**
     * @ctbdCode (optional) 
     * @return Success
     */
    isUpdating(ctbdCode: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/CTBD/isUpdating?";
        if (ctbdCode !== undefined)
            url_ += "ctbdCode=" + encodeURIComponent("" + ctbdCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUpdating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUpdating(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsUpdating(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @ctbdCode (optional) 
     * @return Success
     */
    chiTietBaoDuong_Search_ByCode(ctbdCode: string | null | undefined): Observable<ChiTietBaoDuong_DTO> {
        let url_ = this.baseUrl + "/api/CTBD/ChiTietBaoDuong_Search_ByCode?";
        if (ctbdCode !== undefined)
            url_ += "ctbdCode=" + encodeURIComponent("" + ctbdCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChiTietBaoDuong_Search_ByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChiTietBaoDuong_Search_ByCode(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietBaoDuong_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietBaoDuong_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processChiTietBaoDuong_Search_ByCode(response: HttpResponseBase): Observable<ChiTietBaoDuong_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChiTietBaoDuong_DTO.fromJS(resultData200) : new ChiTietBaoDuong_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietBaoDuong_DTO>(<any>null);
    }
}

@Injectable()
export class CTNVServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    cTNV_GetAll(): Observable<any[]> {
        let url_ = this.baseUrl + "/api/CTNV/CTNV_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCTNV_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCTNV_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processCTNV_GetAll(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @manv (optional) 
     * @return Success
     */
    cTNV_ById(manv: string | null | undefined): Observable<ChiTietNhanVien_DTO> {
        let url_ = this.baseUrl + "/api/CTNV/CTNV_ById?";
        if (manv !== undefined)
            url_ += "manv=" + encodeURIComponent("" + manv) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCTNV_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCTNV_ById(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietNhanVien_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietNhanVien_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processCTNV_ById(response: HttpResponseBase): Observable<ChiTietNhanVien_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ChiTietNhanVien_DTO.fromJS(resultData200) : new ChiTietNhanVien_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietNhanVien_DTO>(<any>null);
    }

    /**
     * @cTNV_MANV (optional) 
     * @cTNV_TEN_NV (optional) 
     * @cTNV_CHUC_VU (optional) 
     * @cTNV_SDT (optional) 
     * @cTNV_PHONG_BAN (optional) 
     * @cTNV_CMND (optional) 
     * @cTNV_DIA_CHI (optional) 
     * @cTNV_NGAY_CAP_CMND (optional) 
     * @cTNV_NOI_CAP_CMND (optional) 
     * @cTNV_MA_SO_THUE (optional) 
     * @cTNV_TRANG_THAI_HOAT_DONG (optional) 
     * @cTNV_EMAIL (optional) 
     * @cTNV_MO_TA (optional) 
     * @rECORD_STATUS (optional) 
     * @mAKER_ID (optional) 
     * @cREATE_DT (optional) 
     * @aUTH_STATUS (optional) 
     * @cHECKER_ID (optional) 
     * @aPPROVE_DT (optional) 
     * @return Success
     */
    cTNV_Search(cTNV_MANV: string | null | undefined, cTNV_TEN_NV: string | null | undefined, cTNV_CHUC_VU: string | null | undefined, cTNV_SDT: string | null | undefined, cTNV_PHONG_BAN: string | null | undefined, cTNV_CMND: string | null | undefined, cTNV_DIA_CHI: string | null | undefined, cTNV_NGAY_CAP_CMND: moment.Moment | null | undefined, cTNV_NOI_CAP_CMND: string | null | undefined, cTNV_MA_SO_THUE: string | null | undefined, cTNV_TRANG_THAI_HOAT_DONG: string | null | undefined, cTNV_EMAIL: string | null | undefined, cTNV_MO_TA: string | null | undefined, rECORD_STATUS: string | null | undefined, mAKER_ID: string | null | undefined, cREATE_DT: moment.Moment | null | undefined, aUTH_STATUS: string | null | undefined, cHECKER_ID: string | null | undefined, aPPROVE_DT: moment.Moment | null | undefined): Observable<ChiTietNhanVien_DTO[]> {
        let url_ = this.baseUrl + "/api/CTNV/CTNV_Search?";
        if (cTNV_MANV !== undefined)
            url_ += "CTNV_MANV=" + encodeURIComponent("" + cTNV_MANV) + "&"; 
        if (cTNV_TEN_NV !== undefined)
            url_ += "CTNV_TEN_NV=" + encodeURIComponent("" + cTNV_TEN_NV) + "&"; 
        if (cTNV_CHUC_VU !== undefined)
            url_ += "CTNV_CHUC_VU=" + encodeURIComponent("" + cTNV_CHUC_VU) + "&"; 
        if (cTNV_SDT !== undefined)
            url_ += "CTNV_SDT=" + encodeURIComponent("" + cTNV_SDT) + "&"; 
        if (cTNV_PHONG_BAN !== undefined)
            url_ += "CTNV_PHONG_BAN=" + encodeURIComponent("" + cTNV_PHONG_BAN) + "&"; 
        if (cTNV_CMND !== undefined)
            url_ += "CTNV_CMND=" + encodeURIComponent("" + cTNV_CMND) + "&"; 
        if (cTNV_DIA_CHI !== undefined)
            url_ += "CTNV_DIA_CHI=" + encodeURIComponent("" + cTNV_DIA_CHI) + "&"; 
        if (cTNV_NGAY_CAP_CMND !== undefined)
            url_ += "CTNV_NGAY_CAP_CMND=" + encodeURIComponent(cTNV_NGAY_CAP_CMND ? "" + cTNV_NGAY_CAP_CMND.toJSON() : "") + "&"; 
        if (cTNV_NOI_CAP_CMND !== undefined)
            url_ += "CTNV_NOI_CAP_CMND=" + encodeURIComponent("" + cTNV_NOI_CAP_CMND) + "&"; 
        if (cTNV_MA_SO_THUE !== undefined)
            url_ += "CTNV_MA_SO_THUE=" + encodeURIComponent("" + cTNV_MA_SO_THUE) + "&"; 
        if (cTNV_TRANG_THAI_HOAT_DONG !== undefined)
            url_ += "CTNV_TRANG_THAI_HOAT_DONG=" + encodeURIComponent("" + cTNV_TRANG_THAI_HOAT_DONG) + "&"; 
        if (cTNV_EMAIL !== undefined)
            url_ += "CTNV_EMAIL=" + encodeURIComponent("" + cTNV_EMAIL) + "&"; 
        if (cTNV_MO_TA !== undefined)
            url_ += "CTNV_MO_TA=" + encodeURIComponent("" + cTNV_MO_TA) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (mAKER_ID !== undefined)
            url_ += "MAKER_ID=" + encodeURIComponent("" + mAKER_ID) + "&"; 
        if (cREATE_DT !== undefined)
            url_ += "CREATE_DT=" + encodeURIComponent(cREATE_DT ? "" + cREATE_DT.toJSON() : "") + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (cHECKER_ID !== undefined)
            url_ += "CHECKER_ID=" + encodeURIComponent("" + cHECKER_ID) + "&"; 
        if (aPPROVE_DT !== undefined)
            url_ += "APPROVE_DT=" + encodeURIComponent(aPPROVE_DT ? "" + aPPROVE_DT.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCTNV_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCTNV_Search(<any>response_);
                } catch (e) {
                    return <Observable<ChiTietNhanVien_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChiTietNhanVien_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processCTNV_Search(response: HttpResponseBase): Observable<ChiTietNhanVien_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ChiTietNhanVien_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietNhanVien_DTO[]>(<any>null);
    }

    /**
     * @filter_input (optional) 
     * @return Success
     */
    cTNV_Insert(filter_input: ChiTietNhanVien_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/CTNV/CTNV_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter_input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCTNV_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCTNV_Insert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processCTNV_Insert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @cTNV_MANV (optional) 
     * @cTNV_TEN_NV (optional) 
     * @cTNV_CHUC_VU (optional) 
     * @cTNV_SDT (optional) 
     * @cTNV_PHONG_BAN (optional) 
     * @cTNV_CMND (optional) 
     * @cTNV_DIA_CHI (optional) 
     * @cTNV_NGAY_CAP_CMND (optional) 
     * @cTNV_NOI_CAP_CMND (optional) 
     * @cTNV_MA_SO_THUE (optional) 
     * @cTNV_TRANG_THAI_HOAT_DONG (optional) 
     * @cTNV_EMAIL (optional) 
     * @cTNV_MO_TA (optional) 
     * @rECORD_STATUS (optional) 
     * @mAKER_ID (optional) 
     * @cREATE_DT (optional) 
     * @aUTH_STATUS (optional) 
     * @cHECKER_ID (optional) 
     * @aPPROVE_DT (optional) 
     * @return Success
     */
    cTNV_Update(cTNV_MANV: string | null | undefined, cTNV_TEN_NV: string | null | undefined, cTNV_CHUC_VU: string | null | undefined, cTNV_SDT: string | null | undefined, cTNV_PHONG_BAN: string | null | undefined, cTNV_CMND: string | null | undefined, cTNV_DIA_CHI: string | null | undefined, cTNV_NGAY_CAP_CMND: moment.Moment | null | undefined, cTNV_NOI_CAP_CMND: string | null | undefined, cTNV_MA_SO_THUE: string | null | undefined, cTNV_TRANG_THAI_HOAT_DONG: string | null | undefined, cTNV_EMAIL: string | null | undefined, cTNV_MO_TA: string | null | undefined, rECORD_STATUS: string | null | undefined, mAKER_ID: string | null | undefined, cREATE_DT: moment.Moment | null | undefined, aUTH_STATUS: string | null | undefined, cHECKER_ID: string | null | undefined, aPPROVE_DT: moment.Moment | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/CTNV/CTNV_Update?";
        if (cTNV_MANV !== undefined)
            url_ += "CTNV_MANV=" + encodeURIComponent("" + cTNV_MANV) + "&"; 
        if (cTNV_TEN_NV !== undefined)
            url_ += "CTNV_TEN_NV=" + encodeURIComponent("" + cTNV_TEN_NV) + "&"; 
        if (cTNV_CHUC_VU !== undefined)
            url_ += "CTNV_CHUC_VU=" + encodeURIComponent("" + cTNV_CHUC_VU) + "&"; 
        if (cTNV_SDT !== undefined)
            url_ += "CTNV_SDT=" + encodeURIComponent("" + cTNV_SDT) + "&"; 
        if (cTNV_PHONG_BAN !== undefined)
            url_ += "CTNV_PHONG_BAN=" + encodeURIComponent("" + cTNV_PHONG_BAN) + "&"; 
        if (cTNV_CMND !== undefined)
            url_ += "CTNV_CMND=" + encodeURIComponent("" + cTNV_CMND) + "&"; 
        if (cTNV_DIA_CHI !== undefined)
            url_ += "CTNV_DIA_CHI=" + encodeURIComponent("" + cTNV_DIA_CHI) + "&"; 
        if (cTNV_NGAY_CAP_CMND !== undefined)
            url_ += "CTNV_NGAY_CAP_CMND=" + encodeURIComponent(cTNV_NGAY_CAP_CMND ? "" + cTNV_NGAY_CAP_CMND.toJSON() : "") + "&"; 
        if (cTNV_NOI_CAP_CMND !== undefined)
            url_ += "CTNV_NOI_CAP_CMND=" + encodeURIComponent("" + cTNV_NOI_CAP_CMND) + "&"; 
        if (cTNV_MA_SO_THUE !== undefined)
            url_ += "CTNV_MA_SO_THUE=" + encodeURIComponent("" + cTNV_MA_SO_THUE) + "&"; 
        if (cTNV_TRANG_THAI_HOAT_DONG !== undefined)
            url_ += "CTNV_TRANG_THAI_HOAT_DONG=" + encodeURIComponent("" + cTNV_TRANG_THAI_HOAT_DONG) + "&"; 
        if (cTNV_EMAIL !== undefined)
            url_ += "CTNV_EMAIL=" + encodeURIComponent("" + cTNV_EMAIL) + "&"; 
        if (cTNV_MO_TA !== undefined)
            url_ += "CTNV_MO_TA=" + encodeURIComponent("" + cTNV_MO_TA) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (mAKER_ID !== undefined)
            url_ += "MAKER_ID=" + encodeURIComponent("" + mAKER_ID) + "&"; 
        if (cREATE_DT !== undefined)
            url_ += "CREATE_DT=" + encodeURIComponent(cREATE_DT ? "" + cREATE_DT.toJSON() : "") + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (cHECKER_ID !== undefined)
            url_ += "CHECKER_ID=" + encodeURIComponent("" + cHECKER_ID) + "&"; 
        if (aPPROVE_DT !== undefined)
            url_ += "APPROVE_DT=" + encodeURIComponent(aPPROVE_DT ? "" + aPPROVE_DT.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCTNV_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCTNV_Update(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processCTNV_Update(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @manv (optional) 
     * @return Success
     */
    cTNV_Delete(manv: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/CTNV/CTNV_Delete?";
        if (manv !== undefined)
            url_ += "manv=" + encodeURIComponent("" + manv) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCTNV_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCTNV_Delete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCTNV_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DashboardYCSCServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getYCSCStatistics(incomeStatisticsDateInterval: IncomeStatisticsDateInterval | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<YCSCStatisticsOutput_DTO[]> {
        let url_ = this.baseUrl + "/api/DashboardYCSC/GetYCSCStatistics?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetYCSCStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetYCSCStatistics(<any>response_);
                } catch (e) {
                    return <Observable<YCSCStatisticsOutput_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<YCSCStatisticsOutput_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetYCSCStatistics(response: HttpResponseBase): Observable<YCSCStatisticsOutput_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(YCSCStatisticsOutput_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YCSCStatisticsOutput_DTO[]>(<any>null);
    }
}

@Injectable()
export class DemoModelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @value (optional) 
     * @date (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getDemoModelsByFilter(value: number | null | undefined, date: moment.Moment | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDemoModelDto> {
        let url_ = this.baseUrl + "/api/DemoModel/GetDemoModelsByFilter?";
        if (value !== undefined)
            url_ += "Value=" + encodeURIComponent("" + value) + "&"; 
        if (date !== undefined)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDemoModelsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDemoModelsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDemoModelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDemoModelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDemoModelsByFilter(response: HttpResponseBase): Observable<PagedResultDtoOfDemoModelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDemoModelDto.fromJS(resultData200) : new PagedResultDtoOfDemoModelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDemoModelDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getDemoModelForEdit(id: number | null | undefined): Observable<DemoModelInput> {
        let url_ = this.baseUrl + "/api/DemoModel/GetDemoModelForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDemoModelForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDemoModelForEdit(<any>response_);
                } catch (e) {
                    return <Observable<DemoModelInput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DemoModelInput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDemoModelForEdit(response: HttpResponseBase): Observable<DemoModelInput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DemoModelInput.fromJS(resultData200) : new DemoModelInput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DemoModelInput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    demoApi(input: DemoModelDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/DemoModel/DemoApi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDemoApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDemoApi(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDemoApi(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrEditDemoModel(input: DemoModelInput | null | undefined): Observable<DemoModelDto> {
        let url_ = this.baseUrl + "/api/DemoModel/CreateOrEditDemoModel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEditDemoModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditDemoModel(<any>response_);
                } catch (e) {
                    return <Observable<DemoModelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DemoModelDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEditDemoModel(response: HttpResponseBase): Observable<DemoModelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DemoModelDto.fromJS(resultData200) : new DemoModelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DemoModelDto>(<any>null);
    }

    /**
     * @return Success
     */
    deleteDemoModel(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/DemoModel/DeleteDemoModel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDemoModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDemoModel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDemoModel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class DeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @index (optional) 
     * @filterInput (optional) 
     * @return Success
     */
    dEVICE_Search(index: string | null | undefined, filterInput: CM_DEV_DTO | null | undefined): Observable<CM_DEV_DTO[]> {
        let url_ = this.baseUrl + "/api/Device/DEVICE_Search?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEVICE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEVICE_Search(<any>response_);
                } catch (e) {
                    return <Observable<CM_DEV_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DEV_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processDEVICE_Search(response: HttpResponseBase): Observable<CM_DEV_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_DEV_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DEV_DTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    dEVICE_Get_All_Branch(): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Device/DEVICE_Get_All_Branch";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEVICE_Get_All_Branch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEVICE_Get_All_Branch(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDEVICE_Get_All_Branch(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    dEVICE_Insert(input: CM_DEV_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Device/DEVICE_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEVICE_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEVICE_Insert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDEVICE_Insert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    dEVICE_Update(input: CM_DEV_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Device/DEVICE_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEVICE_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEVICE_Update(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDEVICE_Update(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @devID (optional) 
     * @return Success
     */
    dEVICE_Delete(devID: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Device/DEVICE_Delete?";
        if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEVICE_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEVICE_Delete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDEVICE_Delete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @return Success
     */
    dEVICE_Get_All_Name(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Device/DEVICE_Get_All_Name";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEVICE_Get_All_Name(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEVICE_Get_All_Name(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processDEVICE_Get_All_Name(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    g2_DEVICE_GETALL(): Observable<CM_DEV_DTO[]> {
        let url_ = this.baseUrl + "/api/Device/G2_DEVICE_GETALL";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processG2_DEVICE_GETALL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processG2_DEVICE_GETALL(<any>response_);
                } catch (e) {
                    return <Observable<CM_DEV_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DEV_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processG2_DEVICE_GETALL(response: HttpResponseBase): Observable<CM_DEV_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_DEV_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DEV_DTO[]>(<any>null);
    }

    /**
     * @check (optional) 
     * @devID (optional) 
     * @return Success
     */
    dEVICE_Approve(check: number | null | undefined, devID: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Device/DEVICE_Approve?";
        if (check !== undefined)
            url_ += "check=" + encodeURIComponent("" + check) + "&"; 
        if (devID !== undefined)
            url_ += "devID=" + encodeURIComponent("" + devID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEVICE_Approve(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEVICE_Approve(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDEVICE_Approve(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @return Success
     */
    get_Current_ID(): Observable<string> {
        let url_ = this.baseUrl + "/api/Device/Get_Current_ID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_Current_ID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_Current_ID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGet_Current_ID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class DonViTinhServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    maDVT(): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/DonViTinh/MaDVT";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMaDVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaDVT(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processMaDVT(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @return Success
     */
    all(): Observable<DonViTinh_DTO[]> {
        let url_ = this.baseUrl + "/api/DonViTinh/All";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(<any>response_);
                } catch (e) {
                    return <Observable<DonViTinh_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DonViTinh_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<DonViTinh_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DonViTinh_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DonViTinh_DTO[]>(<any>null);
    }

    /**
     * @createInput (optional) 
     * @return Success
     */
    create(createInput: DVTCreate_DTO | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/DonViTinh/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @updateInput (optional) 
     * @return Success
     */
    update(updateInput: DVTUpdate_DTO | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/DonViTinh/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }
}

@Injectable()
export class DoUuTienServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @dutId (optional) 
     * @return Success
     */
    dUT_ById(dutId: string | null | undefined): Observable<DUT_DTO> {
        let url_ = this.baseUrl + "/api/DoUuTien/DUT_ById?";
        if (dutId !== undefined)
            url_ += "dutId=" + encodeURIComponent("" + dutId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDUT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDUT_ById(<any>response_);
                } catch (e) {
                    return <Observable<DUT_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DUT_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processDUT_ById(response: HttpResponseBase): Observable<DUT_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DUT_DTO.fromJS(resultData200) : new DUT_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DUT_DTO>(<any>null);
    }

    /**
     * @dutId (optional) 
     * @return Success
     */
    dUT_Delete(dutId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DoUuTien/DUT_Delete?";
        if (dutId !== undefined)
            url_ += "dutId=" + encodeURIComponent("" + dutId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDUT_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDUT_Delete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDUT_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @pageNumber (optional) 
     * @pageSize (optional) 
     * @dutName (optional) 
     * @dutCode (optional) 
     * @dutDesc (optional) 
     * @record_status (optional) 
     * @sort (optional) 
     * @return Success
     */
    dUT_SearchFilter(pageNumber: number | null | undefined, pageSize: number | null | undefined, dutName: string | null | undefined, dutCode: string | null | undefined, dutDesc: string | null | undefined, record_status: string | null | undefined, sort: string | null | undefined): Observable<PageResult> {
        let url_ = this.baseUrl + "/api/DoUuTien/DUT_SearchFilter?";
        if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (dutName !== undefined)
            url_ += "dutName=" + encodeURIComponent("" + dutName) + "&"; 
        if (dutCode !== undefined)
            url_ += "dutCode=" + encodeURIComponent("" + dutCode) + "&"; 
        if (dutDesc !== undefined)
            url_ += "dutDesc=" + encodeURIComponent("" + dutDesc) + "&"; 
        if (record_status !== undefined)
            url_ += "record_status=" + encodeURIComponent("" + record_status) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDUT_SearchFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDUT_SearchFilter(<any>response_);
                } catch (e) {
                    return <Observable<PageResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageResult>><any>_observableThrow(response_);
        }));
    }

    protected processDUT_SearchFilter(response: HttpResponseBase): Observable<PageResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageResult.fromJS(resultData200) : new PageResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageResult>(<any>null);
    }

    /**
     * @dUT_CODE (optional) 
     * @dUT_NAME (optional) 
     * @dUT_DESC (optional) 
     * @dUT_LEVEL (optional) 
     * @nOTES (optional) 
     * @rECORD_STATUS (optional) 
     * @mAKER_ID (optional) 
     * @cREATE_DT (optional) 
     * @aUTH_STATUS (optional) 
     * @cHECKER_ID (optional) 
     * @aPPROVE_DT (optional) 
     * @return Success
     */
    dUT_Create(dUT_CODE: string | null | undefined, dUT_NAME: string | null | undefined, dUT_DESC: string | null | undefined, dUT_LEVEL: number | null | undefined, nOTES: string | null | undefined, rECORD_STATUS: string | null | undefined, mAKER_ID: string | null | undefined, cREATE_DT: moment.Moment | null | undefined, aUTH_STATUS: string | null | undefined, cHECKER_ID: string | null | undefined, aPPROVE_DT: moment.Moment | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DoUuTien/DUT_Create?";
        if (dUT_CODE !== undefined)
            url_ += "DUT_CODE=" + encodeURIComponent("" + dUT_CODE) + "&"; 
        if (dUT_NAME !== undefined)
            url_ += "DUT_NAME=" + encodeURIComponent("" + dUT_NAME) + "&"; 
        if (dUT_DESC !== undefined)
            url_ += "DUT_DESC=" + encodeURIComponent("" + dUT_DESC) + "&"; 
        if (dUT_LEVEL !== undefined)
            url_ += "DUT_LEVEL=" + encodeURIComponent("" + dUT_LEVEL) + "&"; 
        if (nOTES !== undefined)
            url_ += "NOTES=" + encodeURIComponent("" + nOTES) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (mAKER_ID !== undefined)
            url_ += "MAKER_ID=" + encodeURIComponent("" + mAKER_ID) + "&"; 
        if (cREATE_DT !== undefined)
            url_ += "CREATE_DT=" + encodeURIComponent(cREATE_DT ? "" + cREATE_DT.toJSON() : "") + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (cHECKER_ID !== undefined)
            url_ += "CHECKER_ID=" + encodeURIComponent("" + cHECKER_ID) + "&"; 
        if (aPPROVE_DT !== undefined)
            url_ += "APPROVE_DT=" + encodeURIComponent(aPPROVE_DT ? "" + aPPROVE_DT.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDUT_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDUT_Create(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDUT_Create(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    dUT_GetValueGenCode(): Observable<string> {
        let url_ = this.baseUrl + "/api/DoUuTien/DUT_GetValueGenCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDUT_GetValueGenCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDUT_GetValueGenCode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDUT_GetValueGenCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @dUT_ID (optional) 
     * @dUT_CODE (optional) 
     * @dUT_NAME (optional) 
     * @dUT_DESC (optional) 
     * @dUT_LEVEL (optional) 
     * @nOTES (optional) 
     * @rECORD_STATUS (optional) 
     * @mAKER_ID (optional) 
     * @cREATE_DT (optional) 
     * @aUTH_STATUS (optional) 
     * @cHECKER_ID (optional) 
     * @aPPROVE_DT (optional) 
     * @return Success
     */
    dUT_Update(dUT_ID: string | null | undefined, dUT_CODE: string | null | undefined, dUT_NAME: string | null | undefined, dUT_DESC: string | null | undefined, dUT_LEVEL: number | null | undefined, nOTES: string | null | undefined, rECORD_STATUS: string | null | undefined, mAKER_ID: string | null | undefined, cREATE_DT: moment.Moment | null | undefined, aUTH_STATUS: string | null | undefined, cHECKER_ID: string | null | undefined, aPPROVE_DT: moment.Moment | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DoUuTien/DUT_Update?";
        if (dUT_ID !== undefined)
            url_ += "DUT_ID=" + encodeURIComponent("" + dUT_ID) + "&"; 
        if (dUT_CODE !== undefined)
            url_ += "DUT_CODE=" + encodeURIComponent("" + dUT_CODE) + "&"; 
        if (dUT_NAME !== undefined)
            url_ += "DUT_NAME=" + encodeURIComponent("" + dUT_NAME) + "&"; 
        if (dUT_DESC !== undefined)
            url_ += "DUT_DESC=" + encodeURIComponent("" + dUT_DESC) + "&"; 
        if (dUT_LEVEL !== undefined)
            url_ += "DUT_LEVEL=" + encodeURIComponent("" + dUT_LEVEL) + "&"; 
        if (nOTES !== undefined)
            url_ += "NOTES=" + encodeURIComponent("" + nOTES) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (mAKER_ID !== undefined)
            url_ += "MAKER_ID=" + encodeURIComponent("" + mAKER_ID) + "&"; 
        if (cREATE_DT !== undefined)
            url_ += "CREATE_DT=" + encodeURIComponent(cREATE_DT ? "" + cREATE_DT.toJSON() : "") + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (cHECKER_ID !== undefined)
            url_ += "CHECKER_ID=" + encodeURIComponent("" + cHECKER_ID) + "&"; 
        if (aPPROVE_DT !== undefined)
            url_ += "APPROVE_DT=" + encodeURIComponent(aPPROVE_DT ? "" + aPPROVE_DT.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDUT_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDUT_Update(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDUT_Update(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    dUT_GetLevel(): Observable<void> {
        let url_ = this.baseUrl + "/api/DoUuTien/DUT_GetLevel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDUT_GetLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDUT_GetLevel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDUT_GetLevel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DVTServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @dvtId (optional) 
     * @return Success
     */
    cM_DVT_Delete(dvtId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/DVT/CM_DVT_Delete?";
        if (dvtId !== undefined)
            url_ += "dvtId=" + encodeURIComponent("" + dvtId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DVT_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DVT_Delete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DVT_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @dvtCode (optional) 
     * @dvtName (optional) 
     * @record_status (optional) 
     * @return Success
     */
    cM_DVT_Search(dvtCode: string | null | undefined, dvtName: string | null | undefined, record_status: string | null | undefined): Observable<DVT_DTO[]> {
        let url_ = this.baseUrl + "/api/DVT/CM_DVT_Search?";
        if (dvtCode !== undefined)
            url_ += "dvtCode=" + encodeURIComponent("" + dvtCode) + "&"; 
        if (dvtName !== undefined)
            url_ += "dvtName=" + encodeURIComponent("" + dvtName) + "&"; 
        if (record_status !== undefined)
            url_ += "record_status=" + encodeURIComponent("" + record_status) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DVT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DVT_Search(<any>response_);
                } catch (e) {
                    return <Observable<DVT_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DVT_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DVT_Search(response: HttpResponseBase): Observable<DVT_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DVT_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DVT_DTO[]>(<any>null);
    }

    /**
     * @dvtId (optional) 
     * @return Success
     */
    cM_DVT_ById(dvtId: string | null | undefined): Observable<DVT_DTO> {
        let url_ = this.baseUrl + "/api/DVT/CM_DVT_ById?";
        if (dvtId !== undefined)
            url_ += "dvtId=" + encodeURIComponent("" + dvtId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DVT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DVT_ById(<any>response_);
                } catch (e) {
                    return <Observable<DVT_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<DVT_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DVT_ById(response: HttpResponseBase): Observable<DVT_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DVT_DTO.fromJS(resultData200) : new DVT_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DVT_DTO>(<any>null);
    }

    /**
     * @pageNumber (optional) 
     * @pageSize (optional) 
     * @dvtCode (optional) 
     * @dvtName (optional) 
     * @record_status (optional) 
     * @return Success
     */
    cM_DVT_searchFilter(pageNumber: number | null | undefined, pageSize: number | null | undefined, dvtCode: string | null | undefined, dvtName: string | null | undefined, record_status: string | null | undefined): Observable<PageResult> {
        let url_ = this.baseUrl + "/api/DVT/CM_DVT_searchFilter?";
        if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (dvtCode !== undefined)
            url_ += "dvtCode=" + encodeURIComponent("" + dvtCode) + "&"; 
        if (dvtName !== undefined)
            url_ += "dvtName=" + encodeURIComponent("" + dvtName) + "&"; 
        if (record_status !== undefined)
            url_ += "record_status=" + encodeURIComponent("" + record_status) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DVT_searchFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DVT_searchFilter(<any>response_);
                } catch (e) {
                    return <Observable<PageResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DVT_searchFilter(response: HttpResponseBase): Observable<PageResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageResult.fromJS(resultData200) : new PageResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageResult>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateEdition(input: CreateOrUpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateOrUpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @selectedEditionId (optional) 
     * @addAllItem (optional) 
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class EnumeratedTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: EnumeratedTypeCreateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/EnumeratedTypes/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @iD (optional) 
     * @return Success
     */
    delete(iD: number | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/EnumeratedTypes/Delete?";
        if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @tYPE (optional) 
     * @return Success
     */
    getByType(tYPE: string | null | undefined): Observable<EnumeratedTypeTableDTO[]> {
        let url_ = this.baseUrl + "/api/EnumeratedTypes/GetByType?";
        if (tYPE !== undefined)
            url_ += "TYPE=" + encodeURIComponent("" + tYPE) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByType(<any>response_);
                } catch (e) {
                    return <Observable<EnumeratedTypeTableDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumeratedTypeTableDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByType(response: HttpResponseBase): Observable<EnumeratedTypeTableDTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EnumeratedTypeTableDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumeratedTypeTableDTO[]>(<any>null);
    }
}

@Injectable()
export class EquipmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    wORK_ORDER_Search(filterInput: CM_EQUIP_DTO | null | undefined): Observable<CM_EQUIP_DTO[]> {
        let url_ = this.baseUrl + "/api/Equipment/WORK_ORDER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWORK_ORDER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWORK_ORDER_Search(<any>response_);
                } catch (e) {
                    return <Observable<CM_EQUIP_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_EQUIP_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processWORK_ORDER_Search(response: HttpResponseBase): Observable<CM_EQUIP_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_EQUIP_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_EQUIP_DTO[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    cM_Equipment_Insert(input: CM_EQUIP_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Equipment/CM_Equipment_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_Equipment_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_Equipment_Insert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_Equipment_Insert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @wO_NAME (optional) 
     * @return Success
     */
    cM_Equipment_GetCode_WO(wO_NAME: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Equipment/CM_Equipment_GetCode_WO?";
        if (wO_NAME !== undefined)
            url_ += "WO_NAME=" + encodeURIComponent("" + wO_NAME) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_Equipment_GetCode_WO(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_Equipment_GetCode_WO(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCM_Equipment_GetCode_WO(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class FloorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @createInput (optional) 
     * @return Success
     */
    create(createInput: FloorCreate_DTO | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Floor/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<Floor_DTO[]> {
        let url_ = this.baseUrl + "/api/Floor/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<Floor_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Floor_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Floor_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Floor_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Floor_DTO[]>(<any>null);
    }

    /**
     * @buildingId (optional) 
     * @return Success
     */
    getByBuildingId(buildingId: string | null | undefined): Observable<Floor_DTO[]> {
        let url_ = this.baseUrl + "/api/Floor/GetByBuildingId?";
        if (buildingId !== undefined)
            url_ += "buildingId=" + encodeURIComponent("" + buildingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByBuildingId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByBuildingId(<any>response_);
                } catch (e) {
                    return <Observable<Floor_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Floor_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByBuildingId(response: HttpResponseBase): Observable<Floor_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Floor_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Floor_DTO[]>(<any>null);
    }

    /**
     * @floorId (optional) 
     * @return Success
     */
    getById(floorId: string | null | undefined): Observable<Floor_DTO> {
        let url_ = this.baseUrl + "/api/Floor/GetById?";
        if (floorId !== undefined)
            url_ += "floorId=" + encodeURIComponent("" + floorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<Floor_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<Floor_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Floor_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Floor_DTO.fromJS(resultData200) : new Floor_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Floor_DTO>(<any>null);
    }

    /**
     * @updateInput (optional) 
     * @return Success
     */
    update(updateInput: FloorUpdate_DTO | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Floor/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorId (optional) 
     * @return Success
     */
    approveAdd(floorId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Floor/ApproveAdd?";
        if (floorId !== undefined)
            url_ += "floorId=" + encodeURIComponent("" + floorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveAdd(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveAdd(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorId (optional) 
     * @return Success
     */
    cancelApproveAdd(floorId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Floor/CancelApproveAdd?";
        if (floorId !== undefined)
            url_ += "floorId=" + encodeURIComponent("" + floorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelApproveAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelApproveAdd(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancelApproveAdd(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorId (optional) 
     * @return Success
     */
    approveUpdate(floorId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Floor/ApproveUpdate?";
        if (floorId !== undefined)
            url_ += "floorId=" + encodeURIComponent("" + floorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveUpdate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    cancelApproveUpdate(floorTypeId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Floor/CancelApproveUpdate?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelApproveUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelApproveUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancelApproveUpdate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    getApproveOfId(floorTypeId: string | null | undefined): Observable<Floor_DTO> {
        let url_ = this.baseUrl + "/api/Floor/GetApproveOfId?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApproveOfId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApproveOfId(<any>response_);
                } catch (e) {
                    return <Observable<Floor_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<Floor_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetApproveOfId(response: HttpResponseBase): Observable<Floor_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Floor_DTO.fromJS(resultData200) : new Floor_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Floor_DTO>(<any>null);
    }

    /**
     * @floorId (optional) 
     * @return Success
     */
    delete(floorId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Floor/Delete?";
        if (floorId !== undefined)
            url_ += "floorId=" + encodeURIComponent("" + floorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorId (optional) 
     * @return Success
     */
    approveDelete(floorId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Floor/ApproveDelete?";
        if (floorId !== undefined)
            url_ += "floorId=" + encodeURIComponent("" + floorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveDelete(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorId (optional) 
     * @return Success
     */
    cancelApproveDelete(floorId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Floor/CancelApproveDelete?";
        if (floorId !== undefined)
            url_ += "floorId=" + encodeURIComponent("" + floorId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelApproveDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelApproveDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancelApproveDelete(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @buildingId (optional) 
     * @return Success
     */
    export(buildingId: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Floor/Export?";
        if (buildingId !== undefined)
            url_ += "buildingId=" + encodeURIComponent("" + buildingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class FloorsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    approve(body: FloorApproveRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Floors/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: FloorCreateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Floors/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @bUILDING_ID (optional) 
     * @return Success
     */
    delete(bUILDING_ID: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Floors/Delete?";
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @bUILDING_ID (optional) 
     * @return Success
     */
    getByID(bUILDING_ID: string | null | undefined): Observable<FloorTableDTO> {
        let url_ = this.baseUrl + "/api/Floors/GetByID?";
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<FloorTableDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<FloorTableDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<FloorTableDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FloorTableDTO.fromJS(resultData200) : new FloorTableDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FloorTableDTO>(<any>null);
    }

    /**
     * @fLOOR_CODE (optional) 
     * @fLOOR_NAME (optional) 
     * @fLOORTYPE_ID (optional) 
     * @bUILDING_ID (optional) 
     * @rECORD_STATUS (optional) 
     * @aUTH_STATUS (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    pagingSearch(fLOOR_CODE: string | null | undefined, fLOOR_NAME: string | null | undefined, fLOORTYPE_ID: string | null | undefined, bUILDING_ID: string | null | undefined, rECORD_STATUS: string | null | undefined, aUTH_STATUS: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfFloorPagingSearchDTO> {
        let url_ = this.baseUrl + "/api/Floors/PagingSearch?";
        if (fLOOR_CODE !== undefined)
            url_ += "FLOOR_CODE=" + encodeURIComponent("" + fLOOR_CODE) + "&"; 
        if (fLOOR_NAME !== undefined)
            url_ += "FLOOR_NAME=" + encodeURIComponent("" + fLOOR_NAME) + "&"; 
        if (fLOORTYPE_ID !== undefined)
            url_ += "FLOORTYPE_ID=" + encodeURIComponent("" + fLOORTYPE_ID) + "&"; 
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPagingSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPagingSearch(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfFloorPagingSearchDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfFloorPagingSearchDTO>><any>_observableThrow(response_);
        }));
    }

    protected processPagingSearch(response: HttpResponseBase): Observable<PagedResultDtoOfFloorPagingSearchDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfFloorPagingSearchDTO.fromJS(resultData200) : new PagedResultDtoOfFloorPagingSearchDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfFloorPagingSearchDTO>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: FloorUpdateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Floors/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class FloorTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    getById(floorTypeId: string | null | undefined): Observable<FloorType_DTO> {
        let url_ = this.baseUrl + "/api/FloorType/GetById?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<FloorType_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<FloorType_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<FloorType_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FloorType_DTO.fromJS(resultData200) : new FloorType_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FloorType_DTO>(<any>null);
    }

    /**
     * @createInput (optional) 
     * @return Success
     */
    create(createInput: FloorTypeCreate_DTO | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/FloorType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorType_CODE (optional) 
     * @floorType_NAME (optional) 
     * @return Success
     */
    search(floorType_CODE: string | null | undefined, floorType_NAME: string | null | undefined): Observable<FloorType_DTO[]> {
        let url_ = this.baseUrl + "/api/FloorType/Search?";
        if (floorType_CODE !== undefined)
            url_ += "FloorType_CODE=" + encodeURIComponent("" + floorType_CODE) + "&"; 
        if (floorType_NAME !== undefined)
            url_ += "FloorType_NAME=" + encodeURIComponent("" + floorType_NAME) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<FloorType_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FloorType_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<FloorType_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FloorType_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FloorType_DTO[]>(<any>null);
    }

    /**
     * @updateInput (optional) 
     * @return Success
     */
    update(updateInput: FloorTypeUpdate_DTO | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/FloorType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @updateInput (optional) 
     * @return Success
     */
    delete(updateInput: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/FloorType/Delete?";
        if (updateInput !== undefined)
            url_ += "updateInput=" + encodeURIComponent("" + updateInput) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<FloorType_DTO[]> {
        let url_ = this.baseUrl + "/api/FloorType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<FloorType_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FloorType_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FloorType_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FloorType_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FloorType_DTO[]>(<any>null);
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    approveAdd(floorTypeId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/FloorType/ApproveAdd?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveAdd(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveAdd(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    cancelApproveAdd(floorTypeId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/FloorType/CancelApproveAdd?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelApproveAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelApproveAdd(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancelApproveAdd(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    approveUpdate(floorTypeId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/FloorType/ApproveUpdate?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveUpdate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    cancelApproveUpdate(floorTypeId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/FloorType/CancelApproveUpdate?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelApproveUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelApproveUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancelApproveUpdate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    getApproveOfId(floorTypeId: string | null | undefined): Observable<FloorType_DTO> {
        let url_ = this.baseUrl + "/api/FloorType/GetApproveOfId?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApproveOfId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApproveOfId(<any>response_);
                } catch (e) {
                    return <Observable<FloorType_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<FloorType_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetApproveOfId(response: HttpResponseBase): Observable<FloorType_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FloorType_DTO.fromJS(resultData200) : new FloorType_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FloorType_DTO>(<any>null);
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    approveDelete(floorTypeId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/FloorType/ApproveDelete?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processApproveDelete(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }

    /**
     * @floorTypeId (optional) 
     * @return Success
     */
    cancelApproveDelete(floorTypeId: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/FloorType/CancelApproveDelete?";
        if (floorTypeId !== undefined)
            url_ += "floorTypeId=" + encodeURIComponent("" + floorTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelApproveDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelApproveDelete(<any>response_);
                } catch (e) {
                    return <Observable<ServiceResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ServiceResult>><any>_observableThrow(response_);
        }));
    }

    protected processCancelApproveDelete(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceResult.fromJS(resultData200) : new ServiceResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ServiceResult>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: IncomeStatisticsDateInterval2 | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @incomeStatisticsDateInterval (optional) 
     * @return Success
     */
    getIncomeStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, incomeStatisticsDateInterval: IncomeStatisticsDateInterval3 | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setup(input: InstallDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class KiemKeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    kiemKe_Insert(input: KIEMKE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/KiemKe/KiemKe_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKiemKe_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKiemKe_Insert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processKiemKe_Insert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    kiemKe_GetAll(filterInput: KIEMKE_DTO | null | undefined): Observable<KIEMKE_DTO[]> {
        let url_ = this.baseUrl + "/api/KiemKe/KiemKe_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKiemKe_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKiemKe_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<KIEMKE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KIEMKE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processKiemKe_GetAll(response: HttpResponseBase): Observable<KIEMKE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(KIEMKE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KIEMKE_DTO[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    kiemKe_Update(input: KIEMKE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/KiemKe/KiemKe_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKiemKe_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKiemKe_Update(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processKiemKe_Update(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @kiemKeId (optional) 
     * @return Success
     */
    kiemKe_Delete(kiemKeId: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/KiemKe/KiemKe_Delete?";
        if (kiemKeId !== undefined)
            url_ += "kiemKeId=" + encodeURIComponent("" + kiemKeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKiemKe_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKiemKe_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processKiemKe_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @id (optional) 
     * @status (optional) 
     * @return Success
     */
    kiemKe_Close(id: string | null | undefined, status: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/KiemKe/KiemKe_Close?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKiemKe_Close(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKiemKe_Close(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processKiemKe_Close(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @dv_QL (optional) 
     * @bkk_ID (optional) 
     * @ngay_TAO (optional) 
     * @return Success
     */
    bKK_CHECK(dv_QL: string | null | undefined, bkk_ID: string | null | undefined, ngay_TAO: moment.Moment | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/KiemKe/BKK_CHECK?";
        if (dv_QL !== undefined)
            url_ += "dv_QL=" + encodeURIComponent("" + dv_QL) + "&"; 
        if (bkk_ID !== undefined)
            url_ += "bkk_ID=" + encodeURIComponent("" + bkk_ID) + "&"; 
        if (ngay_TAO !== undefined)
            url_ += "ngay_TAO=" + encodeURIComponent(ngay_TAO ? "" + ngay_TAO.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBKK_CHECK(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBKK_CHECK(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBKK_CHECK(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @kiemkeId (optional) 
     * @return Success
     */
    kiemKeById(kiemkeId: string | null | undefined): Observable<KIEM_KE_DTO> {
        let url_ = this.baseUrl + "/api/KiemKe/KiemKeById?";
        if (kiemkeId !== undefined)
            url_ += "kiemkeId=" + encodeURIComponent("" + kiemkeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKiemKeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKiemKeById(<any>response_);
                } catch (e) {
                    return <Observable<KIEM_KE_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<KIEM_KE_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processKiemKeById(response: HttpResponseBase): Observable<KIEM_KE_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? KIEM_KE_DTO.fromJS(resultData200) : new KIEM_KE_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KIEM_KE_DTO>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    kiemKeUpdate(input: KIEM_KE_DTO | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/KiemKe/KiemKeUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKiemKeUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKiemKeUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processKiemKeUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    kiemKeInsert(input: KIEM_KE_DTO | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/KiemKe/KiemKeInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKiemKeInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKiemKeInsert(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processKiemKeInsert(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @branch_ID (optional) 
     * @return Success
     */
    getKiemKeDateAndCode(branch_ID: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/KiemKe/GetKiemKeDateAndCode?";
        if (branch_ID !== undefined)
            url_ += "branch_ID=" + encodeURIComponent("" + branch_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKiemKeDateAndCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKiemKeDateAndCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetKiemKeDateAndCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getBranchIdFromUserId(id: number | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/KiemKe/GetBranchIdFromUserId?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranchIdFromUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranchIdFromUserId(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBranchIdFromUserId(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    kiemKeOfflineProcess(input: CUSTOM_DTO | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/KiemKe/KiemKeOfflineProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKiemKeOfflineProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKiemKeOfflineProcess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processKiemKeOfflineProcess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @baseLanguageName (optional) 
     * @targetValueFilter (optional) 
     * @filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LoaiXeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @loaixeId (optional) 
     * @return Success
     */
    loaiXeById(loaixeId: string | null | undefined): Observable<LOAI_XE_DTO> {
        let url_ = this.baseUrl + "/api/LoaiXe/LoaiXeById?";
        if (loaixeId !== undefined)
            url_ += "loaixeId=" + encodeURIComponent("" + loaixeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiXeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiXeById(<any>response_);
                } catch (e) {
                    return <Observable<LOAI_XE_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<LOAI_XE_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiXeById(response: HttpResponseBase): Observable<LOAI_XE_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LOAI_XE_DTO.fromJS(resultData200) : new LOAI_XE_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LOAI_XE_DTO>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    loaiXeInsert(input: LOAI_XE_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/LoaiXe/LoaiXeInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiXeInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiXeInsert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiXeInsert(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    loaiXeUpdate(input: LOAI_XE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/LoaiXe/LoaiXeUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiXeUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiXeUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiXeUpdate(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @loaixeId (optional) 
     * @return Success
     */
    loaiXeDelete(loaixeId: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/LoaiXe/LoaiXeDelete?";
        if (loaixeId !== undefined)
            url_ += "loaixeId=" + encodeURIComponent("" + loaixeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiXeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiXeDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiXeDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @loaixeCode (optional) 
     * @return Success
     */
    loaiXe_Approve(loaixeCode: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/LoaiXe/LoaiXe_Approve?";
        if (loaixeCode !== undefined)
            url_ += "loaixeCode=" + encodeURIComponent("" + loaixeCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiXe_Approve(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiXe_Approve(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiXe_Approve(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @loaixeCode (optional) 
     * @return Success
     */
    loaiXe_UnApprove(loaixeCode: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/LoaiXe/LoaiXe_UnApprove?";
        if (loaixeCode !== undefined)
            url_ += "loaixeCode=" + encodeURIComponent("" + loaixeCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiXe_UnApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiXe_UnApprove(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiXe_UnApprove(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    loaiXeSearch(filterInput: LOAI_XE_DTO | null | undefined): Observable<LOAI_XE_DTO[]> {
        let url_ = this.baseUrl + "/api/LoaiXe/LoaiXeSearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiXeSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiXeSearch(<any>response_);
                } catch (e) {
                    return <Observable<LOAI_XE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LOAI_XE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiXeSearch(response: HttpResponseBase): Observable<LOAI_XE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LOAI_XE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LOAI_XE_DTO[]>(<any>null);
    }

    /**
     * @toSearch (optional) 
     * @searchType (optional) 
     * @return Success
     */
    loaiXeSearchAlternative(toSearch: string | null | undefined, searchType: string | null | undefined): Observable<LOAI_XE_DTO[]> {
        let url_ = this.baseUrl + "/api/LoaiXe/LoaiXeSearchAlternative?";
        if (toSearch !== undefined)
            url_ += "toSearch=" + encodeURIComponent("" + toSearch) + "&"; 
        if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiXeSearchAlternative(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiXeSearchAlternative(<any>response_);
                } catch (e) {
                    return <Observable<LOAI_XE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LOAI_XE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiXeSearchAlternative(response: HttpResponseBase): Observable<LOAI_XE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LOAI_XE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LOAI_XE_DTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    loaiXeGetAll(): Observable<LOAI_XE_DTO[]> {
        let url_ = this.baseUrl + "/api/LoaiXe/LoaiXeGetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoaiXeGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoaiXeGetAll(<any>response_);
                } catch (e) {
                    return <Observable<LOAI_XE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LOAI_XE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processLoaiXeGetAll(response: HttpResponseBase): Observable<LOAI_XE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LOAI_XE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LOAI_XE_DTO[]>(<any>null);
    }
}

@Injectable()
export class MenuClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMenuClients(): Observable<ListResultDtoOfMenuClientDto> {
        let url_ = this.baseUrl + "/api/MenuClient/GetMenuClients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuClients(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfMenuClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfMenuClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuClients(response: HttpResponseBase): Observable<ListResultDtoOfMenuClientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfMenuClientDto.fromJS(resultData200) : new ListResultDtoOfMenuClientDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfMenuClientDto>(<any>null);
    }

    /**
     * @name (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getMenuClientsByFilter(name: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMenuClientListDto> {
        let url_ = this.baseUrl + "/api/MenuClient/GetMenuClientsByFilter?";
        if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuClientsByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuClientsByFilter(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMenuClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMenuClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuClientsByFilter(response: HttpResponseBase): Observable<PagedResultDtoOfMenuClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMenuClientListDto.fromJS(resultData200) : new PagedResultDtoOfMenuClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMenuClientListDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getMenuClientForEdit(id: number | null | undefined): Observable<GetMenuClientOutput> {
        let url_ = this.baseUrl + "/api/MenuClient/GetMenuClientForEdit?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuClientForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuClientForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMenuClientOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMenuClientOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuClientForEdit(response: HttpResponseBase): Observable<GetMenuClientOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMenuClientOutput.fromJS(resultData200) : new GetMenuClientOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMenuClientOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createMenuClient(input: CreateMenuClientInput | null | undefined): Observable<MenuClientDto> {
        let url_ = this.baseUrl + "/api/MenuClient/CreateMenuClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMenuClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMenuClient(<any>response_);
                } catch (e) {
                    return <Observable<MenuClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMenuClient(response: HttpResponseBase): Observable<MenuClientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuClientDto.fromJS(resultData200) : new MenuClientDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuClientDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateMenuClient(input: UpdateMenuClientInput | null | undefined): Observable<MenuClientDto> {
        let url_ = this.baseUrl + "/api/MenuClient/UpdateMenuClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMenuClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMenuClient(<any>response_);
                } catch (e) {
                    return <Observable<MenuClientDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuClientDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMenuClient(response: HttpResponseBase): Observable<MenuClientDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuClientDto.fromJS(resultData200) : new MenuClientDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuClientDto>(<any>null);
    }

    /**
     * @return Success
     */
    deleteMenuClient(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/MenuClient/DeleteMenuClient/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMenuClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMenuClient(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMenuClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ModelXeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    modelXe_Insert(input: MODELXE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ModelXe/ModelXe_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModelXe_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModelXe_Insert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processModelXe_Insert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    modelXe_GetAll(filterInput: MODELXE_DTO | null | undefined): Observable<MODELXE_DTO[]> {
        let url_ = this.baseUrl + "/api/ModelXe/ModelXe_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModelXe_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModelXe_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<MODELXE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MODELXE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processModelXe_GetAll(response: HttpResponseBase): Observable<MODELXE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MODELXE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MODELXE_DTO[]>(<any>null);
    }

    /**
     * @modelId (optional) 
     * @return Success
     */
    modelXe_ById(modelId: string | null | undefined): Observable<MODELXE_DTO> {
        let url_ = this.baseUrl + "/api/ModelXe/ModelXe_ById?";
        if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModelXe_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModelXe_ById(<any>response_);
                } catch (e) {
                    return <Observable<MODELXE_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<MODELXE_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processModelXe_ById(response: HttpResponseBase): Observable<MODELXE_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MODELXE_DTO.fromJS(resultData200) : new MODELXE_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MODELXE_DTO>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    modelXe_Update(input: MODELXE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ModelXe/ModelXe_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModelXe_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModelXe_Update(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processModelXe_Update(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @modelId (optional) 
     * @return Success
     */
    modelXe_Delete(modelId: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ModelXe/ModelXe_Delete?";
        if (modelId !== undefined)
            url_ += "modelId=" + encodeURIComponent("" + modelId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModelXe_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModelXe_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processModelXe_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @modelCode (optional) 
     * @return Success
     */
    modelXe_MakeCode(modelCode: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ModelXe/ModelXe_MakeCode?";
        if (modelCode !== undefined)
            url_ += "modelCode=" + encodeURIComponent("" + modelCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModelXe_MakeCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModelXe_MakeCode(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processModelXe_MakeCode(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }
}

@Injectable()
export class NhaCungUngServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllNhaCungUng(): Observable<NHACUNGUNG_DTO[]> {
        let url_ = this.baseUrl + "/api/NhaCungUng/GetAllNhaCungUng";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhaCungUng(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhaCungUng(<any>response_);
                } catch (e) {
                    return <Observable<NHACUNGUNG_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NHACUNGUNG_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhaCungUng(response: HttpResponseBase): Observable<NHACUNGUNG_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NHACUNGUNG_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NHACUNGUNG_DTO[]>(<any>null);
    }

    /**
     * @inputFilter (optional) 
     * @orderBy (optional) 
     * @desc (optional) 
     * @skip (optional) 
     * @take (optional) 
     * @return Success
     */
    searchNhaCungUng(inputFilter: NHACUNGUNG_DTO | null | undefined, orderBy: string | null | undefined, desc: boolean | null | undefined, skip: number | null | undefined, take: number | null | undefined): Observable<PagedResultDtoOfNHACUNGUNG_DTO> {
        let url_ = this.baseUrl + "/api/NhaCungUng/SearchNhaCungUng?";
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (desc !== undefined)
            url_ += "desc=" + encodeURIComponent("" + desc) + "&"; 
        if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&"; 
        if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inputFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchNhaCungUng(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchNhaCungUng(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNHACUNGUNG_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNHACUNGUNG_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processSearchNhaCungUng(response: HttpResponseBase): Observable<PagedResultDtoOfNHACUNGUNG_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNHACUNGUNG_DTO.fromJS(resultData200) : new PagedResultDtoOfNHACUNGUNG_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNHACUNGUNG_DTO>(<any>null);
    }

    /**
     * @maNhaCungUng (optional) 
     * @return Success
     */
    deleteNhaCungUng(maNhaCungUng: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/NhaCungUng/DeleteNhaCungUng?";
        if (maNhaCungUng !== undefined)
            url_ += "maNhaCungUng=" + encodeURIComponent("" + maNhaCungUng) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNhaCungUng(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNhaCungUng(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNhaCungUng(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    exportNhaCungUng(input: NHACUNGUNG_DTO | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/NhaCungUng/ExportNhaCungUng";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportNhaCungUng(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportNhaCungUng(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportNhaCungUng(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @nCU_Ma_NCU (optional) 
     * @return Success
     */
    nhaCungUngById(nCU_Ma_NCU: string | null | undefined): Observable<NHA_CUNG_UNG_DTO> {
        let url_ = this.baseUrl + "/api/NhaCungUng/NhaCungUngById?";
        if (nCU_Ma_NCU !== undefined)
            url_ += "NCU_Ma_NCU=" + encodeURIComponent("" + nCU_Ma_NCU) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNhaCungUngById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNhaCungUngById(<any>response_);
                } catch (e) {
                    return <Observable<NHA_CUNG_UNG_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<NHA_CUNG_UNG_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processNhaCungUngById(response: HttpResponseBase): Observable<NHA_CUNG_UNG_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NHA_CUNG_UNG_DTO.fromJS(resultData200) : new NHA_CUNG_UNG_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NHA_CUNG_UNG_DTO>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    nhaCungUngInsert(input: NHA_CUNG_UNG_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/NhaCungUng/NhaCungUngInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNhaCungUngInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNhaCungUngInsert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processNhaCungUngInsert(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    nhaCungUngUpdate(input: NHA_CUNG_UNG_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/NhaCungUng/NhaCungUngUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNhaCungUngUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNhaCungUngUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processNhaCungUngUpdate(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @nCU_Ma_NCU (optional) 
     * @return Success
     */
    nhaCungUngDelete(nCU_Ma_NCU: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/NhaCungUng/NhaCungUngDelete?";
        if (nCU_Ma_NCU !== undefined)
            url_ += "NCU_Ma_NCU=" + encodeURIComponent("" + nCU_Ma_NCU) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNhaCungUngDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNhaCungUngDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processNhaCungUngDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @return Success
     */
    nhaCungUngGetAll(): Observable<NHA_CUNG_UNG_DTO[]> {
        let url_ = this.baseUrl + "/api/NhaCungUng/NhaCungUngGetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNhaCungUngGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNhaCungUngGetAll(<any>response_);
                } catch (e) {
                    return <Observable<NHA_CUNG_UNG_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NHA_CUNG_UNG_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processNhaCungUngGetAll(response: HttpResponseBase): Observable<NHA_CUNG_UNG_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NHA_CUNG_UNG_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NHA_CUNG_UNG_DTO[]>(<any>null);
    }
}

@Injectable()
export class NhanVienServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllNhanVien(): Observable<NHANVIEN_DTO[]> {
        let url_ = this.baseUrl + "/api/NhanVien/GetAllNhanVien";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNhanVien(<any>response_);
                } catch (e) {
                    return <Observable<NHANVIEN_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NHANVIEN_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllNhanVien(response: HttpResponseBase): Observable<NHANVIEN_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NHANVIEN_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NHANVIEN_DTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDepartments(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/NhanVien/GetAllDepartments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartments(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDepartments(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getDepName(): Observable<NHANVIEN_DEP_NAME_DTO[]> {
        let url_ = this.baseUrl + "/api/NhanVien/GetDepName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepName(<any>response_);
                } catch (e) {
                    return <Observable<NHANVIEN_DEP_NAME_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NHANVIEN_DEP_NAME_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepName(response: HttpResponseBase): Observable<NHANVIEN_DEP_NAME_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NHANVIEN_DEP_NAME_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NHANVIEN_DEP_NAME_DTO[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    exportNhanVien(input: NHANVIEN_DTO | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/NhanVien/ExportNhanVien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportNhanVien(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportNhanVien(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @inputFilter (optional) 
     * @return Success
     */
    searchNhanVien(inputFilter: NHANVIEN_FILTER | null | undefined): Observable<PagedResultDtoOfNHANVIEN_DTO> {
        let url_ = this.baseUrl + "/api/NhanVien/SearchNhanVien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inputFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchNhanVien(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNHANVIEN_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNHANVIEN_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processSearchNhanVien(response: HttpResponseBase): Observable<PagedResultDtoOfNHANVIEN_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNHANVIEN_DTO.fromJS(resultData200) : new PagedResultDtoOfNHANVIEN_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNHANVIEN_DTO>(<any>null);
    }

    /**
     * @maNhanVien (optional) 
     * @return Success
     */
    deleteNhanVien(maNhanVien: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/NhanVien/DeleteNhanVien?";
        if (maNhanVien !== undefined)
            url_ += "maNhanVien=" + encodeURIComponent("" + maNhanVien) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNhanVien(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNhanVien(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @manv (optional) 
     * @return Success
     */
    nhanVien_ById(manv: string | null | undefined): Observable<NHANVIEN_DTO[]> {
        let url_ = this.baseUrl + "/api/NhanVien/NhanVien_ById?";
        if (manv !== undefined)
            url_ += "manv=" + encodeURIComponent("" + manv) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNhanVien_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNhanVien_ById(<any>response_);
                } catch (e) {
                    return <Observable<NHANVIEN_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NHANVIEN_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processNhanVien_ById(response: HttpResponseBase): Observable<NHANVIEN_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NHANVIEN_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NHANVIEN_DTO[]>(<any>null);
    }

    /**
     * @filter_input (optional) 
     * @return Success
     */
    insertNhanVien(filter_input: NHANVIEN_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/NhanVien/InsertNhanVien";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter_input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertNhanVien(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processInsertNhanVien(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @nV_ID (optional) 
     * @nV_MA_NV (optional) 
     * @nV_TEN (optional) 
     * @nV_PHONG_BAN (optional) 
     * @nV_TEN_PHONG_BAN (optional) 
     * @nV_CHUC_VU (optional) 
     * @nV_SDT (optional) 
     * @nV_TRANG_THAI (optional) 
     * @nV_CMND (optional) 
     * @nV_NGAY_CAP_CMND (optional) 
     * @nV_NOI_CAP_CMND (optional) 
     * @nV_MA_SO_THUE (optional) 
     * @nV_EMAIL (optional) 
     * @nV_DIA_CHI (optional) 
     * @nV_MO_TA (optional) 
     * @rECORD_STATUS (optional) 
     * @mAKER_ID (optional) 
     * @cREATE_DT (optional) 
     * @aUTH_STATUS (optional) 
     * @cHECKER_ID (optional) 
     * @aPPROVE_DT (optional) 
     * @bRANCH_CREATE (optional) 
     * @return Success
     */
    updateNhanVien(nV_ID: number | null | undefined, nV_MA_NV: string | null | undefined, nV_TEN: string | null | undefined, nV_PHONG_BAN: string | null | undefined, nV_TEN_PHONG_BAN: string | null | undefined, nV_CHUC_VU: string | null | undefined, nV_SDT: string | null | undefined, nV_TRANG_THAI: number | null | undefined, nV_CMND: string | null | undefined, nV_NGAY_CAP_CMND: moment.Moment | null | undefined, nV_NOI_CAP_CMND: string | null | undefined, nV_MA_SO_THUE: string | null | undefined, nV_EMAIL: string | null | undefined, nV_DIA_CHI: string | null | undefined, nV_MO_TA: string | null | undefined, rECORD_STATUS: string | null | undefined, mAKER_ID: string | null | undefined, cREATE_DT: moment.Moment | null | undefined, aUTH_STATUS: string | null | undefined, cHECKER_ID: string | null | undefined, aPPROVE_DT: moment.Moment | null | undefined, bRANCH_CREATE: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/NhanVien/UpdateNhanVien?";
        if (nV_ID !== undefined)
            url_ += "NV_ID=" + encodeURIComponent("" + nV_ID) + "&"; 
        if (nV_MA_NV !== undefined)
            url_ += "NV_MA_NV=" + encodeURIComponent("" + nV_MA_NV) + "&"; 
        if (nV_TEN !== undefined)
            url_ += "NV_TEN=" + encodeURIComponent("" + nV_TEN) + "&"; 
        if (nV_PHONG_BAN !== undefined)
            url_ += "NV_PHONG_BAN=" + encodeURIComponent("" + nV_PHONG_BAN) + "&"; 
        if (nV_TEN_PHONG_BAN !== undefined)
            url_ += "NV_TEN_PHONG_BAN=" + encodeURIComponent("" + nV_TEN_PHONG_BAN) + "&"; 
        if (nV_CHUC_VU !== undefined)
            url_ += "NV_CHUC_VU=" + encodeURIComponent("" + nV_CHUC_VU) + "&"; 
        if (nV_SDT !== undefined)
            url_ += "NV_SDT=" + encodeURIComponent("" + nV_SDT) + "&"; 
        if (nV_TRANG_THAI !== undefined)
            url_ += "NV_TRANG_THAI=" + encodeURIComponent("" + nV_TRANG_THAI) + "&"; 
        if (nV_CMND !== undefined)
            url_ += "NV_CMND=" + encodeURIComponent("" + nV_CMND) + "&"; 
        if (nV_NGAY_CAP_CMND !== undefined)
            url_ += "NV_NGAY_CAP_CMND=" + encodeURIComponent(nV_NGAY_CAP_CMND ? "" + nV_NGAY_CAP_CMND.toJSON() : "") + "&"; 
        if (nV_NOI_CAP_CMND !== undefined)
            url_ += "NV_NOI_CAP_CMND=" + encodeURIComponent("" + nV_NOI_CAP_CMND) + "&"; 
        if (nV_MA_SO_THUE !== undefined)
            url_ += "NV_MA_SO_THUE=" + encodeURIComponent("" + nV_MA_SO_THUE) + "&"; 
        if (nV_EMAIL !== undefined)
            url_ += "NV_EMAIL=" + encodeURIComponent("" + nV_EMAIL) + "&"; 
        if (nV_DIA_CHI !== undefined)
            url_ += "NV_DIA_CHI=" + encodeURIComponent("" + nV_DIA_CHI) + "&"; 
        if (nV_MO_TA !== undefined)
            url_ += "NV_MO_TA=" + encodeURIComponent("" + nV_MO_TA) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (mAKER_ID !== undefined)
            url_ += "MAKER_ID=" + encodeURIComponent("" + mAKER_ID) + "&"; 
        if (cREATE_DT !== undefined)
            url_ += "CREATE_DT=" + encodeURIComponent(cREATE_DT ? "" + cREATE_DT.toJSON() : "") + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (cHECKER_ID !== undefined)
            url_ += "CHECKER_ID=" + encodeURIComponent("" + cHECKER_ID) + "&"; 
        if (aPPROVE_DT !== undefined)
            url_ += "APPROVE_DT=" + encodeURIComponent(aPPROVE_DT ? "" + aPPROVE_DT.toJSON() : "") + "&"; 
        if (bRANCH_CREATE !== undefined)
            url_ += "BRANCH_CREATE=" + encodeURIComponent("" + bRANCH_CREATE) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNhanVien(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNhanVien(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNhanVien(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }
}

@Injectable()
export class NhaSanXuatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    nSX_Search(filterInput: NSX_DTO | null | undefined): Observable<PagedResultDtoOfNSX_DTO> {
        let url_ = this.baseUrl + "/api/NhaSanXuat/NSX_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNSX_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNSX_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNSX_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNSX_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processNSX_Search(response: HttpResponseBase): Observable<PagedResultDtoOfNSX_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNSX_DTO.fromJS(resultData200) : new PagedResultDtoOfNSX_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNSX_DTO>(<any>null);
    }

    /**
     * @nsxId (optional) 
     * @return Success
     */
    nSX_Delete(nsxId: string | null | undefined): Observable<NSX_DTO[]> {
        let url_ = this.baseUrl + "/api/NhaSanXuat/NSX_Delete?";
        if (nsxId !== undefined)
            url_ += "nsxId=" + encodeURIComponent("" + nsxId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNSX_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNSX_Delete(<any>response_);
                } catch (e) {
                    return <Observable<NSX_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NSX_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processNSX_Delete(response: HttpResponseBase): Observable<NSX_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NSX_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NSX_DTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    gettest(): Observable<string> {
        let url_ = this.baseUrl + "/api/NhaSanXuat/gettest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGettest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGettest(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGettest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @listInput (optional) 
     * @return Success
     */
    nSX_ExportExcel(listInput: NSX_DTO[] | null | undefined): Observable<NSX_DTO[]> {
        let url_ = this.baseUrl + "/api/NhaSanXuat/NSX_ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNSX_ExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNSX_ExportExcel(<any>response_);
                } catch (e) {
                    return <Observable<NSX_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NSX_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processNSX_ExportExcel(response: HttpResponseBase): Observable<NSX_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NSX_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NSX_DTO[]>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @state (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: State | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NSXServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    cM_NSX_GetSizeCol(colname: string): Observable<string> {
        let url_ = this.baseUrl + "/api/NSX/CM_NSX_GetSizeCol/{colname}";
        if (colname === undefined || colname === null)
            throw new Error("The parameter 'colname' must be defined.");
        url_ = url_.replace("{colname}", encodeURIComponent("" + colname)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_NSX_GetSizeCol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_NSX_GetSizeCol(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCM_NSX_GetSizeCol(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    cM_NSX_Insert(input: CM_NSX_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/NSX/CM_NSX_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_NSX_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_NSX_Insert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_NSX_Insert(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    cM_NSX_Update(input: CM_NSX_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/NSX/CM_NSX_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_NSX_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_NSX_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_NSX_Update(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @return Success
     */
    cM_NSX_Delete(id: string): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/NSX/CM_NSX_Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_NSX_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_NSX_Delete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_NSX_Delete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @return Success
     */
    cM_NSX_ById(id: string): Observable<CM_NSX_DTO> {
        let url_ = this.baseUrl + "/api/NSX/CM_NSX_ById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_NSX_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_NSX_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_NSX_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_NSX_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processCM_NSX_ById(response: HttpResponseBase): Observable<CM_NSX_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_NSX_DTO.fromJS(resultData200) : new CM_NSX_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_NSX_DTO>(<any>null);
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    cM_NSX_Search(filterInput: CM_NSX_DTO | null | undefined): Observable<PagedResultDtoOfCM_NSX_DTO> {
        let url_ = this.baseUrl + "/api/NSX/CM_NSX_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_NSX_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_NSX_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_NSX_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_NSX_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processCM_NSX_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_NSX_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_NSX_DTO.fromJS(resultData200) : new PagedResultDtoOfCM_NSX_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_NSX_DTO>(<any>null);
    }
}

@Injectable()
export class NTXServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    nguoiThueXe_Insert(input: NguoiThueXe_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/NTX/NguoiThueXe_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNguoiThueXe_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNguoiThueXe_Insert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processNguoiThueXe_Insert(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    nguoiThueXe_Update(input: NguoiThueXe_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/NTX/NguoiThueXe_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNguoiThueXe_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNguoiThueXe_Update(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processNguoiThueXe_Update(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @return Success
     */
    nguoiThueXe_Delete(id: string): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/NTX/NguoiThueXe_Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNguoiThueXe_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNguoiThueXe_Delete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processNguoiThueXe_Delete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @return Success
     */
    nguoiThueXe_ById(id: string): Observable<NguoiThueXe_DTO> {
        let url_ = this.baseUrl + "/api/NTX/NguoiThueXe_ById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNguoiThueXe_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNguoiThueXe_ById(<any>response_);
                } catch (e) {
                    return <Observable<NguoiThueXe_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<NguoiThueXe_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processNguoiThueXe_ById(response: HttpResponseBase): Observable<NguoiThueXe_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NguoiThueXe_DTO.fromJS(resultData200) : new NguoiThueXe_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NguoiThueXe_DTO>(<any>null);
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    nguoiThueXe_Search(filterInput: NguoiThueXe_DTO | null | undefined): Observable<PagedResultDtoOfNguoiThueXe_DTO> {
        let url_ = this.baseUrl + "/api/NTX/NguoiThueXe_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNguoiThueXe_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNguoiThueXe_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNguoiThueXe_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNguoiThueXe_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processNguoiThueXe_Search(response: HttpResponseBase): Observable<PagedResultDtoOfNguoiThueXe_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNguoiThueXe_DTO.fromJS(resultData200) : new PagedResultDtoOfNguoiThueXe_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNguoiThueXe_DTO>(<any>null);
    }

    /**
     * @return Success
     */
    nguoiThueXe_ByXeID(id: string): Observable<PagedResultDtoOfNguoiThueXe_DTO> {
        let url_ = this.baseUrl + "/api/NTX/NguoiThueXe_ByXeID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNguoiThueXe_ByXeID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNguoiThueXe_ByXeID(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNguoiThueXe_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNguoiThueXe_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processNguoiThueXe_ByXeID(response: HttpResponseBase): Observable<PagedResultDtoOfNguoiThueXe_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNguoiThueXe_DTO.fromJS(resultData200) : new PagedResultDtoOfNguoiThueXe_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNguoiThueXe_DTO>(<any>null);
    }

    /**
     * @return Success
     */
    nguoiThueXe_ByXeId_HienTai(id: string): Observable<NguoiThueXe_DTO> {
        let url_ = this.baseUrl + "/api/NTX/NguoiThueXe_ByXeId_HienTai/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNguoiThueXe_ByXeId_HienTai(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNguoiThueXe_ByXeId_HienTai(<any>response_);
                } catch (e) {
                    return <Observable<NguoiThueXe_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<NguoiThueXe_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processNguoiThueXe_ByXeId_HienTai(response: HttpResponseBase): Observable<NguoiThueXe_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? NguoiThueXe_DTO.fromJS(resultData200) : new NguoiThueXe_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NguoiThueXe_DTO>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @userId (optional) 
     * @organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    executePayment(input: ExecutePaymentDto | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExecutePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecutePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecutePayment(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processExecutePayment(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class PhieuCapPhatTBVTServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPCPTBVT(): Observable<PCPTBVT_DTO[]> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/GetAllPCPTBVT";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<PCPTBVT_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PCPTBVT_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPCPTBVT(response: HttpResponseBase): Observable<PCPTBVT_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PCPTBVT_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PCPTBVT_DTO[]>(<any>null);
    }

    /**
     * @inputFilter (optional) 
     * @orderBy (optional) 
     * @desc (optional) 
     * @skip (optional) 
     * @take (optional) 
     * @return Success
     */
    filterPCPTBVT(inputFilter: PCPTBVT_DTO | null | undefined, orderBy: string | null | undefined, desc: boolean | null | undefined, skip: number | null | undefined, take: number | null | undefined): Observable<PagedResultDtoOfPCPTBVT_DTO> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/FilterPCPTBVT?";
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (desc !== undefined)
            url_ += "desc=" + encodeURIComponent("" + desc) + "&"; 
        if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&"; 
        if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inputFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilterPCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilterPCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPCPTBVT_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPCPTBVT_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processFilterPCPTBVT(response: HttpResponseBase): Observable<PagedResultDtoOfPCPTBVT_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPCPTBVT_DTO.fromJS(resultData200) : new PagedResultDtoOfPCPTBVT_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPCPTBVT_DTO>(<any>null);
    }

    /**
     * @inputFilter (optional) 
     * @orderBy (optional) 
     * @desc (optional) 
     * @skip (optional) 
     * @take (optional) 
     * @return Success
     */
    searchPCPTBVT(inputFilter: PCPTBVT_SEARCH_DTO | null | undefined, orderBy: string | null | undefined, desc: boolean | null | undefined, skip: number | null | undefined, take: number | null | undefined): Observable<PagedResultDtoOfPCPTBVT_DTO> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/SearchPCPTBVT?";
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (desc !== undefined)
            url_ += "desc=" + encodeURIComponent("" + desc) + "&"; 
        if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&"; 
        if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inputFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPCPTBVT_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPCPTBVT_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processSearchPCPTBVT(response: HttpResponseBase): Observable<PagedResultDtoOfPCPTBVT_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPCPTBVT_DTO.fromJS(resultData200) : new PagedResultDtoOfPCPTBVT_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPCPTBVT_DTO>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    insertPCPTBVT(input: PCPTBVT_INSERT_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/InsertPCPTBVT";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertPCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertPCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processInsertPCPTBVT(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updatePCPTBVT(input: PCPTBVT_UPDATE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/UpdatePCPTBVT";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePCPTBVT(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    approvePCPTBVT(input: PCPTBVT_APPROVE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/ApprovePCPTBVT";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprovePCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprovePCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processApprovePCPTBVT(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    denyPCPTBVT(input: PCPTBVT_APPROVE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/DenyPCPTBVT";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDenyPCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDenyPCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDenyPCPTBVT(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @maPCPTBVT (optional) 
     * @return Success
     */
    getPCPTBVT(maPCPTBVT: string | null | undefined): Observable<PCPTBVT_DTO> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/GetPCPTBVT?";
        if (maPCPTBVT !== undefined)
            url_ += "maPCPTBVT=" + encodeURIComponent("" + maPCPTBVT) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<PCPTBVT_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PCPTBVT_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetPCPTBVT(response: HttpResponseBase): Observable<PCPTBVT_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PCPTBVT_DTO.fromJS(resultData200) : new PCPTBVT_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PCPTBVT_DTO>(<any>null);
    }

    /**
     * @maPCPTBVT (optional) 
     * @return Success
     */
    deletePCPTBVT(maPCPTBVT: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/DeletePCPTBVT?";
        if (maPCPTBVT !== undefined)
            url_ += "maPCPTBVT=" + encodeURIComponent("" + maPCPTBVT) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePCPTBVT(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    exportPCPTBVT(input: PCPTBVT_DTO | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/PhieuCapPhatTBVT/ExportPCPTBVT";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportPCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportPCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportPCPTBVT(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class PhieuThueXeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @phieuThue_Code (optional) 
     * @return Success
     */
    pTX_Delete(phieuThue_Code: string | null | undefined): Observable<PTX_DTO[]> {
        let url_ = this.baseUrl + "/api/PhieuThueXe/PTX_Delete?";
        if (phieuThue_Code !== undefined)
            url_ += "phieuThue_Code=" + encodeURIComponent("" + phieuThue_Code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPTX_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPTX_Delete(<any>response_);
                } catch (e) {
                    return <Observable<PTX_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PTX_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processPTX_Delete(response: HttpResponseBase): Observable<PTX_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PTX_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PTX_DTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    pTX_ExportExcel(): Observable<PagedResultDtoOfPTX_DTO> {
        let url_ = this.baseUrl + "/api/PhieuThueXe/PTX_ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPTX_ExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPTX_ExportExcel(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPTX_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPTX_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processPTX_ExportExcel(response: HttpResponseBase): Observable<PagedResultDtoOfPTX_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPTX_DTO.fromJS(resultData200) : new PagedResultDtoOfPTX_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPTX_DTO>(<any>null);
    }

    /**
     * @phieuThue (optional) 
     * @return Success
     */
    pTX_Insert(phieuThue: PTX_DTO | null | undefined): Observable<PTX_DTO[]> {
        let url_ = this.baseUrl + "/api/PhieuThueXe/PTX_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(phieuThue);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPTX_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPTX_Insert(<any>response_);
                } catch (e) {
                    return <Observable<PTX_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PTX_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processPTX_Insert(response: HttpResponseBase): Observable<PTX_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PTX_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PTX_DTO[]>(<any>null);
    }

    /**
     * @phieuThue (optional) 
     * @return Success
     */
    pTX_Update(phieuThue: PTX_DTO | null | undefined): Observable<PTX_DTO[]> {
        let url_ = this.baseUrl + "/api/PhieuThueXe/PTX_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(phieuThue);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPTX_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPTX_Update(<any>response_);
                } catch (e) {
                    return <Observable<PTX_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PTX_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processPTX_Update(response: HttpResponseBase): Observable<PTX_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PTX_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PTX_DTO[]>(<any>null);
    }

    /**
     * @phieuThue_Code (optional) 
     * @return Success
     */
    pTX_GetByCode(phieuThue_Code: string | null | undefined): Observable<PTX_DTO[]> {
        let url_ = this.baseUrl + "/api/PhieuThueXe/PTX_GetByCode?";
        if (phieuThue_Code !== undefined)
            url_ += "phieuThue_Code=" + encodeURIComponent("" + phieuThue_Code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPTX_GetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPTX_GetByCode(<any>response_);
                } catch (e) {
                    return <Observable<PTX_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PTX_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processPTX_GetByCode(response: HttpResponseBase): Observable<PTX_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PTX_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PTX_DTO[]>(<any>null);
    }
}

@Injectable()
export class PhongBanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @branch_id (optional) 
     * @return Success
     */
    dEPARTMENT_GET_BRANCH_ID_NAME_BYID(branch_id: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/PhongBan/DEPARTMENT_GET_BRANCH_ID_NAME_BYID?";
        if (branch_id !== undefined)
            url_ += "branch_id=" + encodeURIComponent("" + branch_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEPARTMENT_GET_BRANCH_ID_NAME_BYID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEPARTMENT_GET_BRANCH_ID_NAME_BYID(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDEPARTMENT_GET_BRANCH_ID_NAME_BYID(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @return Success
     */
    dEPARTMENT_GET_USER_BRANCH_BY_USERID(): Observable<AppUser> {
        let url_ = this.baseUrl + "/api/PhongBan/DEPARTMENT_GET_USER_BRANCH_BY_USERID";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEPARTMENT_GET_USER_BRANCH_BY_USERID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEPARTMENT_GET_USER_BRANCH_BY_USERID(<any>response_);
                } catch (e) {
                    return <Observable<AppUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppUser>><any>_observableThrow(response_);
        }));
    }

    protected processDEPARTMENT_GET_USER_BRANCH_BY_USERID(response: HttpResponseBase): Observable<AppUser> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppUser.fromJS(resultData200) : new AppUser();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppUser>(<any>null);
    }

    /**
     * @index (optional) 
     * @filterInput (optional) 
     * @return Success
     */
    dEPARTMENT_Search(index: string | null | undefined, filterInput: CM_PHONGBAN_DTO | null | undefined): Observable<CM_PHONGBAN_DTO[]> {
        let url_ = this.baseUrl + "/api/PhongBan/DEPARTMENT_Search?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEPARTMENT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEPARTMENT_Search(<any>response_);
                } catch (e) {
                    return <Observable<CM_PHONGBAN_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_PHONGBAN_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processDEPARTMENT_Search(response: HttpResponseBase): Observable<CM_PHONGBAN_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_PHONGBAN_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_PHONGBAN_DTO[]>(<any>null);
    }

    /**
     * @list_dep_id (optional) 
     * @return Success
     */
    dEPARTMENT_Delete(list_dep_id: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/PhongBan/DEPARTMENT_Delete?";
        if (list_dep_id !== undefined)
            url_ += "list_dep_id=" + encodeURIComponent("" + list_dep_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEPARTMENT_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEPARTMENT_Delete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDEPARTMENT_Delete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class PhuKienServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @tbvt_ma (optional) 
     * @return Success
     */
    getById(tbvt_ma: string | null | undefined): Observable<PhuKien_DTO> {
        let url_ = this.baseUrl + "/api/PhuKien/GetById?";
        if (tbvt_ma !== undefined)
            url_ += "tbvt_ma=" + encodeURIComponent("" + tbvt_ma) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PhuKien_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhuKien_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PhuKien_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PhuKien_DTO.fromJS(resultData200) : new PhuKien_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhuKien_DTO>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<PhuKien_DTO[]> {
        let url_ = this.baseUrl + "/api/PhuKien/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PhuKien_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhuKien_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PhuKien_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PhuKien_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhuKien_DTO[]>(<any>null);
    }

    /**
     * @filter_input (optional) 
     * @return Success
     */
    search(filter_input: PhuKien_DTO | null | undefined): Observable<PhuKien_DTO[]> {
        let url_ = this.baseUrl + "/api/PhuKien/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter_input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<PhuKien_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PhuKien_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PhuKien_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PhuKien_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhuKien_DTO[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    insert(input: PhuKien_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/PhuKien/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: PhuKien_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/PhuKien/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @tbvt_ma (optional) 
     * @return Success
     */
    delete(tbvt_ma: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/PhuKien/Delete?";
        if (tbvt_ma !== undefined)
            url_ += "tbvt_ma=" + encodeURIComponent("" + tbvt_ma) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @profilePictureId (optional) 
     * @userId (optional) 
     * @tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PTXServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    phieuThueXe_Delete(id: string): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/PTX/PhieuThueXe_Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPhieuThueXe_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPhieuThueXe_Delete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processPhieuThueXe_Delete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @ntxcode (optional) 
     * @ntxname (optional) 
     * @xecode (optional) 
     * @xename (optional) 
     * @license (optional) 
     * @return Success
     */
    phieuThueXe_Search(ntxcode: string | null | undefined, ntxname: string | null | undefined, xecode: string | null | undefined, xename: string | null | undefined, license: string | null | undefined): Observable<PagedResultDtoOfPhieuThueXe_DTO> {
        let url_ = this.baseUrl + "/api/PTX/PhieuThueXe_Search?";
        if (ntxcode !== undefined)
            url_ += "ntxcode=" + encodeURIComponent("" + ntxcode) + "&"; 
        if (ntxname !== undefined)
            url_ += "ntxname=" + encodeURIComponent("" + ntxname) + "&"; 
        if (xecode !== undefined)
            url_ += "xecode=" + encodeURIComponent("" + xecode) + "&"; 
        if (xename !== undefined)
            url_ += "xename=" + encodeURIComponent("" + xename) + "&"; 
        if (license !== undefined)
            url_ += "license=" + encodeURIComponent("" + license) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPhieuThueXe_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPhieuThueXe_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPhieuThueXe_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPhieuThueXe_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processPhieuThueXe_Search(response: HttpResponseBase): Observable<PagedResultDtoOfPhieuThueXe_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPhieuThueXe_DTO.fromJS(resultData200) : new PagedResultDtoOfPhieuThueXe_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPhieuThueXe_DTO>(<any>null);
    }
}

@Injectable()
export class ResidentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @body (optional) 
     * @return Success
     */
    approve(body: ResidentApproveRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Residents/Approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprove(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processApprove(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    create(body: ResidentCreateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Residents/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @bUILDING_ID (optional) 
     * @return Success
     */
    delete(bUILDING_ID: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Residents/Delete?";
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @bUILDING_ID (optional) 
     * @return Success
     */
    getByID(bUILDING_ID: string | null | undefined): Observable<ResidentTableDTO> {
        let url_ = this.baseUrl + "/api/Residents/GetByID?";
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByID(<any>response_);
                } catch (e) {
                    return <Observable<ResidentTableDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResidentTableDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetByID(response: HttpResponseBase): Observable<ResidentTableDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResidentTableDTO.fromJS(resultData200) : new ResidentTableDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResidentTableDTO>(<any>null);
    }

    /**
     * @bUILDING_ID (optional) 
     * @fLOOR_ID (optional) 
     * @aPARTMENT_ID (optional) 
     * @rESIDENT_CODE (optional) 
     * @rESIDENT_NAME (optional) 
     * @rESIDENT_IDCARD (optional) 
     * @rECORD_STATUS (optional) 
     * @aUTH_STATUS (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    pagingSearch(bUILDING_ID: string | null | undefined, fLOOR_ID: string | null | undefined, aPARTMENT_ID: string | null | undefined, rESIDENT_CODE: string | null | undefined, rESIDENT_NAME: string | null | undefined, rESIDENT_IDCARD: string | null | undefined, rECORD_STATUS: string | null | undefined, aUTH_STATUS: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfResidentPagingSearchDTO> {
        let url_ = this.baseUrl + "/api/Residents/PagingSearch?";
        if (bUILDING_ID !== undefined)
            url_ += "BUILDING_ID=" + encodeURIComponent("" + bUILDING_ID) + "&"; 
        if (fLOOR_ID !== undefined)
            url_ += "FLOOR_ID=" + encodeURIComponent("" + fLOOR_ID) + "&"; 
        if (aPARTMENT_ID !== undefined)
            url_ += "APARTMENT_ID=" + encodeURIComponent("" + aPARTMENT_ID) + "&"; 
        if (rESIDENT_CODE !== undefined)
            url_ += "RESIDENT_CODE=" + encodeURIComponent("" + rESIDENT_CODE) + "&"; 
        if (rESIDENT_NAME !== undefined)
            url_ += "RESIDENT_NAME=" + encodeURIComponent("" + rESIDENT_NAME) + "&"; 
        if (rESIDENT_IDCARD !== undefined)
            url_ += "RESIDENT_IDCARD=" + encodeURIComponent("" + rESIDENT_IDCARD) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPagingSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPagingSearch(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfResidentPagingSearchDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfResidentPagingSearchDTO>><any>_observableThrow(response_);
        }));
    }

    protected processPagingSearch(response: HttpResponseBase): Observable<PagedResultDtoOfResidentPagingSearchDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfResidentPagingSearchDTO.fromJS(resultData200) : new PagedResultDtoOfResidentPagingSearchDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfResidentPagingSearchDTO>(<any>null);
    }

    /**
     * @body (optional) 
     * @return Success
     */
    update(body: ResidentUpdateRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Residents/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ServicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @sEARCH (optional) 
     * @sERVICE_CODE (optional) 
     * @sERVICE_NAME (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    servicesSearch(sEARCH: string | null | undefined, sERVICE_CODE: string | null | undefined, sERVICE_NAME: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfServiceSearchDTO> {
        let url_ = this.baseUrl + "/api/Services/ServicesSearch?";
        if (sEARCH !== undefined)
            url_ += "SEARCH=" + encodeURIComponent("" + sEARCH) + "&"; 
        if (sERVICE_CODE !== undefined)
            url_ += "SERVICE_CODE=" + encodeURIComponent("" + sERVICE_CODE) + "&"; 
        if (sERVICE_NAME !== undefined)
            url_ += "SERVICE_NAME=" + encodeURIComponent("" + sERVICE_NAME) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServicesSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServicesSearch(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfServiceSearchDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfServiceSearchDTO>><any>_observableThrow(response_);
        }));
    }

    protected processServicesSearch(response: HttpResponseBase): Observable<PagedResultDtoOfServiceSearchDTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfServiceSearchDTO.fromJS(resultData200) : new PagedResultDtoOfServiceSearchDTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfServiceSearchDTO>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @upgradeEditionId (optional) 
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/UpgradeTenantToEquivalentEdition?";
        if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeTenantToEquivalentEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeTenantToEquivalentEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeTenantToEquivalentEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @subscriptionEndDateStart (optional) 
     * @subscriptionEndDateEnd (optional) 
     * @creationDateStart (optional) 
     * @creationDateEnd (optional) 
     * @editionId (optional) 
     * @editionIdSpecified (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: moment.Moment | null | undefined, subscriptionEndDateEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @salesSummaryDatePeriod (optional) 
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod | null | undefined): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod !== undefined)
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @salesSummaryDatePeriod (optional) 
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod2 | null | undefined): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod !== undefined)
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    getRegionalStats(input: any | null | undefined): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRegionalStatsOutput.fromJS(resultData200) : new GetRegionalStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    getGeneralStats(input: any | null | undefined): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput | null | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | null | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ThietBiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllThietBi(): Observable<THIET_BI_DTO[]> {
        let url_ = this.baseUrl + "/api/ThietBi/GetAllThietBi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThietBi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThietBi(<any>response_);
                } catch (e) {
                    return <Observable<THIET_BI_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<THIET_BI_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThietBi(response: HttpResponseBase): Observable<THIET_BI_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(THIET_BI_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<THIET_BI_DTO[]>(<any>null);
    }

    /**
     * @thietbiId (optional) 
     * @return Success
     */
    thietBiById(thietbiId: string | null | undefined): Observable<THIET_BI_DTO> {
        let url_ = this.baseUrl + "/api/ThietBi/ThietBiById?";
        if (thietbiId !== undefined)
            url_ += "thietbiId=" + encodeURIComponent("" + thietbiId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThietBiById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThietBiById(<any>response_);
                } catch (e) {
                    return <Observable<THIET_BI_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<THIET_BI_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processThietBiById(response: HttpResponseBase): Observable<THIET_BI_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? THIET_BI_DTO.fromJS(resultData200) : new THIET_BI_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<THIET_BI_DTO>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    thietBiUpdate(input: THIET_BI_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ThietBi/ThietBiUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThietBiUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThietBiUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processThietBiUpdate(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }
}

@Injectable()
export class ThietBiVatTuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllThietBiVatTu(): Observable<THIETBIVATTU_DTO[]> {
        let url_ = this.baseUrl + "/api/ThietBiVatTu/GetAllThietBiVatTu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllThietBiVatTu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllThietBiVatTu(<any>response_);
                } catch (e) {
                    return <Observable<THIETBIVATTU_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<THIETBIVATTU_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllThietBiVatTu(response: HttpResponseBase): Observable<THIETBIVATTU_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(THIETBIVATTU_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<THIETBIVATTU_DTO[]>(<any>null);
    }

    /**
     * @inputFilter (optional) 
     * @orderBy (optional) 
     * @desc (optional) 
     * @skip (optional) 
     * @take (optional) 
     * @return Success
     */
    searchThietBiVatTu(inputFilter: THIETBIVATTU_DTO | null | undefined, orderBy: string | null | undefined, desc: boolean | null | undefined, skip: number | null | undefined, take: number | null | undefined): Observable<PagedResultDtoOfTHIETBIVATTU_DTO> {
        let url_ = this.baseUrl + "/api/ThietBiVatTu/SearchThietBiVatTu?";
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (desc !== undefined)
            url_ += "desc=" + encodeURIComponent("" + desc) + "&"; 
        if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&"; 
        if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(inputFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchThietBiVatTu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchThietBiVatTu(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTHIETBIVATTU_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTHIETBIVATTU_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processSearchThietBiVatTu(response: HttpResponseBase): Observable<PagedResultDtoOfTHIETBIVATTU_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTHIETBIVATTU_DTO.fromJS(resultData200) : new PagedResultDtoOfTHIETBIVATTU_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTHIETBIVATTU_DTO>(<any>null);
    }

    /**
     * @maThietBiVatTu (optional) 
     * @return Success
     */
    deleteThietBiVatTu(maThietBiVatTu: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ThietBiVatTu/DeleteThietBiVatTu?";
        if (maThietBiVatTu !== undefined)
            url_ += "maThietBiVatTu=" + encodeURIComponent("" + maThietBiVatTu) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteThietBiVatTu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteThietBiVatTu(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteThietBiVatTu(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @maTBVT (optional) 
     * @maPCP (optional) 
     * @return Success
     */
    removeTBVTFromPCPTBVT(maTBVT: string | null | undefined, maPCP: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ThietBiVatTu/RemoveTBVTFromPCPTBVT?";
        if (maTBVT !== undefined)
            url_ += "maTBVT=" + encodeURIComponent("" + maTBVT) + "&"; 
        if (maPCP !== undefined)
            url_ += "maPCP=" + encodeURIComponent("" + maPCP) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTBVTFromPCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTBVTFromPCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveTBVTFromPCPTBVT(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @maTBVT (optional) 
     * @maPCP (optional) 
     * @return Success
     */
    addTBVTToPCPTBVT(maTBVT: string | null | undefined, maPCP: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/ThietBiVatTu/AddTBVTToPCPTBVT?";
        if (maTBVT !== undefined)
            url_ += "maTBVT=" + encodeURIComponent("" + maTBVT) + "&"; 
        if (maPCP !== undefined)
            url_ += "maPCP=" + encodeURIComponent("" + maPCP) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTBVTToPCPTBVT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTBVTToPCPTBVT(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddTBVTToPCPTBVT(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    exportThietBiVatTu(input: THIETBIVATTU_DTO | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/ThietBiVatTu/ExportThietBiVatTu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportThietBiVatTu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportThietBiVatTu(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportThietBiVatTu(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @defaultTimezoneScope (optional) 
     * @return Success
     */
    getTimezones(defaultTimezoneScope: DefaultTimezoneScope | null | undefined): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope !== undefined)
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @message (optional) 
     * @severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TrangThaiYeuCauSuaChuaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @tTYCSCId (optional) 
     * @return Success
     */
    tTYCSC_ById(tTYCSCId: string | null | undefined): Observable<TTYCSC_DTO> {
        let url_ = this.baseUrl + "/api/TrangThaiYeuCauSuaChua/TTYCSC_ById?";
        if (tTYCSCId !== undefined)
            url_ += "TTYCSCId=" + encodeURIComponent("" + tTYCSCId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTTYCSC_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTTYCSC_ById(<any>response_);
                } catch (e) {
                    return <Observable<TTYCSC_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<TTYCSC_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processTTYCSC_ById(response: HttpResponseBase): Observable<TTYCSC_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TTYCSC_DTO.fromJS(resultData200) : new TTYCSC_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TTYCSC_DTO>(<any>null);
    }

    /**
     * @tTYCSCId (optional) 
     * @return Success
     */
    tTYCSC_Delete(tTYCSCId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TrangThaiYeuCauSuaChua/TTYCSC_Delete?";
        if (tTYCSCId !== undefined)
            url_ += "TTYCSCId=" + encodeURIComponent("" + tTYCSCId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTTYCSC_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTTYCSC_Delete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTTYCSC_Delete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @pageNumber (optional) 
     * @pageSize (optional) 
     * @tTYCSCName (optional) 
     * @tTYCSCCode (optional) 
     * @tTYCSCDesc (optional) 
     * @aPPROVEStatus (optional) 
     * @return Success
     */
    tTYCSC_SearchFilter(pageNumber: number | null | undefined, pageSize: number | null | undefined, tTYCSCName: string | null | undefined, tTYCSCCode: string | null | undefined, tTYCSCDesc: string | null | undefined, aPPROVEStatus: string | null | undefined): Observable<PageResult> {
        let url_ = this.baseUrl + "/api/TrangThaiYeuCauSuaChua/TTYCSC_SearchFilter?";
        if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (tTYCSCName !== undefined)
            url_ += "TTYCSCName=" + encodeURIComponent("" + tTYCSCName) + "&"; 
        if (tTYCSCCode !== undefined)
            url_ += "TTYCSCCode=" + encodeURIComponent("" + tTYCSCCode) + "&"; 
        if (tTYCSCDesc !== undefined)
            url_ += "TTYCSCDesc=" + encodeURIComponent("" + tTYCSCDesc) + "&"; 
        if (aPPROVEStatus !== undefined)
            url_ += "APPROVEStatus=" + encodeURIComponent("" + aPPROVEStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTTYCSC_SearchFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTTYCSC_SearchFilter(<any>response_);
                } catch (e) {
                    return <Observable<PageResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageResult>><any>_observableThrow(response_);
        }));
    }

    protected processTTYCSC_SearchFilter(response: HttpResponseBase): Observable<PageResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageResult.fromJS(resultData200) : new PageResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageResult>(<any>null);
    }

    /**
     * @tTYCSC_ID (optional) 
     * @tTYCSC_CODE (optional) 
     * @tTYCSC_NAME (optional) 
     * @tTYCSC_DESC (optional) 
     * @nOTES (optional) 
     * @rECORD_STATUS (optional) 
     * @mAKER_ID (optional) 
     * @cREATE_DT (optional) 
     * @aUTH_STATUS (optional) 
     * @cHECKER_ID (optional) 
     * @aPPROVE_DT (optional) 
     * @tYPE_APPROVE (optional) 
     * @return Success
     */
    tTYCSC_Create(tTYCSC_ID: string | null | undefined, tTYCSC_CODE: string | null | undefined, tTYCSC_NAME: string | null | undefined, tTYCSC_DESC: string | null | undefined, nOTES: string | null | undefined, rECORD_STATUS: string | null | undefined, mAKER_ID: string | null | undefined, cREATE_DT: moment.Moment | null | undefined, aUTH_STATUS: string | null | undefined, cHECKER_ID: string | null | undefined, aPPROVE_DT: moment.Moment | null | undefined, tYPE_APPROVE: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TrangThaiYeuCauSuaChua/TTYCSC_Create?";
        if (tTYCSC_ID !== undefined)
            url_ += "TTYCSC_ID=" + encodeURIComponent("" + tTYCSC_ID) + "&"; 
        if (tTYCSC_CODE !== undefined)
            url_ += "TTYCSC_CODE=" + encodeURIComponent("" + tTYCSC_CODE) + "&"; 
        if (tTYCSC_NAME !== undefined)
            url_ += "TTYCSC_NAME=" + encodeURIComponent("" + tTYCSC_NAME) + "&"; 
        if (tTYCSC_DESC !== undefined)
            url_ += "TTYCSC_DESC=" + encodeURIComponent("" + tTYCSC_DESC) + "&"; 
        if (nOTES !== undefined)
            url_ += "NOTES=" + encodeURIComponent("" + nOTES) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (mAKER_ID !== undefined)
            url_ += "MAKER_ID=" + encodeURIComponent("" + mAKER_ID) + "&"; 
        if (cREATE_DT !== undefined)
            url_ += "CREATE_DT=" + encodeURIComponent(cREATE_DT ? "" + cREATE_DT.toJSON() : "") + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (cHECKER_ID !== undefined)
            url_ += "CHECKER_ID=" + encodeURIComponent("" + cHECKER_ID) + "&"; 
        if (aPPROVE_DT !== undefined)
            url_ += "APPROVE_DT=" + encodeURIComponent(aPPROVE_DT ? "" + aPPROVE_DT.toJSON() : "") + "&"; 
        if (tYPE_APPROVE !== undefined)
            url_ += "TYPE_APPROVE=" + encodeURIComponent("" + tYPE_APPROVE) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTTYCSC_Create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTTYCSC_Create(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTTYCSC_Create(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    tTYCSC_GetValueGenCode(): Observable<string> {
        let url_ = this.baseUrl + "/api/TrangThaiYeuCauSuaChua/TTYCSC_GetValueGenCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTTYCSC_GetValueGenCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTTYCSC_GetValueGenCode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTTYCSC_GetValueGenCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @tTYCSC_ID (optional) 
     * @tTYCSC_CODE (optional) 
     * @tTYCSC_NAME (optional) 
     * @tTYCSC_DESC (optional) 
     * @nOTES (optional) 
     * @rECORD_STATUS (optional) 
     * @mAKER_ID (optional) 
     * @cREATE_DT (optional) 
     * @aUTH_STATUS (optional) 
     * @cHECKER_ID (optional) 
     * @aPPROVE_DT (optional) 
     * @tYPE_APPROVE (optional) 
     * @return Success
     */
    tTYCSC_Update(tTYCSC_ID: string | null | undefined, tTYCSC_CODE: string | null | undefined, tTYCSC_NAME: string | null | undefined, tTYCSC_DESC: string | null | undefined, nOTES: string | null | undefined, rECORD_STATUS: string | null | undefined, mAKER_ID: string | null | undefined, cREATE_DT: moment.Moment | null | undefined, aUTH_STATUS: string | null | undefined, cHECKER_ID: string | null | undefined, aPPROVE_DT: moment.Moment | null | undefined, tYPE_APPROVE: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TrangThaiYeuCauSuaChua/TTYCSC_Update?";
        if (tTYCSC_ID !== undefined)
            url_ += "TTYCSC_ID=" + encodeURIComponent("" + tTYCSC_ID) + "&"; 
        if (tTYCSC_CODE !== undefined)
            url_ += "TTYCSC_CODE=" + encodeURIComponent("" + tTYCSC_CODE) + "&"; 
        if (tTYCSC_NAME !== undefined)
            url_ += "TTYCSC_NAME=" + encodeURIComponent("" + tTYCSC_NAME) + "&"; 
        if (tTYCSC_DESC !== undefined)
            url_ += "TTYCSC_DESC=" + encodeURIComponent("" + tTYCSC_DESC) + "&"; 
        if (nOTES !== undefined)
            url_ += "NOTES=" + encodeURIComponent("" + nOTES) + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (mAKER_ID !== undefined)
            url_ += "MAKER_ID=" + encodeURIComponent("" + mAKER_ID) + "&"; 
        if (cREATE_DT !== undefined)
            url_ += "CREATE_DT=" + encodeURIComponent(cREATE_DT ? "" + cREATE_DT.toJSON() : "") + "&"; 
        if (aUTH_STATUS !== undefined)
            url_ += "AUTH_STATUS=" + encodeURIComponent("" + aUTH_STATUS) + "&"; 
        if (cHECKER_ID !== undefined)
            url_ += "CHECKER_ID=" + encodeURIComponent("" + cHECKER_ID) + "&"; 
        if (aPPROVE_DT !== undefined)
            url_ += "APPROVE_DT=" + encodeURIComponent(aPPROVE_DT ? "" + aPPROVE_DT.toJSON() : "") + "&"; 
        if (tYPE_APPROVE !== undefined)
            url_ += "TYPE_APPROVE=" + encodeURIComponent("" + tYPE_APPROVE) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTTYCSC_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTTYCSC_Update(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTTYCSC_Update(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @tTYCSC_ID (optional) 
     * @tTYCSC_CODE (optional) 
     * @tTYCSC_NAME (optional) 
     * @tTYCSC_DESC (optional) 
     * @cHECKER_ID (optional) 
     * @tYPE_APPROVE (optional) 
     * @isAPPROVE (optional) 
     * @return Success
     */
    tTYCSC_Approve(tTYCSC_ID: string | null | undefined, tTYCSC_CODE: string | null | undefined, tTYCSC_NAME: string | null | undefined, tTYCSC_DESC: string | null | undefined, cHECKER_ID: string | null | undefined, tYPE_APPROVE: string | null | undefined, isAPPROVE: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TrangThaiYeuCauSuaChua/TTYCSC_Approve?";
        if (tTYCSC_ID !== undefined)
            url_ += "TTYCSC_ID=" + encodeURIComponent("" + tTYCSC_ID) + "&"; 
        if (tTYCSC_CODE !== undefined)
            url_ += "TTYCSC_CODE=" + encodeURIComponent("" + tTYCSC_CODE) + "&"; 
        if (tTYCSC_NAME !== undefined)
            url_ += "TTYCSC_NAME=" + encodeURIComponent("" + tTYCSC_NAME) + "&"; 
        if (tTYCSC_DESC !== undefined)
            url_ += "TTYCSC_DESC=" + encodeURIComponent("" + tTYCSC_DESC) + "&"; 
        if (cHECKER_ID !== undefined)
            url_ += "CHECKER_ID=" + encodeURIComponent("" + cHECKER_ID) + "&"; 
        if (tYPE_APPROVE !== undefined)
            url_ += "TYPE_APPROVE=" + encodeURIComponent("" + tYPE_APPROVE) + "&"; 
        if (isAPPROVE !== undefined)
            url_ += "isAPPROVE=" + encodeURIComponent("" + isAPPROVE) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTTYCSC_Approve(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTTYCSC_Approve(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTTYCSC_Approve(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @pageNumber (optional) 
     * @pageSize (optional) 
     * @tTYCSCName (optional) 
     * @tTYCSCCode (optional) 
     * @tTYCSCDesc (optional) 
     * @aPPROVEStatus (optional) 
     * @return Success
     */
    tTYCSC_ExportExcel(pageNumber: number | null | undefined, pageSize: number | null | undefined, tTYCSCName: string | null | undefined, tTYCSCCode: string | null | undefined, tTYCSCDesc: string | null | undefined, aPPROVEStatus: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TrangThaiYeuCauSuaChua/TTYCSC_ExportExcel?";
        if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&"; 
        if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (tTYCSCName !== undefined)
            url_ += "TTYCSCName=" + encodeURIComponent("" + tTYCSCName) + "&"; 
        if (tTYCSCCode !== undefined)
            url_ += "TTYCSCCode=" + encodeURIComponent("" + tTYCSCCode) + "&"; 
        if (tTYCSCDesc !== undefined)
            url_ += "TTYCSCDesc=" + encodeURIComponent("" + tTYCSCDesc) + "&"; 
        if (aPPROVEStatus !== undefined)
            url_ += "APPROVEStatus=" + encodeURIComponent("" + aPPROVEStatus) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTTYCSC_ExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTTYCSC_ExportExcel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTTYCSC_ExportExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<UiCustomizationSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<UiCustomizationSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UiCustomizationSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<UiCustomizationSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UiCustomizationSettingsEditDto.fromJS(resultData200) : new UiCustomizationSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UiCustomizationSettingsEditDto>(<any>null);
    }

    /**
     * @settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class Use_DichVuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @return Success
     */
    use_DichVuInsert(filter: Use_DichVuInsertRequest | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Use_DichVu/Use_DichVuInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUse_DichVuInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUse_DichVuInsert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processUse_DichVuInsert(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @cANHO_ID (optional) 
     * @dICHVU_ID (optional) 
     * @nG_START (optional) 
     * @nG_END (optional) 
     * @rECORD_STATUS (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    use_DichVuSearch(cANHO_ID: string | null | undefined, dICHVU_ID: string | null | undefined, nG_START: moment.Moment | null | undefined, nG_END: moment.Moment | null | undefined, rECORD_STATUS: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUse_DichVuSearchDTOs> {
        let url_ = this.baseUrl + "/api/Use_DichVu/Use_DichVuSearch?";
        if (cANHO_ID !== undefined)
            url_ += "CANHO_ID=" + encodeURIComponent("" + cANHO_ID) + "&"; 
        if (dICHVU_ID !== undefined)
            url_ += "DICHVU_ID=" + encodeURIComponent("" + dICHVU_ID) + "&"; 
        if (nG_START !== undefined)
            url_ += "NG_START=" + encodeURIComponent(nG_START ? "" + nG_START.toJSON() : "") + "&"; 
        if (nG_END !== undefined)
            url_ += "NG_END=" + encodeURIComponent(nG_END ? "" + nG_END.toJSON() : "") + "&"; 
        if (rECORD_STATUS !== undefined)
            url_ += "RECORD_STATUS=" + encodeURIComponent("" + rECORD_STATUS) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUse_DichVuSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUse_DichVuSearch(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUse_DichVuSearchDTOs>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUse_DichVuSearchDTOs>><any>_observableThrow(response_);
        }));
    }

    protected processUse_DichVuSearch(response: HttpResponseBase): Observable<PagedResultDtoOfUse_DichVuSearchDTOs> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUse_DichVuSearchDTOs.fromJS(resultData200) : new PagedResultDtoOfUse_DichVuSearchDTOs();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUse_DichVuSearchDTOs>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @permission (optional) 
     * @role (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permission: string | null | undefined, role: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUsersToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class XeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    cM_XE_Search(filterInput: CM_XE_DTO | null | undefined): Observable<CM_XE_DTO[]> {
        let url_ = this.baseUrl + "/api/Xe/CM_XE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_XE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_XE_Search(<any>response_);
                } catch (e) {
                    return <Observable<CM_XE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_XE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_XE_Search(response: HttpResponseBase): Observable<CM_XE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CM_XE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_XE_DTO[]>(<any>null);
    }

    /**
     * @xeId (optional) 
     * @return Success
     */
    cM_XE_ById(xeId: string | null | undefined): Observable<CM_XE_DTO> {
        let url_ = this.baseUrl + "/api/Xe/CM_XE_ById?";
        if (xeId !== undefined)
            url_ += "xeId=" + encodeURIComponent("" + xeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_XE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_XE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_XE_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_XE_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processCM_XE_ById(response: HttpResponseBase): Observable<CM_XE_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_XE_DTO.fromJS(resultData200) : new CM_XE_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_XE_DTO>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    cM_XE_Insert(input: CM_XE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Xe/CM_XE_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_XE_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_XE_Insert(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_XE_Insert(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    cM_XE_Update(input: CM_XE_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Xe/CM_XE_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_XE_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_XE_Update(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_XE_Update(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @xeId (optional) 
     * @return Success
     */
    cM_XE_Delete(xeId: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Xe/CM_XE_Delete?";
        if (xeId !== undefined)
            url_ += "xeId=" + encodeURIComponent("" + xeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_XE_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_XE_Delete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_XE_Delete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @xeId (optional) 
     * @checkerId (optional) 
     * @return Success
     */
    cM_XE_Approve(xeId: string | null | undefined, checkerId: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/Xe/CM_XE_Approve?";
        if (xeId !== undefined)
            url_ += "xeId=" + encodeURIComponent("" + xeId) + "&"; 
        if (checkerId !== undefined)
            url_ += "checkerId=" + encodeURIComponent("" + checkerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_XE_Approve(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_XE_Approve(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_XE_Approve(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @filterInput (optional) 
     * @return Success
     */
    xE_Search(filterInput: XE_DTO | null | undefined): Observable<PagedResultDtoOfXE_DTO> {
        let url_ = this.baseUrl + "/api/Xe/XE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfXE_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfXE_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processXE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfXE_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfXE_DTO.fromJS(resultData200) : new PagedResultDtoOfXE_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfXE_DTO>(<any>null);
    }

    /**
     * @listInput (optional) 
     * @return Success
     */
    xE_ExportExcel(listInput: XE_DTO[] | null | undefined): Observable<XE_DTO[]> {
        let url_ = this.baseUrl + "/api/Xe/XE_ExportExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXE_ExportExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXE_ExportExcel(<any>response_);
                } catch (e) {
                    return <Observable<XE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processXE_ExportExcel(response: HttpResponseBase): Observable<XE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(XE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XE_DTO[]>(<any>null);
    }

    /**
     * @xeCode (optional) 
     * @return Success
     */
    xE_ByCode(xeCode: string | null | undefined): Observable<XE_DTO[]> {
        let url_ = this.baseUrl + "/api/Xe/XE_ByCode?";
        if (xeCode !== undefined)
            url_ += "xeCode=" + encodeURIComponent("" + xeCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXE_ByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXE_ByCode(<any>response_);
                } catch (e) {
                    return <Observable<XE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processXE_ByCode(response: HttpResponseBase): Observable<XE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(XE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XE_DTO[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    xE_Insert(input: XE_DTO | null | undefined): Observable<XE_DTO[]> {
        let url_ = this.baseUrl + "/api/Xe/XE_Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXE_Insert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXE_Insert(<any>response_);
                } catch (e) {
                    return <Observable<XE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processXE_Insert(response: HttpResponseBase): Observable<XE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(XE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XE_DTO[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    xE_Update(input: XE_DTO | null | undefined): Observable<XE_DTO[]> {
        let url_ = this.baseUrl + "/api/Xe/XE_Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXE_Update(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXE_Update(<any>response_);
                } catch (e) {
                    return <Observable<XE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processXE_Update(response: HttpResponseBase): Observable<XE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(XE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XE_DTO[]>(<any>null);
    }

    /**
     * @xeId (optional) 
     * @return Success
     */
    xE_Delete(xeId: string | null | undefined): Observable<XE_DTO[]> {
        let url_ = this.baseUrl + "/api/Xe/XE_Delete?";
        if (xeId !== undefined)
            url_ += "xeId=" + encodeURIComponent("" + xeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXE_Delete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXE_Delete(<any>response_);
                } catch (e) {
                    return <Observable<XE_DTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<XE_DTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processXE_Delete(response: HttpResponseBase): Observable<XE_DTO[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(XE_DTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XE_DTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    xE_ByNtxID(id: string): Observable<PagedResultDtoOfXE_DTO> {
        let url_ = this.baseUrl + "/api/Xe/XE_ByNtxID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXE_ByNtxID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXE_ByNtxID(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfXE_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfXE_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processXE_ByNtxID(response: HttpResponseBase): Observable<PagedResultDtoOfXE_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfXE_DTO.fromJS(resultData200) : new PagedResultDtoOfXE_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfXE_DTO>(<any>null);
    }

    /**
     * @return Success
     */
    xE_ByID(id: string): Observable<XE_DTO> {
        let url_ = this.baseUrl + "/api/Xe/XE_ByID/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXE_ByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXE_ByID(<any>response_);
                } catch (e) {
                    return <Observable<XE_DTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<XE_DTO>><any>_observableThrow(response_);
        }));
    }

    protected processXE_ByID(response: HttpResponseBase): Observable<XE_DTO> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? XE_DTO.fromJS(resultData200) : new XE_DTO();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XE_DTO>(<any>null);
    }
}

@Injectable()
export class YeuCauSuaChuaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @yCSC_TBVT_ID (optional) 
     * @return Success
     */
    yCSCByTBVTId(yCSC_TBVT_ID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/YeuCauSuaChua/YCSCByTBVTId?";
        if (yCSC_TBVT_ID !== undefined)
            url_ += "YCSC_TBVT_ID=" + encodeURIComponent("" + yCSC_TBVT_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYCSCByTBVTId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYCSCByTBVTId(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processYCSCByTBVTId(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @yCSC_MA_YCSC (optional) 
     * @return Success
     */
    yCSCById(yCSC_MA_YCSC: string | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/YeuCauSuaChua/YCSCById?";
        if (yCSC_MA_YCSC !== undefined)
            url_ += "YCSC_MA_YCSC=" + encodeURIComponent("" + yCSC_MA_YCSC) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYCSCById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYCSCById(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processYCSCById(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    yCSCInsert(input: YEU_CAU_SUA_CHUA_DTO | null | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/YeuCauSuaChua/YCSCInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYCSCInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYCSCInsert(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processYCSCInsert(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    yCSCUpdate(input: YEU_CAU_SUA_CHUA_DTO | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/YeuCauSuaChua/YCSCUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYCSCUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYCSCUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processYCSCUpdate(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @return Success
     */
    yCSCDelete(): Observable<any[]> {
        let url_ = this.baseUrl + "/api/YeuCauSuaChua/YCSCDelete";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYCSCDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYCSCDelete(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processYCSCDelete(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @yCSC_ID (optional) 
     * @return Success
     */
    yCSCDeleteSingle(yCSC_ID: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/YeuCauSuaChua/YCSCDeleteSingle?";
        if (yCSC_ID !== undefined)
            url_ += "YCSC_ID=" + encodeURIComponent("" + yCSC_ID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYCSCDeleteSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYCSCDeleteSingle(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processYCSCDeleteSingle(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @return Success
     */
    yCSCGetAll(): Observable<any[]> {
        let url_ = this.baseUrl + "/api/YeuCauSuaChua/YCSCGetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYCSCGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYCSCGetAll(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processYCSCGetAll(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }

    /**
     * @toSearch (optional) 
     * @searchType (optional) 
     * @return Success
     */
    yCSCSearchWithOption(toSearch: string | null | undefined, searchType: string | null | undefined): Observable<any[]> {
        let url_ = this.baseUrl + "/api/YeuCauSuaChua/YCSCSearchWithOption?";
        if (toSearch !== undefined)
            url_ += "toSearch=" + encodeURIComponent("" + toSearch) + "&"; 
        if (searchType !== undefined)
            url_ += "searchType=" + encodeURIComponent("" + searchType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processYCSCSearchWithOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processYCSCSearchWithOption(<any>response_);
                } catch (e) {
                    return <Observable<any[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<any[]>><any>_observableThrow(response_);
        }));
    }

    protected processYCSCSearchWithOption(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: IsTenantAvailableOutputState | undefined;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number | undefined;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean | undefined;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number | undefined;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class ApSearchDTO implements IApSearchDTO {
    apartmenT_ID!: string | undefined;
    apartmenT_CODE!: string | undefined;
    apartmenT_NAME!: string | undefined;
    apartmenT_TYPE_NAME!: string | undefined;
    buildinG_NAME!: string | undefined;
    floor_NAME!: string | undefined;
    residenT_QUANTITY!: number | undefined;
    apartmenT_MAX_TENANT!: number | undefined;
    apartmenT_PRICE!: number | undefined;
    apartmenT_STATUS!: string | undefined;
    autH_STATUS_NAME!: string | undefined;

    constructor(data?: IApSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apartmenT_ID = data["apartmenT_ID"];
            this.apartmenT_CODE = data["apartmenT_CODE"];
            this.apartmenT_NAME = data["apartmenT_NAME"];
            this.apartmenT_TYPE_NAME = data["apartmenT_TYPE_NAME"];
            this.buildinG_NAME = data["buildinG_NAME"];
            this.floor_NAME = data["floor_NAME"];
            this.residenT_QUANTITY = data["residenT_QUANTITY"];
            this.apartmenT_MAX_TENANT = data["apartmenT_MAX_TENANT"];
            this.apartmenT_PRICE = data["apartmenT_PRICE"];
            this.apartmenT_STATUS = data["apartmenT_STATUS"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
        }
    }

    static fromJS(data: any): ApSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apartmenT_ID"] = this.apartmenT_ID;
        data["apartmenT_CODE"] = this.apartmenT_CODE;
        data["apartmenT_NAME"] = this.apartmenT_NAME;
        data["apartmenT_TYPE_NAME"] = this.apartmenT_TYPE_NAME;
        data["buildinG_NAME"] = this.buildinG_NAME;
        data["floor_NAME"] = this.floor_NAME;
        data["residenT_QUANTITY"] = this.residenT_QUANTITY;
        data["apartmenT_MAX_TENANT"] = this.apartmenT_MAX_TENANT;
        data["apartmenT_PRICE"] = this.apartmenT_PRICE;
        data["apartmenT_STATUS"] = this.apartmenT_STATUS;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        return data; 
    }
}

export interface IApSearchDTO {
    apartmenT_ID: string | undefined;
    apartmenT_CODE: string | undefined;
    apartmenT_NAME: string | undefined;
    apartmenT_TYPE_NAME: string | undefined;
    buildinG_NAME: string | undefined;
    floor_NAME: string | undefined;
    residenT_QUANTITY: number | undefined;
    apartmenT_MAX_TENANT: number | undefined;
    apartmenT_PRICE: number | undefined;
    apartmenT_STATUS: string | undefined;
    autH_STATUS_NAME: string | undefined;
}

export class ApartmentDTO implements IApartmentDTO {
    apartmenT_ID!: string | undefined;
    apartmenT_CODE!: string | undefined;
    apartmenT_NAME!: string | undefined;
    apartmenT_TYPE_ID!: string | undefined;
    buildinG_ID!: string | undefined;
    floor_ID!: string | undefined;
    apartmenT_STATUS!: string | undefined;
    apartmenT_PRICE!: number | undefined;
    apartmenT_ROOMS!: number | undefined;
    apartmenT_AREA!: number | undefined;
    apartmenT_MAX_TENANT!: number | undefined;
    apartmenT_DESCRIPTION!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    approvE_PERMISSION!: string | undefined;
    apartmenT_OLD_ID!: string | undefined;

    constructor(data?: IApartmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apartmenT_ID = data["apartmenT_ID"];
            this.apartmenT_CODE = data["apartmenT_CODE"];
            this.apartmenT_NAME = data["apartmenT_NAME"];
            this.apartmenT_TYPE_ID = data["apartmenT_TYPE_ID"];
            this.buildinG_ID = data["buildinG_ID"];
            this.floor_ID = data["floor_ID"];
            this.apartmenT_STATUS = data["apartmenT_STATUS"];
            this.apartmenT_PRICE = data["apartmenT_PRICE"];
            this.apartmenT_ROOMS = data["apartmenT_ROOMS"];
            this.apartmenT_AREA = data["apartmenT_AREA"];
            this.apartmenT_MAX_TENANT = data["apartmenT_MAX_TENANT"];
            this.apartmenT_DESCRIPTION = data["apartmenT_DESCRIPTION"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.approvE_PERMISSION = data["approvE_PERMISSION"];
            this.apartmenT_OLD_ID = data["apartmenT_OLD_ID"];
        }
    }

    static fromJS(data: any): ApartmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApartmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apartmenT_ID"] = this.apartmenT_ID;
        data["apartmenT_CODE"] = this.apartmenT_CODE;
        data["apartmenT_NAME"] = this.apartmenT_NAME;
        data["apartmenT_TYPE_ID"] = this.apartmenT_TYPE_ID;
        data["buildinG_ID"] = this.buildinG_ID;
        data["floor_ID"] = this.floor_ID;
        data["apartmenT_STATUS"] = this.apartmenT_STATUS;
        data["apartmenT_PRICE"] = this.apartmenT_PRICE;
        data["apartmenT_ROOMS"] = this.apartmenT_ROOMS;
        data["apartmenT_AREA"] = this.apartmenT_AREA;
        data["apartmenT_MAX_TENANT"] = this.apartmenT_MAX_TENANT;
        data["apartmenT_DESCRIPTION"] = this.apartmenT_DESCRIPTION;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["approvE_PERMISSION"] = this.approvE_PERMISSION;
        data["apartmenT_OLD_ID"] = this.apartmenT_OLD_ID;
        return data; 
    }
}

export interface IApartmentDTO {
    apartmenT_ID: string | undefined;
    apartmenT_CODE: string | undefined;
    apartmenT_NAME: string | undefined;
    apartmenT_TYPE_ID: string | undefined;
    buildinG_ID: string | undefined;
    floor_ID: string | undefined;
    apartmenT_STATUS: string | undefined;
    apartmenT_PRICE: number | undefined;
    apartmenT_ROOMS: number | undefined;
    apartmenT_AREA: number | undefined;
    apartmenT_MAX_TENANT: number | undefined;
    apartmenT_DESCRIPTION: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    approvE_PERMISSION: string | undefined;
    apartmenT_OLD_ID: string | undefined;
}

export class CustomApartmentDTO implements ICustomApartmentDTO {
    apartmenT_ID!: string | undefined;
    apartmenT_CODE!: string | undefined;
    apartmenT_NAME!: string | undefined;
    apartmenT_TYPE_NAME!: string | undefined;
    buildinG_NAME!: string | undefined;
    floor_NAME!: string | undefined;
    apartmenT_STATUS!: string | undefined;
    apartmenT_PRICE!: number | undefined;
    numbeR_OF_PEOPLE!: string | undefined;
    apartmenT_ROOMS!: number | undefined;
    apartmenT_AREA!: number | undefined;
    apartmenT_MAX_TENANT!: number | undefined;
    apartmenT_DESCRIPTION!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: ICustomApartmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apartmenT_ID = data["apartmenT_ID"];
            this.apartmenT_CODE = data["apartmenT_CODE"];
            this.apartmenT_NAME = data["apartmenT_NAME"];
            this.apartmenT_TYPE_NAME = data["apartmenT_TYPE_NAME"];
            this.buildinG_NAME = data["buildinG_NAME"];
            this.floor_NAME = data["floor_NAME"];
            this.apartmenT_STATUS = data["apartmenT_STATUS"];
            this.apartmenT_PRICE = data["apartmenT_PRICE"];
            this.numbeR_OF_PEOPLE = data["numbeR_OF_PEOPLE"];
            this.apartmenT_ROOMS = data["apartmenT_ROOMS"];
            this.apartmenT_AREA = data["apartmenT_AREA"];
            this.apartmenT_MAX_TENANT = data["apartmenT_MAX_TENANT"];
            this.apartmenT_DESCRIPTION = data["apartmenT_DESCRIPTION"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomApartmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CustomApartmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apartmenT_ID"] = this.apartmenT_ID;
        data["apartmenT_CODE"] = this.apartmenT_CODE;
        data["apartmenT_NAME"] = this.apartmenT_NAME;
        data["apartmenT_TYPE_NAME"] = this.apartmenT_TYPE_NAME;
        data["buildinG_NAME"] = this.buildinG_NAME;
        data["floor_NAME"] = this.floor_NAME;
        data["apartmenT_STATUS"] = this.apartmenT_STATUS;
        data["apartmenT_PRICE"] = this.apartmenT_PRICE;
        data["numbeR_OF_PEOPLE"] = this.numbeR_OF_PEOPLE;
        data["apartmenT_ROOMS"] = this.apartmenT_ROOMS;
        data["apartmenT_AREA"] = this.apartmenT_AREA;
        data["apartmenT_MAX_TENANT"] = this.apartmenT_MAX_TENANT;
        data["apartmenT_DESCRIPTION"] = this.apartmenT_DESCRIPTION;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICustomApartmentDTO {
    apartmenT_ID: string | undefined;
    apartmenT_CODE: string | undefined;
    apartmenT_NAME: string | undefined;
    apartmenT_TYPE_NAME: string | undefined;
    buildinG_NAME: string | undefined;
    floor_NAME: string | undefined;
    apartmenT_STATUS: string | undefined;
    apartmenT_PRICE: number | undefined;
    numbeR_OF_PEOPLE: string | undefined;
    apartmenT_ROOMS: number | undefined;
    apartmenT_AREA: number | undefined;
    apartmenT_MAX_TENANT: number | undefined;
    apartmenT_DESCRIPTION: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class Apartment_DTO implements IApartment_DTO {
    apartmenT_ID!: string | undefined;
    apartmenT_CODE!: string | undefined;
    apartmenT_NAME!: string | undefined;
    apartmenT_TYPE_ID!: string | undefined;
    buildinG_ID!: string | undefined;
    floor_ID!: string | undefined;
    apartmenT_STATUS!: string | undefined;
    apartmenT_PRICE!: number | undefined;
    apartmenT_ROOMS!: number | undefined;
    apartmenT_AREA!: number | undefined;
    apartmenT_OWNER!: string | undefined;
    apartmenT_DESCRIPTION!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IApartment_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apartmenT_ID = data["apartmenT_ID"];
            this.apartmenT_CODE = data["apartmenT_CODE"];
            this.apartmenT_NAME = data["apartmenT_NAME"];
            this.apartmenT_TYPE_ID = data["apartmenT_TYPE_ID"];
            this.buildinG_ID = data["buildinG_ID"];
            this.floor_ID = data["floor_ID"];
            this.apartmenT_STATUS = data["apartmenT_STATUS"];
            this.apartmenT_PRICE = data["apartmenT_PRICE"];
            this.apartmenT_ROOMS = data["apartmenT_ROOMS"];
            this.apartmenT_AREA = data["apartmenT_AREA"];
            this.apartmenT_OWNER = data["apartmenT_OWNER"];
            this.apartmenT_DESCRIPTION = data["apartmenT_DESCRIPTION"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Apartment_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new Apartment_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apartmenT_ID"] = this.apartmenT_ID;
        data["apartmenT_CODE"] = this.apartmenT_CODE;
        data["apartmenT_NAME"] = this.apartmenT_NAME;
        data["apartmenT_TYPE_ID"] = this.apartmenT_TYPE_ID;
        data["buildinG_ID"] = this.buildinG_ID;
        data["floor_ID"] = this.floor_ID;
        data["apartmenT_STATUS"] = this.apartmenT_STATUS;
        data["apartmenT_PRICE"] = this.apartmenT_PRICE;
        data["apartmenT_ROOMS"] = this.apartmenT_ROOMS;
        data["apartmenT_AREA"] = this.apartmenT_AREA;
        data["apartmenT_OWNER"] = this.apartmenT_OWNER;
        data["apartmenT_DESCRIPTION"] = this.apartmenT_DESCRIPTION;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IApartment_DTO {
    apartmenT_ID: string | undefined;
    apartmenT_CODE: string | undefined;
    apartmenT_NAME: string | undefined;
    apartmenT_TYPE_ID: string | undefined;
    buildinG_ID: string | undefined;
    floor_ID: string | undefined;
    apartmenT_STATUS: string | undefined;
    apartmenT_PRICE: number | undefined;
    apartmenT_ROOMS: number | undefined;
    apartmenT_AREA: number | undefined;
    apartmenT_OWNER: string | undefined;
    apartmenT_DESCRIPTION: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ResidentDTO implements IResidentDTO {
    residenT_ID!: string | undefined;
    residenT_CODE!: string | undefined;
    residenT_NAME!: string | undefined;
    residenT_BIRTH!: moment.Moment | undefined;
    residenT_IDCARD!: string | undefined;
    cuR_APARTMENT!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IResidentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.residenT_ID = data["residenT_ID"];
            this.residenT_CODE = data["residenT_CODE"];
            this.residenT_NAME = data["residenT_NAME"];
            this.residenT_BIRTH = data["residenT_BIRTH"] ? moment(data["residenT_BIRTH"].toString()) : <any>undefined;
            this.residenT_IDCARD = data["residenT_IDCARD"];
            this.cuR_APARTMENT = data["cuR_APARTMENT"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResidentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResidentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["residenT_ID"] = this.residenT_ID;
        data["residenT_CODE"] = this.residenT_CODE;
        data["residenT_NAME"] = this.residenT_NAME;
        data["residenT_BIRTH"] = this.residenT_BIRTH ? this.residenT_BIRTH.toISOString() : <any>undefined;
        data["residenT_IDCARD"] = this.residenT_IDCARD;
        data["cuR_APARTMENT"] = this.cuR_APARTMENT;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IResidentDTO {
    residenT_ID: string | undefined;
    residenT_CODE: string | undefined;
    residenT_NAME: string | undefined;
    residenT_BIRTH: moment.Moment | undefined;
    residenT_IDCARD: string | undefined;
    cuR_APARTMENT: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ApartmentApproveRequest implements IApartmentApproveRequest {
    apartmenT_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;

    constructor(data?: IApartmentApproveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apartmenT_ID = data["apartmenT_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
        }
    }

    static fromJS(data: any): ApartmentApproveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApartmentApproveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apartmenT_ID"] = this.apartmenT_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        return data; 
    }
}

export interface IApartmentApproveRequest {
    apartmenT_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
}

export class ApartmentCreateRequest implements IApartmentCreateRequest {
    apartmenT_CODE!: string | undefined;
    apartmenT_NAME!: string | undefined;
    apartmenttypE_ID!: string | undefined;
    flooR_ID!: string | undefined;
    apartmenT_STATUS!: string | undefined;
    description!: string | undefined;
    apartmenT_PRICE!: number | undefined;
    apartmenT_ROOMS!: number | undefined;
    apartmenT_AREA!: number | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IApartmentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apartmenT_CODE = data["apartmenT_CODE"];
            this.apartmenT_NAME = data["apartmenT_NAME"];
            this.apartmenttypE_ID = data["apartmenttypE_ID"];
            this.flooR_ID = data["flooR_ID"];
            this.apartmenT_STATUS = data["apartmenT_STATUS"];
            this.description = data["description"];
            this.apartmenT_PRICE = data["apartmenT_PRICE"];
            this.apartmenT_ROOMS = data["apartmenT_ROOMS"];
            this.apartmenT_AREA = data["apartmenT_AREA"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApartmentCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApartmentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apartmenT_CODE"] = this.apartmenT_CODE;
        data["apartmenT_NAME"] = this.apartmenT_NAME;
        data["apartmenttypE_ID"] = this.apartmenttypE_ID;
        data["flooR_ID"] = this.flooR_ID;
        data["apartmenT_STATUS"] = this.apartmenT_STATUS;
        data["description"] = this.description;
        data["apartmenT_PRICE"] = this.apartmenT_PRICE;
        data["apartmenT_ROOMS"] = this.apartmenT_ROOMS;
        data["apartmenT_AREA"] = this.apartmenT_AREA;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IApartmentCreateRequest {
    apartmenT_CODE: string | undefined;
    apartmenT_NAME: string | undefined;
    apartmenttypE_ID: string | undefined;
    flooR_ID: string | undefined;
    apartmenT_STATUS: string | undefined;
    description: string | undefined;
    apartmenT_PRICE: number | undefined;
    apartmenT_ROOMS: number | undefined;
    apartmenT_AREA: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ApartmentTableDTO implements IApartmentTableDTO {
    apartmenT_ID!: string | undefined;
    apartmenT_CODE!: string | undefined;
    apartmenT_NAME!: string | undefined;
    apartmenttypE_ID!: string | undefined;
    flooR_ID!: string | undefined;
    apartmenT_STATUS!: string | undefined;
    description!: string | undefined;
    apartmenT_PRICE!: number | undefined;
    apartmenT_ROOMS!: number | undefined;
    apartmenT_AREA!: number | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IApartmentTableDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apartmenT_ID = data["apartmenT_ID"];
            this.apartmenT_CODE = data["apartmenT_CODE"];
            this.apartmenT_NAME = data["apartmenT_NAME"];
            this.apartmenttypE_ID = data["apartmenttypE_ID"];
            this.flooR_ID = data["flooR_ID"];
            this.apartmenT_STATUS = data["apartmenT_STATUS"];
            this.description = data["description"];
            this.apartmenT_PRICE = data["apartmenT_PRICE"];
            this.apartmenT_ROOMS = data["apartmenT_ROOMS"];
            this.apartmenT_AREA = data["apartmenT_AREA"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApartmentTableDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApartmentTableDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apartmenT_ID"] = this.apartmenT_ID;
        data["apartmenT_CODE"] = this.apartmenT_CODE;
        data["apartmenT_NAME"] = this.apartmenT_NAME;
        data["apartmenttypE_ID"] = this.apartmenttypE_ID;
        data["flooR_ID"] = this.flooR_ID;
        data["apartmenT_STATUS"] = this.apartmenT_STATUS;
        data["description"] = this.description;
        data["apartmenT_PRICE"] = this.apartmenT_PRICE;
        data["apartmenT_ROOMS"] = this.apartmenT_ROOMS;
        data["apartmenT_AREA"] = this.apartmenT_AREA;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IApartmentTableDTO {
    apartmenT_ID: string | undefined;
    apartmenT_CODE: string | undefined;
    apartmenT_NAME: string | undefined;
    apartmenttypE_ID: string | undefined;
    flooR_ID: string | undefined;
    apartmenT_STATUS: string | undefined;
    description: string | undefined;
    apartmenT_PRICE: number | undefined;
    apartmenT_ROOMS: number | undefined;
    apartmenT_AREA: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfApartmentPagingSearchDTO implements IPagedResultDtoOfApartmentPagingSearchDTO {
    totalCount!: number | undefined;
    items!: ApartmentPagingSearchDTO[] | undefined;

    constructor(data?: IPagedResultDtoOfApartmentPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApartmentPagingSearchDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApartmentPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApartmentPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApartmentPagingSearchDTO {
    totalCount: number | undefined;
    items: ApartmentPagingSearchDTO[] | undefined;
}

export class ApartmentPagingSearchDTO implements IApartmentPagingSearchDTO {
    totalRows!: number | undefined;
    apartmenttypE_NAME!: string | undefined;
    apartmenT_ID!: string | undefined;
    apartmenT_CODE!: string | undefined;
    apartmenT_NAME!: string | undefined;
    apartmenttypE_ID!: string | undefined;
    flooR_ID!: string | undefined;
    apartmenT_STATUS!: string | undefined;
    description!: string | undefined;
    apartmenT_PRICE!: number | undefined;
    apartmenT_ROOMS!: number | undefined;
    apartmenT_AREA!: number | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IApartmentPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalRows = data["totalRows"];
            this.apartmenttypE_NAME = data["apartmenttypE_NAME"];
            this.apartmenT_ID = data["apartmenT_ID"];
            this.apartmenT_CODE = data["apartmenT_CODE"];
            this.apartmenT_NAME = data["apartmenT_NAME"];
            this.apartmenttypE_ID = data["apartmenttypE_ID"];
            this.flooR_ID = data["flooR_ID"];
            this.apartmenT_STATUS = data["apartmenT_STATUS"];
            this.description = data["description"];
            this.apartmenT_PRICE = data["apartmenT_PRICE"];
            this.apartmenT_ROOMS = data["apartmenT_ROOMS"];
            this.apartmenT_AREA = data["apartmenT_AREA"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApartmentPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApartmentPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRows"] = this.totalRows;
        data["apartmenttypE_NAME"] = this.apartmenttypE_NAME;
        data["apartmenT_ID"] = this.apartmenT_ID;
        data["apartmenT_CODE"] = this.apartmenT_CODE;
        data["apartmenT_NAME"] = this.apartmenT_NAME;
        data["apartmenttypE_ID"] = this.apartmenttypE_ID;
        data["flooR_ID"] = this.flooR_ID;
        data["apartmenT_STATUS"] = this.apartmenT_STATUS;
        data["description"] = this.description;
        data["apartmenT_PRICE"] = this.apartmenT_PRICE;
        data["apartmenT_ROOMS"] = this.apartmenT_ROOMS;
        data["apartmenT_AREA"] = this.apartmenT_AREA;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IApartmentPagingSearchDTO {
    totalRows: number | undefined;
    apartmenttypE_NAME: string | undefined;
    apartmenT_ID: string | undefined;
    apartmenT_CODE: string | undefined;
    apartmenT_NAME: string | undefined;
    apartmenttypE_ID: string | undefined;
    flooR_ID: string | undefined;
    apartmenT_STATUS: string | undefined;
    description: string | undefined;
    apartmenT_PRICE: number | undefined;
    apartmenT_ROOMS: number | undefined;
    apartmenT_AREA: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ApartmentUpdateRequest implements IApartmentUpdateRequest {
    apartmenT_ID!: string | undefined;
    apartmenT_CODE!: string | undefined;
    apartmenT_NAME!: string | undefined;
    apartmenttypE_ID!: string | undefined;
    flooR_ID!: string | undefined;
    apartmenT_STATUS!: string | undefined;
    description!: string | undefined;
    apartmenT_PRICE!: number | undefined;
    apartmenT_ROOMS!: number | undefined;
    apartmenT_AREA!: number | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IApartmentUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apartmenT_ID = data["apartmenT_ID"];
            this.apartmenT_CODE = data["apartmenT_CODE"];
            this.apartmenT_NAME = data["apartmenT_NAME"];
            this.apartmenttypE_ID = data["apartmenttypE_ID"];
            this.flooR_ID = data["flooR_ID"];
            this.apartmenT_STATUS = data["apartmenT_STATUS"];
            this.description = data["description"];
            this.apartmenT_PRICE = data["apartmenT_PRICE"];
            this.apartmenT_ROOMS = data["apartmenT_ROOMS"];
            this.apartmenT_AREA = data["apartmenT_AREA"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApartmentUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApartmentUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apartmenT_ID"] = this.apartmenT_ID;
        data["apartmenT_CODE"] = this.apartmenT_CODE;
        data["apartmenT_NAME"] = this.apartmenT_NAME;
        data["apartmenttypE_ID"] = this.apartmenttypE_ID;
        data["flooR_ID"] = this.flooR_ID;
        data["apartmenT_STATUS"] = this.apartmenT_STATUS;
        data["description"] = this.description;
        data["apartmenT_PRICE"] = this.apartmenT_PRICE;
        data["apartmenT_ROOMS"] = this.apartmenT_ROOMS;
        data["apartmenT_AREA"] = this.apartmenT_AREA;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IApartmentUpdateRequest {
    apartmenT_ID: string | undefined;
    apartmenT_CODE: string | undefined;
    apartmenT_NAME: string | undefined;
    apartmenttypE_ID: string | undefined;
    flooR_ID: string | undefined;
    apartmenT_STATUS: string | undefined;
    description: string | undefined;
    apartmenT_PRICE: number | undefined;
    apartmenT_ROOMS: number | undefined;
    apartmenT_AREA: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ApartmentTypeDTO implements IApartmentTypeDTO {
    apartmenT_TYPE_ID!: string | undefined;
    apartmenT_TYPE_CODE!: string | undefined;
    apartmenT_TYPE_NAME!: string | undefined;
    apartmenT_TYPE_DESCRIPTION!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IApartmentTypeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apartmenT_TYPE_ID = data["apartmenT_TYPE_ID"];
            this.apartmenT_TYPE_CODE = data["apartmenT_TYPE_CODE"];
            this.apartmenT_TYPE_NAME = data["apartmenT_TYPE_NAME"];
            this.apartmenT_TYPE_DESCRIPTION = data["apartmenT_TYPE_DESCRIPTION"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApartmentTypeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApartmentTypeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apartmenT_TYPE_ID"] = this.apartmenT_TYPE_ID;
        data["apartmenT_TYPE_CODE"] = this.apartmenT_TYPE_CODE;
        data["apartmenT_TYPE_NAME"] = this.apartmenT_TYPE_NAME;
        data["apartmenT_TYPE_DESCRIPTION"] = this.apartmenT_TYPE_DESCRIPTION;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IApartmentTypeDTO {
    apartmenT_TYPE_ID: string | undefined;
    apartmenT_TYPE_CODE: string | undefined;
    apartmenT_TYPE_NAME: string | undefined;
    apartmenT_TYPE_DESCRIPTION: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number | undefined;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment | undefined;
    executionDuration!: number | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number | undefined;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment | undefined;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeListDtoChangeType | undefined;
    changeTypeName!: string | undefined;
    entityChangeSetId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            this.changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeListDtoChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number | undefined;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class BD_DTO implements IBD_DTO {
    bD_ID!: string | undefined;
    bD_CODE!: string | undefined;
    bD_GARAGE!: string | undefined;
    bD_ADDRESS!: string | undefined;
    bD_PRICE!: number | undefined;
    xE_ID!: string | undefined;
    bD_FROM_DT!: moment.Moment | undefined;
    bD_TO_DT!: moment.Moment | undefined;
    createD_DT!: moment.Moment | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    bD_LAST_DISTANCE!: number | undefined;
    bD_DETAILS!: ChiTietBaoDuong_DTO[] | undefined;

    constructor(data?: IBD_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bD_ID = data["bD_ID"];
            this.bD_CODE = data["bD_CODE"];
            this.bD_GARAGE = data["bD_GARAGE"];
            this.bD_ADDRESS = data["bD_ADDRESS"];
            this.bD_PRICE = data["bD_PRICE"];
            this.xE_ID = data["xE_ID"];
            this.bD_FROM_DT = data["bD_FROM_DT"] ? moment(data["bD_FROM_DT"].toString()) : <any>undefined;
            this.bD_TO_DT = data["bD_TO_DT"] ? moment(data["bD_TO_DT"].toString()) : <any>undefined;
            this.createD_DT = data["createD_DT"] ? moment(data["createD_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.bD_LAST_DISTANCE = data["bD_LAST_DISTANCE"];
            if (data["bD_DETAILS"] && data["bD_DETAILS"].constructor === Array) {
                this.bD_DETAILS = [];
                for (let item of data["bD_DETAILS"])
                    this.bD_DETAILS.push(ChiTietBaoDuong_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BD_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new BD_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bD_ID"] = this.bD_ID;
        data["bD_CODE"] = this.bD_CODE;
        data["bD_GARAGE"] = this.bD_GARAGE;
        data["bD_ADDRESS"] = this.bD_ADDRESS;
        data["bD_PRICE"] = this.bD_PRICE;
        data["xE_ID"] = this.xE_ID;
        data["bD_FROM_DT"] = this.bD_FROM_DT ? this.bD_FROM_DT.toISOString() : <any>undefined;
        data["bD_TO_DT"] = this.bD_TO_DT ? this.bD_TO_DT.toISOString() : <any>undefined;
        data["createD_DT"] = this.createD_DT ? this.createD_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["bD_LAST_DISTANCE"] = this.bD_LAST_DISTANCE;
        if (this.bD_DETAILS && this.bD_DETAILS.constructor === Array) {
            data["bD_DETAILS"] = [];
            for (let item of this.bD_DETAILS)
                data["bD_DETAILS"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBD_DTO {
    bD_ID: string | undefined;
    bD_CODE: string | undefined;
    bD_GARAGE: string | undefined;
    bD_ADDRESS: string | undefined;
    bD_PRICE: number | undefined;
    xE_ID: string | undefined;
    bD_FROM_DT: moment.Moment | undefined;
    bD_TO_DT: moment.Moment | undefined;
    createD_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    bD_LAST_DISTANCE: number | undefined;
    bD_DETAILS: ChiTietBaoDuong_DTO[] | undefined;
}

export class ChiTietBaoDuong_DTO implements IChiTietBaoDuong_DTO {
    ctbD_ID!: string | undefined;
    ctbD_CODE!: string | undefined;
    ctbD_NAME!: string | undefined;
    ctbD_QUANTITY!: number | undefined;
    ctbD_UNIT_PRICE!: number | undefined;
    ctbD_TOTAL_PRICE!: number | undefined;
    bD_ID!: string | undefined;
    createD_DT!: moment.Moment | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_STATUS!: string | undefined;
    reason!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IChiTietBaoDuong_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ctbD_ID = data["ctbD_ID"];
            this.ctbD_CODE = data["ctbD_CODE"];
            this.ctbD_NAME = data["ctbD_NAME"];
            this.ctbD_QUANTITY = data["ctbD_QUANTITY"];
            this.ctbD_UNIT_PRICE = data["ctbD_UNIT_PRICE"];
            this.ctbD_TOTAL_PRICE = data["ctbD_TOTAL_PRICE"];
            this.bD_ID = data["bD_ID"];
            this.createD_DT = data["createD_DT"] ? moment(data["createD_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_STATUS = data["approvE_STATUS"];
            this.reason = data["reason"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChiTietBaoDuong_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new ChiTietBaoDuong_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ctbD_ID"] = this.ctbD_ID;
        data["ctbD_CODE"] = this.ctbD_CODE;
        data["ctbD_NAME"] = this.ctbD_NAME;
        data["ctbD_QUANTITY"] = this.ctbD_QUANTITY;
        data["ctbD_UNIT_PRICE"] = this.ctbD_UNIT_PRICE;
        data["ctbD_TOTAL_PRICE"] = this.ctbD_TOTAL_PRICE;
        data["bD_ID"] = this.bD_ID;
        data["createD_DT"] = this.createD_DT ? this.createD_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_STATUS"] = this.approvE_STATUS;
        data["reason"] = this.reason;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IChiTietBaoDuong_DTO {
    ctbD_ID: string | undefined;
    ctbD_CODE: string | undefined;
    ctbD_NAME: string | undefined;
    ctbD_QUANTITY: number | undefined;
    ctbD_UNIT_PRICE: number | undefined;
    ctbD_TOTAL_PRICE: number | undefined;
    bD_ID: string | undefined;
    createD_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_STATUS: string | undefined;
    reason: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfBD_DTO implements IPagedResultDtoOfBD_DTO {
    totalCount!: number | undefined;
    items!: BD_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfBD_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BD_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBD_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBD_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBD_DTO {
    totalCount: number | undefined;
    items: BD_DTO[] | undefined;
}

export class PagedResultDtoOfGroup03BranchDTO implements IPagedResultDtoOfGroup03BranchDTO {
    totalCount!: number | undefined;
    items!: Group03BranchDTO[] | undefined;

    constructor(data?: IPagedResultDtoOfGroup03BranchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Group03BranchDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGroup03BranchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGroup03BranchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGroup03BranchDTO {
    totalCount: number | undefined;
    items: Group03BranchDTO[] | undefined;
}

export class Group03BranchDTO implements IGroup03BranchDTO {
    brancH_ID!: string | undefined;
    fatheR_ID!: string | undefined;
    iS_POTENTIAL!: string | undefined;
    brancH_CODE!: string | undefined;
    brancH_NAME!: string | undefined;
    daO_CODE!: string | undefined;
    daO_NAME!: string | undefined;
    regioN_ID!: string | undefined;
    brancH_TYPE!: string | undefined;
    brancH_EMAIL!: string | undefined;
    brancH_FAX!: string | undefined;
    brancH_STATUS!: string | undefined;
    addr!: string | undefined;
    provice!: string | undefined;
    tel!: string | undefined;
    taX_NO!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IGroup03BranchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brancH_ID = data["brancH_ID"];
            this.fatheR_ID = data["fatheR_ID"];
            this.iS_POTENTIAL = data["iS_POTENTIAL"];
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.daO_CODE = data["daO_CODE"];
            this.daO_NAME = data["daO_NAME"];
            this.regioN_ID = data["regioN_ID"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.brancH_EMAIL = data["brancH_EMAIL"];
            this.brancH_FAX = data["brancH_FAX"];
            this.brancH_STATUS = data["brancH_STATUS"];
            this.addr = data["addr"];
            this.provice = data["provice"];
            this.tel = data["tel"];
            this.taX_NO = data["taX_NO"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Group03BranchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new Group03BranchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brancH_ID"] = this.brancH_ID;
        data["fatheR_ID"] = this.fatheR_ID;
        data["iS_POTENTIAL"] = this.iS_POTENTIAL;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["daO_CODE"] = this.daO_CODE;
        data["daO_NAME"] = this.daO_NAME;
        data["regioN_ID"] = this.regioN_ID;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["brancH_EMAIL"] = this.brancH_EMAIL;
        data["brancH_FAX"] = this.brancH_FAX;
        data["brancH_STATUS"] = this.brancH_STATUS;
        data["addr"] = this.addr;
        data["provice"] = this.provice;
        data["tel"] = this.tel;
        data["taX_NO"] = this.taX_NO;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGroup03BranchDTO {
    brancH_ID: string | undefined;
    fatheR_ID: string | undefined;
    iS_POTENTIAL: string | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    regioN_ID: string | undefined;
    brancH_TYPE: string | undefined;
    brancH_EMAIL: string | undefined;
    brancH_FAX: string | undefined;
    brancH_STATUS: string | undefined;
    addr: string | undefined;
    provice: string | undefined;
    tel: string | undefined;
    taX_NO: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class CM_BRANCH_DTO implements ICM_BRANCH_DTO {
    brancH_ID!: string | undefined;
    fatheR_ID!: string | undefined;
    iS_POTENTIAL!: string | undefined;
    brancH_CODE!: string | undefined;
    brancH_NAME!: string | undefined;
    daO_CODE!: string | undefined;
    daO_NAME!: string | undefined;
    regioN_ID!: string | undefined;
    brancH_TYPE!: string | undefined;
    brancH_EMAIL!: string | undefined;
    brancH_FAX!: string | undefined;
    brancH_STATUS!: string | undefined;
    addr!: string | undefined;
    provice!: string | undefined;
    tel!: string | undefined;
    taX_NO!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: ICM_BRANCH_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brancH_ID = data["brancH_ID"];
            this.fatheR_ID = data["fatheR_ID"];
            this.iS_POTENTIAL = data["iS_POTENTIAL"];
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.daO_CODE = data["daO_CODE"];
            this.daO_NAME = data["daO_NAME"];
            this.regioN_ID = data["regioN_ID"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.brancH_EMAIL = data["brancH_EMAIL"];
            this.brancH_FAX = data["brancH_FAX"];
            this.brancH_STATUS = data["brancH_STATUS"];
            this.addr = data["addr"];
            this.provice = data["provice"];
            this.tel = data["tel"];
            this.taX_NO = data["taX_NO"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_BRANCH_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new CM_BRANCH_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brancH_ID"] = this.brancH_ID;
        data["fatheR_ID"] = this.fatheR_ID;
        data["iS_POTENTIAL"] = this.iS_POTENTIAL;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["daO_CODE"] = this.daO_CODE;
        data["daO_NAME"] = this.daO_NAME;
        data["regioN_ID"] = this.regioN_ID;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["brancH_EMAIL"] = this.brancH_EMAIL;
        data["brancH_FAX"] = this.brancH_FAX;
        data["brancH_STATUS"] = this.brancH_STATUS;
        data["addr"] = this.addr;
        data["provice"] = this.provice;
        data["tel"] = this.tel;
        data["taX_NO"] = this.taX_NO;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICM_BRANCH_DTO {
    brancH_ID: string | undefined;
    fatheR_ID: string | undefined;
    iS_POTENTIAL: string | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    regioN_ID: string | undefined;
    brancH_TYPE: string | undefined;
    brancH_EMAIL: string | undefined;
    brancH_FAX: string | undefined;
    brancH_STATUS: string | undefined;
    addr: string | undefined;
    provice: string | undefined;
    tel: string | undefined;
    taX_NO: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class BuildingApproveRequest implements IBuildingApproveRequest {
    buildinG_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;

    constructor(data?: IBuildingApproveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildinG_ID = data["buildinG_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
        }
    }

    static fromJS(data: any): BuildingApproveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingApproveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildinG_ID"] = this.buildinG_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        return data; 
    }
}

export interface IBuildingApproveRequest {
    buildinG_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
}

export class BuildingCreateRequest implements IBuildingCreateRequest {
    buildinG_CODE!: string | undefined;
    buildinG_NAME!: string | undefined;
    address!: string | undefined;
    flooR_NO!: number | undefined;
    description!: string | undefined;
    manageR_ID!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IBuildingCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildinG_CODE = data["buildinG_CODE"];
            this.buildinG_NAME = data["buildinG_NAME"];
            this.address = data["address"];
            this.flooR_NO = data["flooR_NO"];
            this.description = data["description"];
            this.manageR_ID = data["manageR_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BuildingCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildinG_CODE"] = this.buildinG_CODE;
        data["buildinG_NAME"] = this.buildinG_NAME;
        data["address"] = this.address;
        data["flooR_NO"] = this.flooR_NO;
        data["description"] = this.description;
        data["manageR_ID"] = this.manageR_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBuildingCreateRequest {
    buildinG_CODE: string | undefined;
    buildinG_NAME: string | undefined;
    address: string | undefined;
    flooR_NO: number | undefined;
    description: string | undefined;
    manageR_ID: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class BuildingTableDTO implements IBuildingTableDTO {
    buildinG_ID!: string | undefined;
    buildinG_CODE!: string | undefined;
    buildinG_NAME!: string | undefined;
    address!: string | undefined;
    flooR_NO!: number | undefined;
    description!: string | undefined;
    manageR_ID!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IBuildingTableDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildinG_ID = data["buildinG_ID"];
            this.buildinG_CODE = data["buildinG_CODE"];
            this.buildinG_NAME = data["buildinG_NAME"];
            this.address = data["address"];
            this.flooR_NO = data["flooR_NO"];
            this.description = data["description"];
            this.manageR_ID = data["manageR_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BuildingTableDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingTableDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildinG_ID"] = this.buildinG_ID;
        data["buildinG_CODE"] = this.buildinG_CODE;
        data["buildinG_NAME"] = this.buildinG_NAME;
        data["address"] = this.address;
        data["flooR_NO"] = this.flooR_NO;
        data["description"] = this.description;
        data["manageR_ID"] = this.manageR_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBuildingTableDTO {
    buildinG_ID: string | undefined;
    buildinG_CODE: string | undefined;
    buildinG_NAME: string | undefined;
    address: string | undefined;
    flooR_NO: number | undefined;
    description: string | undefined;
    manageR_ID: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfBuildingPagingSearchDTO implements IPagedResultDtoOfBuildingPagingSearchDTO {
    totalCount!: number | undefined;
    items!: BuildingPagingSearchDTO[] | undefined;

    constructor(data?: IPagedResultDtoOfBuildingPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BuildingPagingSearchDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBuildingPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBuildingPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBuildingPagingSearchDTO {
    totalCount: number | undefined;
    items: BuildingPagingSearchDTO[] | undefined;
}

export class BuildingPagingSearchDTO implements IBuildingPagingSearchDTO {
    totalRows!: number | undefined;
    buildinG_ID!: string | undefined;
    buildinG_CODE!: string | undefined;
    buildinG_NAME!: string | undefined;
    address!: string | undefined;
    flooR_NO!: number | undefined;
    description!: string | undefined;
    manageR_ID!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IBuildingPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalRows = data["totalRows"];
            this.buildinG_ID = data["buildinG_ID"];
            this.buildinG_CODE = data["buildinG_CODE"];
            this.buildinG_NAME = data["buildinG_NAME"];
            this.address = data["address"];
            this.flooR_NO = data["flooR_NO"];
            this.description = data["description"];
            this.manageR_ID = data["manageR_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BuildingPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRows"] = this.totalRows;
        data["buildinG_ID"] = this.buildinG_ID;
        data["buildinG_CODE"] = this.buildinG_CODE;
        data["buildinG_NAME"] = this.buildinG_NAME;
        data["address"] = this.address;
        data["flooR_NO"] = this.flooR_NO;
        data["description"] = this.description;
        data["manageR_ID"] = this.manageR_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBuildingPagingSearchDTO {
    totalRows: number | undefined;
    buildinG_ID: string | undefined;
    buildinG_CODE: string | undefined;
    buildinG_NAME: string | undefined;
    address: string | undefined;
    flooR_NO: number | undefined;
    description: string | undefined;
    manageR_ID: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class BuildingUpdateRequest implements IBuildingUpdateRequest {
    buildinG_ID!: string | undefined;
    buildinG_CODE!: string | undefined;
    buildinG_NAME!: string | undefined;
    address!: string | undefined;
    flooR_NO!: number | undefined;
    description!: string | undefined;
    manageR_ID!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IBuildingUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.buildinG_ID = data["buildinG_ID"];
            this.buildinG_CODE = data["buildinG_CODE"];
            this.buildinG_NAME = data["buildinG_NAME"];
            this.address = data["address"];
            this.flooR_NO = data["flooR_NO"];
            this.description = data["description"];
            this.manageR_ID = data["manageR_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BuildingUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buildinG_ID"] = this.buildinG_ID;
        data["buildinG_CODE"] = this.buildinG_CODE;
        data["buildinG_NAME"] = this.buildinG_NAME;
        data["address"] = this.address;
        data["flooR_NO"] = this.flooR_NO;
        data["description"] = this.description;
        data["manageR_ID"] = this.manageR_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBuildingUpdateRequest {
    buildinG_ID: string | undefined;
    buildinG_CODE: string | undefined;
    buildinG_NAME: string | undefined;
    address: string | undefined;
    flooR_NO: number | undefined;
    description: string | undefined;
    manageR_ID: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment | undefined;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [];
                for (let item of data["friends"])
                    this.friends.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number | undefined;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number | undefined;
    isOnline!: boolean | undefined;
    state!: FriendDtoState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendDtoState | undefined;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    targetUserId!: number | undefined;
    targetTenantId!: number | undefined;
    side!: ChatMessageDtoSide | undefined;
    readState!: ChatMessageDtoReadState | undefined;
    receiverReadState!: ChatMessageDtoReceiverReadState | undefined;
    message!: string | undefined;
    creationTime!: moment.Moment | undefined;
    sharedMessageId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatMessageDtoSide | undefined;
    readState: ChatMessageDtoReadState | undefined;
    receiverReadState: ChatMessageDtoReceiverReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class CHI_TIET_BAN_KIEM_KE_DTO implements ICHI_TIET_BAN_KIEM_KE_DTO {
    ctbkK_ID!: string | undefined;
    ctbkK_BKK_ID!: string | undefined;
    ctbkK_MA_TB!: string | undefined;
    ctbkK_TT!: string | undefined;
    ctbkK_CHECK!: string | undefined;
    ctbkK_TT_SAU!: string | undefined;
    ctbkK_TEN_TB!: string | undefined;
    ctbkK_DV_QL!: string | undefined;
    ctbkK_THOI_GIAN!: moment.Moment | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: ICHI_TIET_BAN_KIEM_KE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ctbkK_ID = data["ctbkK_ID"];
            this.ctbkK_BKK_ID = data["ctbkK_BKK_ID"];
            this.ctbkK_MA_TB = data["ctbkK_MA_TB"];
            this.ctbkK_TT = data["ctbkK_TT"];
            this.ctbkK_CHECK = data["ctbkK_CHECK"];
            this.ctbkK_TT_SAU = data["ctbkK_TT_SAU"];
            this.ctbkK_TEN_TB = data["ctbkK_TEN_TB"];
            this.ctbkK_DV_QL = data["ctbkK_DV_QL"];
            this.ctbkK_THOI_GIAN = data["ctbkK_THOI_GIAN"] ? moment(data["ctbkK_THOI_GIAN"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CHI_TIET_BAN_KIEM_KE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new CHI_TIET_BAN_KIEM_KE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ctbkK_ID"] = this.ctbkK_ID;
        data["ctbkK_BKK_ID"] = this.ctbkK_BKK_ID;
        data["ctbkK_MA_TB"] = this.ctbkK_MA_TB;
        data["ctbkK_TT"] = this.ctbkK_TT;
        data["ctbkK_CHECK"] = this.ctbkK_CHECK;
        data["ctbkK_TT_SAU"] = this.ctbkK_TT_SAU;
        data["ctbkK_TEN_TB"] = this.ctbkK_TEN_TB;
        data["ctbkK_DV_QL"] = this.ctbkK_DV_QL;
        data["ctbkK_THOI_GIAN"] = this.ctbkK_THOI_GIAN ? this.ctbkK_THOI_GIAN.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICHI_TIET_BAN_KIEM_KE_DTO {
    ctbkK_ID: string | undefined;
    ctbkK_BKK_ID: string | undefined;
    ctbkK_MA_TB: string | undefined;
    ctbkK_TT: string | undefined;
    ctbkK_CHECK: string | undefined;
    ctbkK_TT_SAU: string | undefined;
    ctbkK_TEN_TB: string | undefined;
    ctbkK_DV_QL: string | undefined;
    ctbkK_THOI_GIAN: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ThietBiVatTu implements IThietBiVatTu {
    tbvT_ID!: number | undefined;
    tbvT_MA_TBVT!: string | undefined;
    tbvT_TEN!: string | undefined;
    tbvT_SERIAL!: string | undefined;
    tbvT_LOAI!: string | undefined;
    tbvT_NGAY_MUA!: moment.Moment | undefined;
    tbvT_DVT!: string | undefined;
    tbvT_NHAP_THEO_LO!: string | undefined;
    tbvT_SL_THEO_LO!: number | undefined;
    tbvT_HANG_SX!: string | undefined;
    tbvT_NAM_SX!: string | undefined;
    tbvT_NGAY_TINH_BAO_HANH!: moment.Moment | undefined;
    tbvT_NGAY_KET_THUC_BAO_HANH!: moment.Moment | undefined;
    tbvT_NHA_CUNG_CAP!: string | undefined;
    tbvT_TINH_TRANG_THIET_BI!: string | undefined;
    tbvT_GHI_CHU_TINH_TRANG!: string | undefined;
    tbvT_CAN_BAO_DUONG!: string | undefined;
    tbvT_CHU_KY_BAO_DUONG!: string | undefined;
    tbvT_NOI_DUNG_BAO_DUONG!: string | undefined;
    tbvT_TI_LE_HAO_MON!: string | undefined;
    tbvT_TINH_TRANG_TBTBVT!: string | undefined;
    tbvT_PhuKien!: PhuKien_DTO[] | undefined;
    recorD_STATUS!: string | undefined;

    constructor(data?: IThietBiVatTu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tbvT_ID = data["tbvT_ID"];
            this.tbvT_MA_TBVT = data["tbvT_MA_TBVT"];
            this.tbvT_TEN = data["tbvT_TEN"];
            this.tbvT_SERIAL = data["tbvT_SERIAL"];
            this.tbvT_LOAI = data["tbvT_LOAI"];
            this.tbvT_NGAY_MUA = data["tbvT_NGAY_MUA"] ? moment(data["tbvT_NGAY_MUA"].toString()) : <any>undefined;
            this.tbvT_DVT = data["tbvT_DVT"];
            this.tbvT_NHAP_THEO_LO = data["tbvT_NHAP_THEO_LO"];
            this.tbvT_SL_THEO_LO = data["tbvT_SL_THEO_LO"];
            this.tbvT_HANG_SX = data["tbvT_HANG_SX"];
            this.tbvT_NAM_SX = data["tbvT_NAM_SX"];
            this.tbvT_NGAY_TINH_BAO_HANH = data["tbvT_NGAY_TINH_BAO_HANH"] ? moment(data["tbvT_NGAY_TINH_BAO_HANH"].toString()) : <any>undefined;
            this.tbvT_NGAY_KET_THUC_BAO_HANH = data["tbvT_NGAY_KET_THUC_BAO_HANH"] ? moment(data["tbvT_NGAY_KET_THUC_BAO_HANH"].toString()) : <any>undefined;
            this.tbvT_NHA_CUNG_CAP = data["tbvT_NHA_CUNG_CAP"];
            this.tbvT_TINH_TRANG_THIET_BI = data["tbvT_TINH_TRANG_THIET_BI"];
            this.tbvT_GHI_CHU_TINH_TRANG = data["tbvT_GHI_CHU_TINH_TRANG"];
            this.tbvT_CAN_BAO_DUONG = data["tbvT_CAN_BAO_DUONG"];
            this.tbvT_CHU_KY_BAO_DUONG = data["tbvT_CHU_KY_BAO_DUONG"];
            this.tbvT_NOI_DUNG_BAO_DUONG = data["tbvT_NOI_DUNG_BAO_DUONG"];
            this.tbvT_TI_LE_HAO_MON = data["tbvT_TI_LE_HAO_MON"];
            this.tbvT_TINH_TRANG_TBTBVT = data["tbvT_TINH_TRANG_TBTBVT"];
            if (data["tbvT_PhuKien"] && data["tbvT_PhuKien"].constructor === Array) {
                this.tbvT_PhuKien = [];
                for (let item of data["tbvT_PhuKien"])
                    this.tbvT_PhuKien.push(PhuKien_DTO.fromJS(item));
            }
            this.recorD_STATUS = data["recorD_STATUS"];
        }
    }

    static fromJS(data: any): ThietBiVatTu {
        data = typeof data === 'object' ? data : {};
        let result = new ThietBiVatTu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tbvT_ID"] = this.tbvT_ID;
        data["tbvT_MA_TBVT"] = this.tbvT_MA_TBVT;
        data["tbvT_TEN"] = this.tbvT_TEN;
        data["tbvT_SERIAL"] = this.tbvT_SERIAL;
        data["tbvT_LOAI"] = this.tbvT_LOAI;
        data["tbvT_NGAY_MUA"] = this.tbvT_NGAY_MUA ? this.tbvT_NGAY_MUA.toISOString() : <any>undefined;
        data["tbvT_DVT"] = this.tbvT_DVT;
        data["tbvT_NHAP_THEO_LO"] = this.tbvT_NHAP_THEO_LO;
        data["tbvT_SL_THEO_LO"] = this.tbvT_SL_THEO_LO;
        data["tbvT_HANG_SX"] = this.tbvT_HANG_SX;
        data["tbvT_NAM_SX"] = this.tbvT_NAM_SX;
        data["tbvT_NGAY_TINH_BAO_HANH"] = this.tbvT_NGAY_TINH_BAO_HANH ? this.tbvT_NGAY_TINH_BAO_HANH.toISOString() : <any>undefined;
        data["tbvT_NGAY_KET_THUC_BAO_HANH"] = this.tbvT_NGAY_KET_THUC_BAO_HANH ? this.tbvT_NGAY_KET_THUC_BAO_HANH.toISOString() : <any>undefined;
        data["tbvT_NHA_CUNG_CAP"] = this.tbvT_NHA_CUNG_CAP;
        data["tbvT_TINH_TRANG_THIET_BI"] = this.tbvT_TINH_TRANG_THIET_BI;
        data["tbvT_GHI_CHU_TINH_TRANG"] = this.tbvT_GHI_CHU_TINH_TRANG;
        data["tbvT_CAN_BAO_DUONG"] = this.tbvT_CAN_BAO_DUONG;
        data["tbvT_CHU_KY_BAO_DUONG"] = this.tbvT_CHU_KY_BAO_DUONG;
        data["tbvT_NOI_DUNG_BAO_DUONG"] = this.tbvT_NOI_DUNG_BAO_DUONG;
        data["tbvT_TI_LE_HAO_MON"] = this.tbvT_TI_LE_HAO_MON;
        data["tbvT_TINH_TRANG_TBTBVT"] = this.tbvT_TINH_TRANG_TBTBVT;
        if (this.tbvT_PhuKien && this.tbvT_PhuKien.constructor === Array) {
            data["tbvT_PhuKien"] = [];
            for (let item of this.tbvT_PhuKien)
                data["tbvT_PhuKien"].push(item.toJSON());
        }
        data["recorD_STATUS"] = this.recorD_STATUS;
        return data; 
    }
}

export interface IThietBiVatTu {
    tbvT_ID: number | undefined;
    tbvT_MA_TBVT: string | undefined;
    tbvT_TEN: string | undefined;
    tbvT_SERIAL: string | undefined;
    tbvT_LOAI: string | undefined;
    tbvT_NGAY_MUA: moment.Moment | undefined;
    tbvT_DVT: string | undefined;
    tbvT_NHAP_THEO_LO: string | undefined;
    tbvT_SL_THEO_LO: number | undefined;
    tbvT_HANG_SX: string | undefined;
    tbvT_NAM_SX: string | undefined;
    tbvT_NGAY_TINH_BAO_HANH: moment.Moment | undefined;
    tbvT_NGAY_KET_THUC_BAO_HANH: moment.Moment | undefined;
    tbvT_NHA_CUNG_CAP: string | undefined;
    tbvT_TINH_TRANG_THIET_BI: string | undefined;
    tbvT_GHI_CHU_TINH_TRANG: string | undefined;
    tbvT_CAN_BAO_DUONG: string | undefined;
    tbvT_CHU_KY_BAO_DUONG: string | undefined;
    tbvT_NOI_DUNG_BAO_DUONG: string | undefined;
    tbvT_TI_LE_HAO_MON: string | undefined;
    tbvT_TINH_TRANG_TBTBVT: string | undefined;
    tbvT_PhuKien: PhuKien_DTO[] | undefined;
    recorD_STATUS: string | undefined;
}

export class PhuKien_DTO implements IPhuKien_DTO {
    phU_KIEN_ID!: number | undefined;
    phU_KIEN_TBVT_ID!: number | undefined;
    phU_KIEN_MA_PK!: string | undefined;
    phU_KIEN_TEN!: string | undefined;
    phU_KIEN_DVT!: string | undefined;
    phU_KIEN_SO_LUONG!: number | undefined;
    phU_KIEN_GHI_CHU!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_CREATE!: string | undefined;

    constructor(data?: IPhuKien_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phU_KIEN_ID = data["phU_KIEN_ID"];
            this.phU_KIEN_TBVT_ID = data["phU_KIEN_TBVT_ID"];
            this.phU_KIEN_MA_PK = data["phU_KIEN_MA_PK"];
            this.phU_KIEN_TEN = data["phU_KIEN_TEN"];
            this.phU_KIEN_DVT = data["phU_KIEN_DVT"];
            this.phU_KIEN_SO_LUONG = data["phU_KIEN_SO_LUONG"];
            this.phU_KIEN_GHI_CHU = data["phU_KIEN_GHI_CHU"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CREATE = data["brancH_CREATE"];
        }
    }

    static fromJS(data: any): PhuKien_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PhuKien_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phU_KIEN_ID"] = this.phU_KIEN_ID;
        data["phU_KIEN_TBVT_ID"] = this.phU_KIEN_TBVT_ID;
        data["phU_KIEN_MA_PK"] = this.phU_KIEN_MA_PK;
        data["phU_KIEN_TEN"] = this.phU_KIEN_TEN;
        data["phU_KIEN_DVT"] = this.phU_KIEN_DVT;
        data["phU_KIEN_SO_LUONG"] = this.phU_KIEN_SO_LUONG;
        data["phU_KIEN_GHI_CHU"] = this.phU_KIEN_GHI_CHU;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CREATE"] = this.brancH_CREATE;
        return data; 
    }
}

export interface IPhuKien_DTO {
    phU_KIEN_ID: number | undefined;
    phU_KIEN_TBVT_ID: number | undefined;
    phU_KIEN_MA_PK: string | undefined;
    phU_KIEN_TEN: string | undefined;
    phU_KIEN_DVT: string | undefined;
    phU_KIEN_SO_LUONG: number | undefined;
    phU_KIEN_GHI_CHU: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CREATE: string | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number | undefined;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class ContractApproveRequest implements IContractApproveRequest {
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;

    constructor(data?: IContractApproveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
        }
    }

    static fromJS(data: any): ContractApproveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContractApproveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        return data; 
    }
}

export interface IContractApproveRequest {
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
}

export class ContractCreateRequest implements IContractCreateRequest {
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IContractCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContractCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContractCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContractCreateRequest {
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ContractTableDTO implements IContractTableDTO {
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IContractTableDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContractTableDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTableDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContractTableDTO {
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfContractPagingSearchDTO implements IPagedResultDtoOfContractPagingSearchDTO {
    totalCount!: number | undefined;
    items!: ContractPagingSearchDTO[] | undefined;

    constructor(data?: IPagedResultDtoOfContractPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContractPagingSearchDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContractPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContractPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfContractPagingSearchDTO {
    totalCount: number | undefined;
    items: ContractPagingSearchDTO[] | undefined;
}

export class ContractPagingSearchDTO implements IContractPagingSearchDTO {
    totalRows!: number | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IContractPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalRows = data["totalRows"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContractPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ContractPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRows"] = this.totalRows;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContractPagingSearchDTO {
    totalRows: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ContractUpdateRequest implements IContractUpdateRequest {
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IContractUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContractUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContractUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContractUpdateRequest {
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfChiTietBaoDuong_DTO implements IPagedResultDtoOfChiTietBaoDuong_DTO {
    totalCount!: number | undefined;
    items!: ChiTietBaoDuong_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfChiTietBaoDuong_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChiTietBaoDuong_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfChiTietBaoDuong_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfChiTietBaoDuong_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfChiTietBaoDuong_DTO {
    totalCount: number | undefined;
    items: ChiTietBaoDuong_DTO[] | undefined;
}

export class ChiTietNhanVien_DTO implements IChiTietNhanVien_DTO {
    ctnV_MANV!: string | undefined;
    ctnV_TEN_NV!: string | undefined;
    ctnV_CHUC_VU!: string | undefined;
    ctnV_SDT!: string | undefined;
    ctnV_PHONG_BAN!: string | undefined;
    ctnV_CMND!: string | undefined;
    ctnV_DIA_CHI!: string | undefined;
    ctnV_NGAY_CAP_CMND!: moment.Moment | undefined;
    ctnV_NOI_CAP_CMND!: string | undefined;
    ctnV_MA_SO_THUE!: string | undefined;
    ctnV_TRANG_THAI_HOAT_DONG!: string | undefined;
    ctnV_EMAIL!: string | undefined;
    ctnV_MO_TA!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IChiTietNhanVien_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ctnV_MANV = data["ctnV_MANV"];
            this.ctnV_TEN_NV = data["ctnV_TEN_NV"];
            this.ctnV_CHUC_VU = data["ctnV_CHUC_VU"];
            this.ctnV_SDT = data["ctnV_SDT"];
            this.ctnV_PHONG_BAN = data["ctnV_PHONG_BAN"];
            this.ctnV_CMND = data["ctnV_CMND"];
            this.ctnV_DIA_CHI = data["ctnV_DIA_CHI"];
            this.ctnV_NGAY_CAP_CMND = data["ctnV_NGAY_CAP_CMND"] ? moment(data["ctnV_NGAY_CAP_CMND"].toString()) : <any>undefined;
            this.ctnV_NOI_CAP_CMND = data["ctnV_NOI_CAP_CMND"];
            this.ctnV_MA_SO_THUE = data["ctnV_MA_SO_THUE"];
            this.ctnV_TRANG_THAI_HOAT_DONG = data["ctnV_TRANG_THAI_HOAT_DONG"];
            this.ctnV_EMAIL = data["ctnV_EMAIL"];
            this.ctnV_MO_TA = data["ctnV_MO_TA"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChiTietNhanVien_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new ChiTietNhanVien_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ctnV_MANV"] = this.ctnV_MANV;
        data["ctnV_TEN_NV"] = this.ctnV_TEN_NV;
        data["ctnV_CHUC_VU"] = this.ctnV_CHUC_VU;
        data["ctnV_SDT"] = this.ctnV_SDT;
        data["ctnV_PHONG_BAN"] = this.ctnV_PHONG_BAN;
        data["ctnV_CMND"] = this.ctnV_CMND;
        data["ctnV_DIA_CHI"] = this.ctnV_DIA_CHI;
        data["ctnV_NGAY_CAP_CMND"] = this.ctnV_NGAY_CAP_CMND ? this.ctnV_NGAY_CAP_CMND.toISOString() : <any>undefined;
        data["ctnV_NOI_CAP_CMND"] = this.ctnV_NOI_CAP_CMND;
        data["ctnV_MA_SO_THUE"] = this.ctnV_MA_SO_THUE;
        data["ctnV_TRANG_THAI_HOAT_DONG"] = this.ctnV_TRANG_THAI_HOAT_DONG;
        data["ctnV_EMAIL"] = this.ctnV_EMAIL;
        data["ctnV_MO_TA"] = this.ctnV_MO_TA;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IChiTietNhanVien_DTO {
    ctnV_MANV: string | undefined;
    ctnV_TEN_NV: string | undefined;
    ctnV_CHUC_VU: string | undefined;
    ctnV_SDT: string | undefined;
    ctnV_PHONG_BAN: string | undefined;
    ctnV_CMND: string | undefined;
    ctnV_DIA_CHI: string | undefined;
    ctnV_NGAY_CAP_CMND: moment.Moment | undefined;
    ctnV_NOI_CAP_CMND: string | undefined;
    ctnV_MA_SO_THUE: string | undefined;
    ctnV_TRANG_THAI_HOAT_DONG: string | undefined;
    ctnV_EMAIL: string | undefined;
    ctnV_MO_TA: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class YCSCStatisticsOutput_DTO implements IYCSCStatisticsOutput_DTO {
    status_YCSC!: string | undefined;
    total_Status!: number | undefined;
    ycscStatistics!: YCSCStatistic[] | undefined;

    constructor(data?: IYCSCStatisticsOutput_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status_YCSC = data["status_YCSC"];
            this.total_Status = data["total_Status"];
            if (data["ycscStatistics"] && data["ycscStatistics"].constructor === Array) {
                this.ycscStatistics = [];
                for (let item of data["ycscStatistics"])
                    this.ycscStatistics.push(YCSCStatistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): YCSCStatisticsOutput_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new YCSCStatisticsOutput_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status_YCSC"] = this.status_YCSC;
        data["total_Status"] = this.total_Status;
        if (this.ycscStatistics && this.ycscStatistics.constructor === Array) {
            data["ycscStatistics"] = [];
            for (let item of this.ycscStatistics)
                data["ycscStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IYCSCStatisticsOutput_DTO {
    status_YCSC: string | undefined;
    total_Status: number | undefined;
    ycscStatistics: YCSCStatistic[] | undefined;
}

export class YCSCStatistic implements IYCSCStatistic {
    label!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IYCSCStatistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): YCSCStatistic {
        data = typeof data === 'object' ? data : {};
        let result = new YCSCStatistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IYCSCStatistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class PagedResultDtoOfDemoModelDto implements IPagedResultDtoOfDemoModelDto {
    totalCount!: number | undefined;
    items!: DemoModelDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDemoModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DemoModelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDemoModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDemoModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDemoModelDto {
    totalCount: number | undefined;
    items: DemoModelDto[] | undefined;
}

export class DemoModelDto implements IDemoModelDto {
    value!: number | undefined;
    info!: string | undefined;
    date!: moment.Moment | undefined;

    constructor(data?: IDemoModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.info = data["info"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DemoModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new DemoModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["info"] = this.info;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDemoModelDto {
    value: number | undefined;
    info: string | undefined;
    date: moment.Moment | undefined;
}

export class DemoModelInput implements IDemoModelInput {
    value!: number | undefined;
    info!: string | undefined;
    date!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IDemoModelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.info = data["info"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DemoModelInput {
        data = typeof data === 'object' ? data : {};
        let result = new DemoModelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["info"] = this.info;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDemoModelInput {
    value: number | undefined;
    info: string | undefined;
    date: moment.Moment | undefined;
    id: number | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class CM_DEV_DTO implements ICM_DEV_DTO {
    devicE_ID!: string | undefined;
    devicE_CODE!: string | undefined;
    devicE_NAME!: string | undefined;
    brancH_ID!: string | undefined;
    maintenancE_CYCLE!: string | undefined;
    recorD_STATUS!: string | undefined;
    activE_STATUS!: string | undefined;
    datE_BUY!: moment.Moment | undefined;
    datE_WARRANTY_BEGIN!: moment.Moment | undefined;
    datE_WARRANTY_END!: moment.Moment | undefined;
    descriptions!: string | undefined;
    produceR_ID!: string | undefined;
    yeaR_PRODUCTION!: number | undefined;
    serial!: string | undefined;
    makeR_ID!: string | undefined;
    checkeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    brancH_NAME!: string | undefined;

    constructor(data?: ICM_DEV_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.devicE_ID = data["devicE_ID"];
            this.devicE_CODE = data["devicE_CODE"];
            this.devicE_NAME = data["devicE_NAME"];
            this.brancH_ID = data["brancH_ID"];
            this.maintenancE_CYCLE = data["maintenancE_CYCLE"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.activE_STATUS = data["activE_STATUS"];
            this.datE_BUY = data["datE_BUY"] ? moment(data["datE_BUY"].toString()) : <any>undefined;
            this.datE_WARRANTY_BEGIN = data["datE_WARRANTY_BEGIN"] ? moment(data["datE_WARRANTY_BEGIN"].toString()) : <any>undefined;
            this.datE_WARRANTY_END = data["datE_WARRANTY_END"] ? moment(data["datE_WARRANTY_END"].toString()) : <any>undefined;
            this.descriptions = data["descriptions"];
            this.produceR_ID = data["produceR_ID"];
            this.yeaR_PRODUCTION = data["yeaR_PRODUCTION"];
            this.serial = data["serial"];
            this.makeR_ID = data["makeR_ID"];
            this.checkeR_ID = data["checkeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.brancH_NAME = data["brancH_NAME"];
        }
    }

    static fromJS(data: any): CM_DEV_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DEV_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["devicE_ID"] = this.devicE_ID;
        data["devicE_CODE"] = this.devicE_CODE;
        data["devicE_NAME"] = this.devicE_NAME;
        data["brancH_ID"] = this.brancH_ID;
        data["maintenancE_CYCLE"] = this.maintenancE_CYCLE;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["activE_STATUS"] = this.activE_STATUS;
        data["datE_BUY"] = this.datE_BUY ? this.datE_BUY.toISOString() : <any>undefined;
        data["datE_WARRANTY_BEGIN"] = this.datE_WARRANTY_BEGIN ? this.datE_WARRANTY_BEGIN.toISOString() : <any>undefined;
        data["datE_WARRANTY_END"] = this.datE_WARRANTY_END ? this.datE_WARRANTY_END.toISOString() : <any>undefined;
        data["descriptions"] = this.descriptions;
        data["produceR_ID"] = this.produceR_ID;
        data["yeaR_PRODUCTION"] = this.yeaR_PRODUCTION;
        data["serial"] = this.serial;
        data["makeR_ID"] = this.makeR_ID;
        data["checkeR_ID"] = this.checkeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["brancH_NAME"] = this.brancH_NAME;
        return data; 
    }
}

export interface ICM_DEV_DTO {
    devicE_ID: string | undefined;
    devicE_CODE: string | undefined;
    devicE_NAME: string | undefined;
    brancH_ID: string | undefined;
    maintenancE_CYCLE: string | undefined;
    recorD_STATUS: string | undefined;
    activE_STATUS: string | undefined;
    datE_BUY: moment.Moment | undefined;
    datE_WARRANTY_BEGIN: moment.Moment | undefined;
    datE_WARRANTY_END: moment.Moment | undefined;
    descriptions: string | undefined;
    produceR_ID: string | undefined;
    yeaR_PRODUCTION: number | undefined;
    serial: string | undefined;
    makeR_ID: string | undefined;
    checkeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    brancH_NAME: string | undefined;
}

export class ServiceResult implements IServiceResult {
    code!: string | undefined;
    error!: string | undefined;
    value!: any | undefined;

    constructor(data?: IServiceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.error = data["error"];
            if (data["value"]) {
                this.value = {};
                for (let key in data["value"]) {
                    if (data["value"].hasOwnProperty(key))
                        this.value[key] = data["value"][key];
                }
            }
        }
    }

    static fromJS(data: any): ServiceResult {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["error"] = this.error;
        if (this.value) {
            data["value"] = {};
            for (let key in this.value) {
                if (this.value.hasOwnProperty(key))
                    data["value"][key] = this.value[key];
            }
        }
        return data; 
    }
}

export interface IServiceResult {
    code: string | undefined;
    error: string | undefined;
    value: any | undefined;
}

export class DonViTinh_DTO implements IDonViTinh_DTO {
    dvT_ID!: string | undefined;
    dvT_CODE!: string | undefined;
    dvT_NAME!: string | undefined;
    dvT_DESC!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IDonViTinh_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dvT_ID = data["dvT_ID"];
            this.dvT_CODE = data["dvT_CODE"];
            this.dvT_NAME = data["dvT_NAME"];
            this.dvT_DESC = data["dvT_DESC"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DonViTinh_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new DonViTinh_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dvT_ID"] = this.dvT_ID;
        data["dvT_CODE"] = this.dvT_CODE;
        data["dvT_NAME"] = this.dvT_NAME;
        data["dvT_DESC"] = this.dvT_DESC;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDonViTinh_DTO {
    dvT_ID: string | undefined;
    dvT_CODE: string | undefined;
    dvT_NAME: string | undefined;
    dvT_DESC: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class DVTCreate_DTO implements IDVTCreate_DTO {
    dvT_CODE!: string | undefined;
    dvT_NAME!: string | undefined;
    dvT_DESC!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IDVTCreate_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dvT_CODE = data["dvT_CODE"];
            this.dvT_NAME = data["dvT_NAME"];
            this.dvT_DESC = data["dvT_DESC"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DVTCreate_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new DVTCreate_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dvT_CODE"] = this.dvT_CODE;
        data["dvT_NAME"] = this.dvT_NAME;
        data["dvT_DESC"] = this.dvT_DESC;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDVTCreate_DTO {
    dvT_CODE: string | undefined;
    dvT_NAME: string | undefined;
    dvT_DESC: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class DVTUpdate_DTO implements IDVTUpdate_DTO {
    dvT_ID!: string | undefined;
    dvT_CODE!: string | undefined;
    dvT_NAME!: string | undefined;
    dvT_DESC!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IDVTUpdate_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dvT_ID = data["dvT_ID"];
            this.dvT_CODE = data["dvT_CODE"];
            this.dvT_NAME = data["dvT_NAME"];
            this.dvT_DESC = data["dvT_DESC"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DVTUpdate_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new DVTUpdate_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dvT_ID"] = this.dvT_ID;
        data["dvT_CODE"] = this.dvT_CODE;
        data["dvT_NAME"] = this.dvT_NAME;
        data["dvT_DESC"] = this.dvT_DESC;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDVTUpdate_DTO {
    dvT_ID: string | undefined;
    dvT_CODE: string | undefined;
    dvT_NAME: string | undefined;
    dvT_DESC: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class DUT_DTO implements IDUT_DTO {
    duT_ID!: string | undefined;
    duT_CODE!: string | undefined;
    duT_NAME!: string | undefined;
    duT_DESC!: string | undefined;
    duT_LEVEL!: number | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IDUT_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.duT_ID = data["duT_ID"];
            this.duT_CODE = data["duT_CODE"];
            this.duT_NAME = data["duT_NAME"];
            this.duT_DESC = data["duT_DESC"];
            this.duT_LEVEL = data["duT_LEVEL"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DUT_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new DUT_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["duT_ID"] = this.duT_ID;
        data["duT_CODE"] = this.duT_CODE;
        data["duT_NAME"] = this.duT_NAME;
        data["duT_DESC"] = this.duT_DESC;
        data["duT_LEVEL"] = this.duT_LEVEL;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDUT_DTO {
    duT_ID: string | undefined;
    duT_CODE: string | undefined;
    duT_NAME: string | undefined;
    duT_DESC: string | undefined;
    duT_LEVEL: number | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PageResult implements IPageResult {
    code!: string | undefined;
    error!: string | undefined;
    value!: any | undefined;
    totaL_RECORD!: number | undefined;

    constructor(data?: IPageResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.error = data["error"];
            if (data["value"]) {
                this.value = {};
                for (let key in data["value"]) {
                    if (data["value"].hasOwnProperty(key))
                        this.value[key] = data["value"][key];
                }
            }
            this.totaL_RECORD = data["totaL_RECORD"];
        }
    }

    static fromJS(data: any): PageResult {
        data = typeof data === 'object' ? data : {};
        let result = new PageResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["error"] = this.error;
        if (this.value) {
            data["value"] = {};
            for (let key in this.value) {
                if (this.value.hasOwnProperty(key))
                    data["value"][key] = this.value[key];
            }
        }
        data["totaL_RECORD"] = this.totaL_RECORD;
        return data; 
    }
}

export interface IPageResult {
    code: string | undefined;
    error: string | undefined;
    value: any | undefined;
    totaL_RECORD: number | undefined;
}

export class DVT_DTO implements IDVT_DTO {
    dvT_ID!: string | undefined;
    dvT_CODE!: string | undefined;
    dvT_NAME!: string | undefined;
    dvT_DESC!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_CREATE!: string | undefined;

    constructor(data?: IDVT_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dvT_ID = data["dvT_ID"];
            this.dvT_CODE = data["dvT_CODE"];
            this.dvT_NAME = data["dvT_NAME"];
            this.dvT_DESC = data["dvT_DESC"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CREATE = data["brancH_CREATE"];
        }
    }

    static fromJS(data: any): DVT_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new DVT_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dvT_ID"] = this.dvT_ID;
        data["dvT_CODE"] = this.dvT_CODE;
        data["dvT_NAME"] = this.dvT_NAME;
        data["dvT_DESC"] = this.dvT_DESC;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CREATE"] = this.brancH_CREATE;
        return data; 
    }
}

export interface IDVT_DTO {
    dvT_ID: string | undefined;
    dvT_CODE: string | undefined;
    dvT_NAME: string | undefined;
    dvT_DESC: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CREATE: string | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto | undefined;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator | undefined;
    itemSource!: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class EnumeratedTypeCreateRequest implements IEnumeratedTypeCreateRequest {
    type!: string | undefined;
    value!: string | undefined;
    label!: string | undefined;

    constructor(data?: IEnumeratedTypeCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.value = data["value"];
            this.label = data["label"];
        }
    }

    static fromJS(data: any): EnumeratedTypeCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EnumeratedTypeCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        data["label"] = this.label;
        return data; 
    }
}

export interface IEnumeratedTypeCreateRequest {
    type: string | undefined;
    value: string | undefined;
    label: string | undefined;
}

export class EnumeratedTypeTableDTO implements IEnumeratedTypeTableDTO {
    id!: number | undefined;
    code!: string | undefined;
    type!: string | undefined;
    value!: string | undefined;
    label!: string | undefined;

    constructor(data?: IEnumeratedTypeTableDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.type = data["type"];
            this.value = data["value"];
            this.label = data["label"];
        }
    }

    static fromJS(data: any): EnumeratedTypeTableDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EnumeratedTypeTableDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["type"] = this.type;
        data["value"] = this.value;
        data["label"] = this.label;
        return data; 
    }
}

export interface IEnumeratedTypeTableDTO {
    id: number | undefined;
    code: string | undefined;
    type: string | undefined;
    value: string | undefined;
    label: string | undefined;
}

export class CM_EQUIP_DTO implements ICM_EQUIP_DTO {
    wO_ID!: string | undefined;
    wO_CODE!: string | undefined;
    devicE_NAME!: string | undefined;
    descriptions!: string | undefined;
    prioritY_ORDER!: string | undefined;
    recorD_STATUS!: string | undefined;
    kinD_FIX!: string | undefined;
    fixer!: string | undefined;
    datE_IN!: moment.Moment | undefined;
    descriptionS_ERROR!: string | undefined;
    datE_OUT!: moment.Moment | undefined;
    makeR_ID!: string | undefined;
    checkeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;

    constructor(data?: ICM_EQUIP_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wO_ID = data["wO_ID"];
            this.wO_CODE = data["wO_CODE"];
            this.devicE_NAME = data["devicE_NAME"];
            this.descriptions = data["descriptions"];
            this.prioritY_ORDER = data["prioritY_ORDER"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.kinD_FIX = data["kinD_FIX"];
            this.fixer = data["fixer"];
            this.datE_IN = data["datE_IN"] ? moment(data["datE_IN"].toString()) : <any>undefined;
            this.descriptionS_ERROR = data["descriptionS_ERROR"];
            this.datE_OUT = data["datE_OUT"] ? moment(data["datE_OUT"].toString()) : <any>undefined;
            this.makeR_ID = data["makeR_ID"];
            this.checkeR_ID = data["checkeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
        }
    }

    static fromJS(data: any): CM_EQUIP_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new CM_EQUIP_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wO_ID"] = this.wO_ID;
        data["wO_CODE"] = this.wO_CODE;
        data["devicE_NAME"] = this.devicE_NAME;
        data["descriptions"] = this.descriptions;
        data["prioritY_ORDER"] = this.prioritY_ORDER;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["kinD_FIX"] = this.kinD_FIX;
        data["fixer"] = this.fixer;
        data["datE_IN"] = this.datE_IN ? this.datE_IN.toISOString() : <any>undefined;
        data["descriptionS_ERROR"] = this.descriptionS_ERROR;
        data["datE_OUT"] = this.datE_OUT ? this.datE_OUT.toISOString() : <any>undefined;
        data["makeR_ID"] = this.makeR_ID;
        data["checkeR_ID"] = this.checkeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        return data; 
    }
}

export interface ICM_EQUIP_DTO {
    wO_ID: string | undefined;
    wO_CODE: string | undefined;
    devicE_NAME: string | undefined;
    descriptions: string | undefined;
    prioritY_ORDER: string | undefined;
    recorD_STATUS: string | undefined;
    kinD_FIX: string | undefined;
    fixer: string | undefined;
    datE_IN: moment.Moment | undefined;
    descriptionS_ERROR: string | undefined;
    datE_OUT: moment.Moment | undefined;
    makeR_ID: string | undefined;
    checkeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
}

export class FloorCreate_DTO implements IFloorCreate_DTO {
    floor_CODE!: string | undefined;
    floor_NAME!: string | undefined;
    floorType_ID!: string | undefined;
    building_ID!: string | undefined;
    floor_STATUS!: string | undefined;
    floor_NOTE!: string | undefined;

    constructor(data?: IFloorCreate_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floor_CODE = data["floor_CODE"];
            this.floor_NAME = data["floor_NAME"];
            this.floorType_ID = data["floorType_ID"];
            this.building_ID = data["building_ID"];
            this.floor_STATUS = data["floor_STATUS"];
            this.floor_NOTE = data["floor_NOTE"];
        }
    }

    static fromJS(data: any): FloorCreate_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new FloorCreate_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floor_CODE"] = this.floor_CODE;
        data["floor_NAME"] = this.floor_NAME;
        data["floorType_ID"] = this.floorType_ID;
        data["building_ID"] = this.building_ID;
        data["floor_STATUS"] = this.floor_STATUS;
        data["floor_NOTE"] = this.floor_NOTE;
        return data; 
    }
}

export interface IFloorCreate_DTO {
    floor_CODE: string | undefined;
    floor_NAME: string | undefined;
    floorType_ID: string | undefined;
    building_ID: string | undefined;
    floor_STATUS: string | undefined;
    floor_NOTE: string | undefined;
}

export class Floor_DTO implements IFloor_DTO {
    floor_ID!: string | undefined;
    floor_CODE!: string | undefined;
    floor_NAME!: string | undefined;
    floorType_ID!: string | undefined;
    floorType_NAME!: string | undefined;
    building_ID!: string | undefined;
    floor_STATUS!: string | undefined;
    floor_NOTE!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    deletE_REQUESTED!: string | undefined;

    constructor(data?: IFloor_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floor_ID = data["floor_ID"];
            this.floor_CODE = data["floor_CODE"];
            this.floor_NAME = data["floor_NAME"];
            this.floorType_ID = data["floorType_ID"];
            this.floorType_NAME = data["floorType_NAME"];
            this.building_ID = data["building_ID"];
            this.floor_STATUS = data["floor_STATUS"];
            this.floor_NOTE = data["floor_NOTE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.deletE_REQUESTED = data["deletE_REQUESTED"];
        }
    }

    static fromJS(data: any): Floor_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new Floor_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floor_ID"] = this.floor_ID;
        data["floor_CODE"] = this.floor_CODE;
        data["floor_NAME"] = this.floor_NAME;
        data["floorType_ID"] = this.floorType_ID;
        data["floorType_NAME"] = this.floorType_NAME;
        data["building_ID"] = this.building_ID;
        data["floor_STATUS"] = this.floor_STATUS;
        data["floor_NOTE"] = this.floor_NOTE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["deletE_REQUESTED"] = this.deletE_REQUESTED;
        return data; 
    }
}

export interface IFloor_DTO {
    floor_ID: string | undefined;
    floor_CODE: string | undefined;
    floor_NAME: string | undefined;
    floorType_ID: string | undefined;
    floorType_NAME: string | undefined;
    building_ID: string | undefined;
    floor_STATUS: string | undefined;
    floor_NOTE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    deletE_REQUESTED: string | undefined;
}

export class FloorUpdate_DTO implements IFloorUpdate_DTO {
    floor_ID!: string | undefined;
    floor_CODE!: string | undefined;
    floor_NAME!: string | undefined;
    floorType_ID!: string | undefined;
    building_ID!: string | undefined;
    floor_STATUS!: string | undefined;
    floor_NOTE!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: string | undefined;

    constructor(data?: IFloorUpdate_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floor_ID = data["floor_ID"];
            this.floor_CODE = data["floor_CODE"];
            this.floor_NAME = data["floor_NAME"];
            this.floorType_ID = data["floorType_ID"];
            this.building_ID = data["building_ID"];
            this.floor_STATUS = data["floor_STATUS"];
            this.floor_NOTE = data["floor_NOTE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"];
        }
    }

    static fromJS(data: any): FloorUpdate_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new FloorUpdate_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floor_ID"] = this.floor_ID;
        data["floor_CODE"] = this.floor_CODE;
        data["floor_NAME"] = this.floor_NAME;
        data["floorType_ID"] = this.floorType_ID;
        data["building_ID"] = this.building_ID;
        data["floor_STATUS"] = this.floor_STATUS;
        data["floor_NOTE"] = this.floor_NOTE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT;
        return data; 
    }
}

export interface IFloorUpdate_DTO {
    floor_ID: string | undefined;
    floor_CODE: string | undefined;
    floor_NAME: string | undefined;
    floorType_ID: string | undefined;
    building_ID: string | undefined;
    floor_STATUS: string | undefined;
    floor_NOTE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: string | undefined;
}

export class FloorApproveRequest implements IFloorApproveRequest {
    flooR_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;

    constructor(data?: IFloorApproveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flooR_ID = data["flooR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
        }
    }

    static fromJS(data: any): FloorApproveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FloorApproveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flooR_ID"] = this.flooR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        return data; 
    }
}

export interface IFloorApproveRequest {
    flooR_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
}

export class FloorCreateRequest implements IFloorCreateRequest {
    flooR_CODE!: string | undefined;
    flooR_NAME!: string | undefined;
    floortypE_ID!: string | undefined;
    buildinG_ID!: string | undefined;
    flooR_STATUS!: string | undefined;
    description!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IFloorCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flooR_CODE = data["flooR_CODE"];
            this.flooR_NAME = data["flooR_NAME"];
            this.floortypE_ID = data["floortypE_ID"];
            this.buildinG_ID = data["buildinG_ID"];
            this.flooR_STATUS = data["flooR_STATUS"];
            this.description = data["description"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FloorCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FloorCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flooR_CODE"] = this.flooR_CODE;
        data["flooR_NAME"] = this.flooR_NAME;
        data["floortypE_ID"] = this.floortypE_ID;
        data["buildinG_ID"] = this.buildinG_ID;
        data["flooR_STATUS"] = this.flooR_STATUS;
        data["description"] = this.description;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IFloorCreateRequest {
    flooR_CODE: string | undefined;
    flooR_NAME: string | undefined;
    floortypE_ID: string | undefined;
    buildinG_ID: string | undefined;
    flooR_STATUS: string | undefined;
    description: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class FloorTableDTO implements IFloorTableDTO {
    flooR_ID!: string | undefined;
    flooR_CODE!: string | undefined;
    flooR_NAME!: string | undefined;
    floortypE_ID!: string | undefined;
    buildinG_ID!: string | undefined;
    flooR_STATUS!: string | undefined;
    description!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IFloorTableDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flooR_ID = data["flooR_ID"];
            this.flooR_CODE = data["flooR_CODE"];
            this.flooR_NAME = data["flooR_NAME"];
            this.floortypE_ID = data["floortypE_ID"];
            this.buildinG_ID = data["buildinG_ID"];
            this.flooR_STATUS = data["flooR_STATUS"];
            this.description = data["description"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FloorTableDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FloorTableDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flooR_ID"] = this.flooR_ID;
        data["flooR_CODE"] = this.flooR_CODE;
        data["flooR_NAME"] = this.flooR_NAME;
        data["floortypE_ID"] = this.floortypE_ID;
        data["buildinG_ID"] = this.buildinG_ID;
        data["flooR_STATUS"] = this.flooR_STATUS;
        data["description"] = this.description;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IFloorTableDTO {
    flooR_ID: string | undefined;
    flooR_CODE: string | undefined;
    flooR_NAME: string | undefined;
    floortypE_ID: string | undefined;
    buildinG_ID: string | undefined;
    flooR_STATUS: string | undefined;
    description: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfFloorPagingSearchDTO implements IPagedResultDtoOfFloorPagingSearchDTO {
    totalCount!: number | undefined;
    items!: FloorPagingSearchDTO[] | undefined;

    constructor(data?: IPagedResultDtoOfFloorPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FloorPagingSearchDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfFloorPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfFloorPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfFloorPagingSearchDTO {
    totalCount: number | undefined;
    items: FloorPagingSearchDTO[] | undefined;
}

export class FloorPagingSearchDTO implements IFloorPagingSearchDTO {
    totalRows!: number | undefined;
    floortypE_NAME!: string | undefined;
    flooR_ID!: string | undefined;
    flooR_CODE!: string | undefined;
    flooR_NAME!: string | undefined;
    floortypE_ID!: string | undefined;
    buildinG_ID!: string | undefined;
    flooR_STATUS!: string | undefined;
    description!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IFloorPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalRows = data["totalRows"];
            this.floortypE_NAME = data["floortypE_NAME"];
            this.flooR_ID = data["flooR_ID"];
            this.flooR_CODE = data["flooR_CODE"];
            this.flooR_NAME = data["flooR_NAME"];
            this.floortypE_ID = data["floortypE_ID"];
            this.buildinG_ID = data["buildinG_ID"];
            this.flooR_STATUS = data["flooR_STATUS"];
            this.description = data["description"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FloorPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FloorPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRows"] = this.totalRows;
        data["floortypE_NAME"] = this.floortypE_NAME;
        data["flooR_ID"] = this.flooR_ID;
        data["flooR_CODE"] = this.flooR_CODE;
        data["flooR_NAME"] = this.flooR_NAME;
        data["floortypE_ID"] = this.floortypE_ID;
        data["buildinG_ID"] = this.buildinG_ID;
        data["flooR_STATUS"] = this.flooR_STATUS;
        data["description"] = this.description;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IFloorPagingSearchDTO {
    totalRows: number | undefined;
    floortypE_NAME: string | undefined;
    flooR_ID: string | undefined;
    flooR_CODE: string | undefined;
    flooR_NAME: string | undefined;
    floortypE_ID: string | undefined;
    buildinG_ID: string | undefined;
    flooR_STATUS: string | undefined;
    description: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class FloorUpdateRequest implements IFloorUpdateRequest {
    flooR_ID!: string | undefined;
    flooR_CODE!: string | undefined;
    flooR_NAME!: string | undefined;
    floortypE_ID!: string | undefined;
    buildinG_ID!: string | undefined;
    flooR_STATUS!: string | undefined;
    description!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IFloorUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flooR_ID = data["flooR_ID"];
            this.flooR_CODE = data["flooR_CODE"];
            this.flooR_NAME = data["flooR_NAME"];
            this.floortypE_ID = data["floortypE_ID"];
            this.buildinG_ID = data["buildinG_ID"];
            this.flooR_STATUS = data["flooR_STATUS"];
            this.description = data["description"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FloorUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FloorUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flooR_ID"] = this.flooR_ID;
        data["flooR_CODE"] = this.flooR_CODE;
        data["flooR_NAME"] = this.flooR_NAME;
        data["floortypE_ID"] = this.floortypE_ID;
        data["buildinG_ID"] = this.buildinG_ID;
        data["flooR_STATUS"] = this.flooR_STATUS;
        data["description"] = this.description;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IFloorUpdateRequest {
    flooR_ID: string | undefined;
    flooR_CODE: string | undefined;
    flooR_NAME: string | undefined;
    floortypE_ID: string | undefined;
    buildinG_ID: string | undefined;
    flooR_STATUS: string | undefined;
    description: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class FloorType_DTO implements IFloorType_DTO {
    floorType_ID!: string | undefined;
    floorType_CODE!: string | undefined;
    floorType_NAME!: string | undefined;
    floorType_DESC!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    deletE_REQUESTED!: string | undefined;

    constructor(data?: IFloorType_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorType_ID = data["floorType_ID"];
            this.floorType_CODE = data["floorType_CODE"];
            this.floorType_NAME = data["floorType_NAME"];
            this.floorType_DESC = data["floorType_DESC"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.deletE_REQUESTED = data["deletE_REQUESTED"];
        }
    }

    static fromJS(data: any): FloorType_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new FloorType_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorType_ID"] = this.floorType_ID;
        data["floorType_CODE"] = this.floorType_CODE;
        data["floorType_NAME"] = this.floorType_NAME;
        data["floorType_DESC"] = this.floorType_DESC;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["deletE_REQUESTED"] = this.deletE_REQUESTED;
        return data; 
    }
}

export interface IFloorType_DTO {
    floorType_ID: string | undefined;
    floorType_CODE: string | undefined;
    floorType_NAME: string | undefined;
    floorType_DESC: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    deletE_REQUESTED: string | undefined;
}

export class FloorTypeCreate_DTO implements IFloorTypeCreate_DTO {
    floorType_CODE!: string | undefined;
    floorType_NAME!: string | undefined;
    floorType_DESC!: string | undefined;

    constructor(data?: IFloorTypeCreate_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorType_CODE = data["floorType_CODE"];
            this.floorType_NAME = data["floorType_NAME"];
            this.floorType_DESC = data["floorType_DESC"];
        }
    }

    static fromJS(data: any): FloorTypeCreate_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new FloorTypeCreate_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorType_CODE"] = this.floorType_CODE;
        data["floorType_NAME"] = this.floorType_NAME;
        data["floorType_DESC"] = this.floorType_DESC;
        return data; 
    }
}

export interface IFloorTypeCreate_DTO {
    floorType_CODE: string | undefined;
    floorType_NAME: string | undefined;
    floorType_DESC: string | undefined;
}

export class FloorTypeUpdate_DTO implements IFloorTypeUpdate_DTO {
    floorType_ID!: string | undefined;
    floorType_CODE!: string | undefined;
    floorType_NAME!: string | undefined;
    floorType_DESC!: string | undefined;

    constructor(data?: IFloorTypeUpdate_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorType_ID = data["floorType_ID"];
            this.floorType_CODE = data["floorType_CODE"];
            this.floorType_NAME = data["floorType_NAME"];
            this.floorType_DESC = data["floorType_DESC"];
        }
    }

    static fromJS(data: any): FloorTypeUpdate_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new FloorTypeUpdate_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorType_ID"] = this.floorType_ID;
        data["floorType_CODE"] = this.floorType_CODE;
        data["floorType_NAME"] = this.floorType_NAME;
        data["floorType_DESC"] = this.floorType_DESC;
        return data; 
    }
}

export interface IFloorTypeUpdate_DTO {
    floorType_ID: string | undefined;
    floorType_CODE: string | undefined;
    floorType_NAME: string | undefined;
    floorType_DESC: string | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount!: number | undefined;
    newSubscriptionAmount!: number | undefined;
    dashboardPlaceholder1!: number | undefined;
    dashboardPlaceholder2!: number | undefined;
    incomeStatistics!: IncomeStastistic[] | undefined;
    editionStatistics!: TenantEdition[] | undefined;
    expiringTenants!: ExpiringTenant[] | undefined;
    recentTenants!: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount!: number | undefined;
    maxRecentTenantsShownCount!: number | undefined;
    subscriptionEndAlertDayCount!: number | undefined;
    recentTenantsDayCount!: number | undefined;
    subscriptionEndDateStart!: moment.Moment | undefined;
    subscriptionEndDateEnd!: moment.Moment | undefined;
    tenantCreationStartDate!: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [];
                for (let item of data["expiringTenants"])
                    this.expiringTenants.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [];
                for (let item of data["recentTenants"])
                    this.recentTenants.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number | undefined;
    name!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    smsVerificationEnabled!: boolean | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredTenantActiveByDefault!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings!: boolean | undefined;
    passwordComplexity!: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity!: PasswordComplexitySetting | undefined;
    userLockOut!: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean | undefined;
    requireLowercase!: boolean | undefined;
    requireNonAlphanumeric!: boolean | undefined;
    requireUppercase!: boolean | undefined;
    requiredLength!: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout!: number | undefined;
    defaultAccountLockoutSeconds!: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean | undefined;
    isEnabled!: boolean | undefined;
    isEmailProviderEnabled!: boolean | undefined;
    isSmsProviderEnabled!: boolean | undefined;
    isRememberBrowserEnabled!: boolean | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto | undefined;
    billInfo!: HostBillingSettingsEditDto | undefined;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [];
                for (let item of data["languages"])
                    this.languages.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean | undefined;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: moment.Moment | undefined;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [];
                for (let item of data["tenantAddress"])
                    this.tenantAddress.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [];
                for (let item of data["hostAddress"])
                    this.hostAddress.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;
}

export class KIEMKE_DTO implements IKIEMKE_DTO {
    kK_ID!: string | undefined;
    kK_CODE!: string | undefined;
    kK_NGAYTAO!: string | undefined;
    kK_NGUOITAO!: string | undefined;
    kK_MADONVI!: string | undefined;
    kK_TENDONVI!: string | undefined;
    kK_NGAYCHOT!: string | undefined;
    kK_TONGTB_DUOCKIEMKE!: number | undefined;
    kK_TONGTB_DUSOVOISAOKE!: number | undefined;
    kK_TONGTB_THIEUSOVOISAOKE!: number | undefined;
    kK_TONGTB_THUASOVOISAOKE!: number | undefined;
    kK_TRANGTHAI!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: string | undefined;

    constructor(data?: IKIEMKE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kK_ID = data["kK_ID"];
            this.kK_CODE = data["kK_CODE"];
            this.kK_NGAYTAO = data["kK_NGAYTAO"];
            this.kK_NGUOITAO = data["kK_NGUOITAO"];
            this.kK_MADONVI = data["kK_MADONVI"];
            this.kK_TENDONVI = data["kK_TENDONVI"];
            this.kK_NGAYCHOT = data["kK_NGAYCHOT"];
            this.kK_TONGTB_DUOCKIEMKE = data["kK_TONGTB_DUOCKIEMKE"];
            this.kK_TONGTB_DUSOVOISAOKE = data["kK_TONGTB_DUSOVOISAOKE"];
            this.kK_TONGTB_THIEUSOVOISAOKE = data["kK_TONGTB_THIEUSOVOISAOKE"];
            this.kK_TONGTB_THUASOVOISAOKE = data["kK_TONGTB_THUASOVOISAOKE"];
            this.kK_TRANGTHAI = data["kK_TRANGTHAI"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"];
        }
    }

    static fromJS(data: any): KIEMKE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new KIEMKE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kK_ID"] = this.kK_ID;
        data["kK_CODE"] = this.kK_CODE;
        data["kK_NGAYTAO"] = this.kK_NGAYTAO;
        data["kK_NGUOITAO"] = this.kK_NGUOITAO;
        data["kK_MADONVI"] = this.kK_MADONVI;
        data["kK_TENDONVI"] = this.kK_TENDONVI;
        data["kK_NGAYCHOT"] = this.kK_NGAYCHOT;
        data["kK_TONGTB_DUOCKIEMKE"] = this.kK_TONGTB_DUOCKIEMKE;
        data["kK_TONGTB_DUSOVOISAOKE"] = this.kK_TONGTB_DUSOVOISAOKE;
        data["kK_TONGTB_THIEUSOVOISAOKE"] = this.kK_TONGTB_THIEUSOVOISAOKE;
        data["kK_TONGTB_THUASOVOISAOKE"] = this.kK_TONGTB_THUASOVOISAOKE;
        data["kK_TRANGTHAI"] = this.kK_TRANGTHAI;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT;
        return data; 
    }
}

export interface IKIEMKE_DTO {
    kK_ID: string | undefined;
    kK_CODE: string | undefined;
    kK_NGAYTAO: string | undefined;
    kK_NGUOITAO: string | undefined;
    kK_MADONVI: string | undefined;
    kK_TENDONVI: string | undefined;
    kK_NGAYCHOT: string | undefined;
    kK_TONGTB_DUOCKIEMKE: number | undefined;
    kK_TONGTB_DUSOVOISAOKE: number | undefined;
    kK_TONGTB_THIEUSOVOISAOKE: number | undefined;
    kK_TONGTB_THUASOVOISAOKE: number | undefined;
    kK_TRANGTHAI: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: string | undefined;
}

export class KIEM_KE_DTO implements IKIEM_KE_DTO {
    kK_ID!: string | undefined;
    kK_CODE!: string | undefined;
    kK_NGAYTAO!: moment.Moment | undefined;
    kK_NGUOITAO!: string | undefined;
    kK_MADONVI!: string | undefined;
    kK_TENDONVI!: string | undefined;
    kK_NGAYCHOT!: moment.Moment | undefined;
    kK_TONGTB_DUOCKIEMKE!: number | undefined;
    kK_TONGTB_DUSOVOISAOKE!: number | undefined;
    kK_TONGTB_THIEUSOVOISAOKE!: number | undefined;
    kK_TONGTB_THUASOVOISAOKE!: number | undefined;
    kK_TRANGTHAI!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IKIEM_KE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kK_ID = data["kK_ID"];
            this.kK_CODE = data["kK_CODE"];
            this.kK_NGAYTAO = data["kK_NGAYTAO"] ? moment(data["kK_NGAYTAO"].toString()) : <any>undefined;
            this.kK_NGUOITAO = data["kK_NGUOITAO"];
            this.kK_MADONVI = data["kK_MADONVI"];
            this.kK_TENDONVI = data["kK_TENDONVI"];
            this.kK_NGAYCHOT = data["kK_NGAYCHOT"] ? moment(data["kK_NGAYCHOT"].toString()) : <any>undefined;
            this.kK_TONGTB_DUOCKIEMKE = data["kK_TONGTB_DUOCKIEMKE"];
            this.kK_TONGTB_DUSOVOISAOKE = data["kK_TONGTB_DUSOVOISAOKE"];
            this.kK_TONGTB_THIEUSOVOISAOKE = data["kK_TONGTB_THIEUSOVOISAOKE"];
            this.kK_TONGTB_THUASOVOISAOKE = data["kK_TONGTB_THUASOVOISAOKE"];
            this.kK_TRANGTHAI = data["kK_TRANGTHAI"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): KIEM_KE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new KIEM_KE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kK_ID"] = this.kK_ID;
        data["kK_CODE"] = this.kK_CODE;
        data["kK_NGAYTAO"] = this.kK_NGAYTAO ? this.kK_NGAYTAO.toISOString() : <any>undefined;
        data["kK_NGUOITAO"] = this.kK_NGUOITAO;
        data["kK_MADONVI"] = this.kK_MADONVI;
        data["kK_TENDONVI"] = this.kK_TENDONVI;
        data["kK_NGAYCHOT"] = this.kK_NGAYCHOT ? this.kK_NGAYCHOT.toISOString() : <any>undefined;
        data["kK_TONGTB_DUOCKIEMKE"] = this.kK_TONGTB_DUOCKIEMKE;
        data["kK_TONGTB_DUSOVOISAOKE"] = this.kK_TONGTB_DUSOVOISAOKE;
        data["kK_TONGTB_THIEUSOVOISAOKE"] = this.kK_TONGTB_THIEUSOVOISAOKE;
        data["kK_TONGTB_THUASOVOISAOKE"] = this.kK_TONGTB_THUASOVOISAOKE;
        data["kK_TRANGTHAI"] = this.kK_TRANGTHAI;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IKIEM_KE_DTO {
    kK_ID: string | undefined;
    kK_CODE: string | undefined;
    kK_NGAYTAO: moment.Moment | undefined;
    kK_NGUOITAO: string | undefined;
    kK_MADONVI: string | undefined;
    kK_TENDONVI: string | undefined;
    kK_NGAYCHOT: moment.Moment | undefined;
    kK_TONGTB_DUOCKIEMKE: number | undefined;
    kK_TONGTB_DUSOVOISAOKE: number | undefined;
    kK_TONGTB_THIEUSOVOISAOKE: number | undefined;
    kK_TONGTB_THUASOVOISAOKE: number | undefined;
    kK_TRANGTHAI: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class CUSTOM_DTO implements ICUSTOM_DTO {
    donvI_ID!: string | undefined;
    bkK_CODE!: string | undefined;
    ngaY_TAO!: moment.Moment | undefined;
    listtb!: string | undefined;

    constructor(data?: ICUSTOM_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.donvI_ID = data["donvI_ID"];
            this.bkK_CODE = data["bkK_CODE"];
            this.ngaY_TAO = data["ngaY_TAO"] ? moment(data["ngaY_TAO"].toString()) : <any>undefined;
            this.listtb = data["listtb"];
        }
    }

    static fromJS(data: any): CUSTOM_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new CUSTOM_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["donvI_ID"] = this.donvI_ID;
        data["bkK_CODE"] = this.bkK_CODE;
        data["ngaY_TAO"] = this.ngaY_TAO ? this.ngaY_TAO.toISOString() : <any>undefined;
        data["listtb"] = this.listtb;
        return data; 
    }
}

export interface ICUSTOM_DTO {
    donvI_ID: string | undefined;
    bkK_CODE: string | undefined;
    ngaY_TAO: moment.Moment | undefined;
    listtb: string | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto | undefined;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [];
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [];
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number | undefined;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class LOAI_XE_DTO implements ILOAI_XE_DTO {
    lX_ID!: string | undefined;
    lX_TEN!: string | undefined;
    lX_MO_TA!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    lX_CODE!: string | undefined;
    lX_HANGXE!: string | undefined;
    lX_NAMSX!: number | undefined;
    lX_LOAINGUYENLIEU!: string | undefined;
    lX_DINHMUCNL!: number | undefined;

    constructor(data?: ILOAI_XE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lX_ID = data["lX_ID"];
            this.lX_TEN = data["lX_TEN"];
            this.lX_MO_TA = data["lX_MO_TA"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.lX_CODE = data["lX_CODE"];
            this.lX_HANGXE = data["lX_HANGXE"];
            this.lX_NAMSX = data["lX_NAMSX"];
            this.lX_LOAINGUYENLIEU = data["lX_LOAINGUYENLIEU"];
            this.lX_DINHMUCNL = data["lX_DINHMUCNL"];
        }
    }

    static fromJS(data: any): LOAI_XE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new LOAI_XE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lX_ID"] = this.lX_ID;
        data["lX_TEN"] = this.lX_TEN;
        data["lX_MO_TA"] = this.lX_MO_TA;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["lX_CODE"] = this.lX_CODE;
        data["lX_HANGXE"] = this.lX_HANGXE;
        data["lX_NAMSX"] = this.lX_NAMSX;
        data["lX_LOAINGUYENLIEU"] = this.lX_LOAINGUYENLIEU;
        data["lX_DINHMUCNL"] = this.lX_DINHMUCNL;
        return data; 
    }
}

export interface ILOAI_XE_DTO {
    lX_ID: string | undefined;
    lX_TEN: string | undefined;
    lX_MO_TA: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    lX_CODE: string | undefined;
    lX_HANGXE: string | undefined;
    lX_NAMSX: number | undefined;
    lX_LOAINGUYENLIEU: string | undefined;
    lX_DINHMUCNL: number | undefined;
}

export class ListResultDtoOfMenuClientDto implements IListResultDtoOfMenuClientDto {
    items!: MenuClientDto[] | undefined;

    constructor(data?: IListResultDtoOfMenuClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MenuClientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfMenuClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfMenuClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfMenuClientDto {
    items: MenuClientDto[] | undefined;
}

export class MenuClientDto implements IMenuClientDto {
    name!: string | undefined;
    alias!: string | undefined;
    description!: string | undefined;
    parentId!: number | undefined;
    displayOrder!: number | undefined;
    homeOrder!: number | undefined;
    image!: string | undefined;
    homeFlag!: boolean | undefined;
    metaKeyword!: string | undefined;
    metaDescription!: string | undefined;
    status!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IMenuClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.alias = data["alias"];
            this.description = data["description"];
            this.parentId = data["parentId"];
            this.displayOrder = data["displayOrder"];
            this.homeOrder = data["homeOrder"];
            this.image = data["image"];
            this.homeFlag = data["homeFlag"];
            this.metaKeyword = data["metaKeyword"];
            this.metaDescription = data["metaDescription"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MenuClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["alias"] = this.alias;
        data["description"] = this.description;
        data["parentId"] = this.parentId;
        data["displayOrder"] = this.displayOrder;
        data["homeOrder"] = this.homeOrder;
        data["image"] = this.image;
        data["homeFlag"] = this.homeFlag;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMenuClientDto {
    name: string | undefined;
    alias: string | undefined;
    description: string | undefined;
    parentId: number | undefined;
    displayOrder: number | undefined;
    homeOrder: number | undefined;
    image: string | undefined;
    homeFlag: boolean | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfMenuClientListDto implements IPagedResultDtoOfMenuClientListDto {
    totalCount!: number | undefined;
    items!: MenuClientListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMenuClientListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MenuClientListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMenuClientListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMenuClientListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMenuClientListDto {
    totalCount: number | undefined;
    items: MenuClientListDto[] | undefined;
}

export class MenuClientListDto implements IMenuClientListDto {
    name!: string | undefined;
    alias!: string | undefined;
    description!: string | undefined;
    parentId!: number | undefined;
    displayOrder!: number | undefined;
    homeOrder!: number | undefined;
    image!: string | undefined;
    homeFlag!: boolean | undefined;
    status!: boolean | undefined;
    createdDate!: moment.Moment | undefined;
    createdBy!: string | undefined;
    updatedDate!: moment.Moment | undefined;
    updatedBy!: string | undefined;
    id!: number | undefined;

    constructor(data?: IMenuClientListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.alias = data["alias"];
            this.description = data["description"];
            this.parentId = data["parentId"];
            this.displayOrder = data["displayOrder"];
            this.homeOrder = data["homeOrder"];
            this.image = data["image"];
            this.homeFlag = data["homeFlag"];
            this.status = data["status"];
            this.createdDate = data["createdDate"] ? moment(data["createdDate"].toString()) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.updatedDate = data["updatedDate"] ? moment(data["updatedDate"].toString()) : <any>undefined;
            this.updatedBy = data["updatedBy"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MenuClientListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuClientListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["alias"] = this.alias;
        data["description"] = this.description;
        data["parentId"] = this.parentId;
        data["displayOrder"] = this.displayOrder;
        data["homeOrder"] = this.homeOrder;
        data["image"] = this.image;
        data["homeFlag"] = this.homeFlag;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMenuClientListDto {
    name: string | undefined;
    alias: string | undefined;
    description: string | undefined;
    parentId: number | undefined;
    displayOrder: number | undefined;
    homeOrder: number | undefined;
    image: string | undefined;
    homeFlag: boolean | undefined;
    status: boolean | undefined;
    createdDate: moment.Moment | undefined;
    createdBy: string | undefined;
    updatedDate: moment.Moment | undefined;
    updatedBy: string | undefined;
    id: number | undefined;
}

export class GetMenuClientOutput implements IGetMenuClientOutput {
    menuClient!: MenuClientDto | undefined;
    menuClients!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetMenuClientOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuClient = data["menuClient"] ? MenuClientDto.fromJS(data["menuClient"]) : <any>undefined;
            if (data["menuClients"] && data["menuClients"].constructor === Array) {
                this.menuClients = [];
                for (let item of data["menuClients"])
                    this.menuClients.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMenuClientOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenuClientOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuClient"] = this.menuClient ? this.menuClient.toJSON() : <any>undefined;
        if (this.menuClients && this.menuClients.constructor === Array) {
            data["menuClients"] = [];
            for (let item of this.menuClients)
                data["menuClients"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMenuClientOutput {
    menuClient: MenuClientDto | undefined;
    menuClients: ComboboxItemDto[] | undefined;
}

export class CreateMenuClientInput implements ICreateMenuClientInput {
    id!: number | undefined;
    name!: string;
    alias!: string | undefined;
    description!: string | undefined;
    parentId!: number | undefined;
    displayOrder!: number | undefined;
    homeOrder!: number | undefined;
    image!: string | undefined;
    homeFlag!: boolean | undefined;
    metaKeyword!: string | undefined;
    metaDescription!: string | undefined;
    status!: boolean | undefined;

    constructor(data?: ICreateMenuClientInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.alias = data["alias"];
            this.description = data["description"];
            this.parentId = data["parentId"];
            this.displayOrder = data["displayOrder"];
            this.homeOrder = data["homeOrder"];
            this.image = data["image"];
            this.homeFlag = data["homeFlag"];
            this.metaKeyword = data["metaKeyword"];
            this.metaDescription = data["metaDescription"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): CreateMenuClientInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMenuClientInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["alias"] = this.alias;
        data["description"] = this.description;
        data["parentId"] = this.parentId;
        data["displayOrder"] = this.displayOrder;
        data["homeOrder"] = this.homeOrder;
        data["image"] = this.image;
        data["homeFlag"] = this.homeFlag;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["status"] = this.status;
        return data; 
    }
}

export interface ICreateMenuClientInput {
    id: number | undefined;
    name: string;
    alias: string | undefined;
    description: string | undefined;
    parentId: number | undefined;
    displayOrder: number | undefined;
    homeOrder: number | undefined;
    image: string | undefined;
    homeFlag: boolean | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean | undefined;
}

export class UpdateMenuClientInput implements IUpdateMenuClientInput {
    id!: number | undefined;
    name!: string;
    alias!: string | undefined;
    description!: string | undefined;
    parentId!: number | undefined;
    displayOrder!: number | undefined;
    homeOrder!: number | undefined;
    image!: string | undefined;
    homeFlag!: boolean | undefined;
    metaKeyword!: string | undefined;
    metaDescription!: string | undefined;
    status!: boolean | undefined;

    constructor(data?: IUpdateMenuClientInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.alias = data["alias"];
            this.description = data["description"];
            this.parentId = data["parentId"];
            this.displayOrder = data["displayOrder"];
            this.homeOrder = data["homeOrder"];
            this.image = data["image"];
            this.homeFlag = data["homeFlag"];
            this.metaKeyword = data["metaKeyword"];
            this.metaDescription = data["metaDescription"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): UpdateMenuClientInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMenuClientInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["alias"] = this.alias;
        data["description"] = this.description;
        data["parentId"] = this.parentId;
        data["displayOrder"] = this.displayOrder;
        data["homeOrder"] = this.homeOrder;
        data["image"] = this.image;
        data["homeFlag"] = this.homeFlag;
        data["metaKeyword"] = this.metaKeyword;
        data["metaDescription"] = this.metaDescription;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateMenuClientInput {
    id: number | undefined;
    name: string;
    alias: string | undefined;
    description: string | undefined;
    parentId: number | undefined;
    displayOrder: number | undefined;
    homeOrder: number | undefined;
    image: string | undefined;
    homeFlag: boolean | undefined;
    metaKeyword: string | undefined;
    metaDescription: string | undefined;
    status: boolean | undefined;
}

export class MODELXE_DTO implements IMODELXE_DTO {
    modeL_ID!: string | undefined;
    modeL_CODE!: string | undefined;
    modeL_NAME!: string | undefined;
    modeL_TYPE!: string | undefined;
    modeL_HSX!: string | undefined;
    modeL_DMNL!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IMODELXE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modeL_ID = data["modeL_ID"];
            this.modeL_CODE = data["modeL_CODE"];
            this.modeL_NAME = data["modeL_NAME"];
            this.modeL_TYPE = data["modeL_TYPE"];
            this.modeL_HSX = data["modeL_HSX"];
            this.modeL_DMNL = data["modeL_DMNL"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MODELXE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new MODELXE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modeL_ID"] = this.modeL_ID;
        data["modeL_CODE"] = this.modeL_CODE;
        data["modeL_NAME"] = this.modeL_NAME;
        data["modeL_TYPE"] = this.modeL_TYPE;
        data["modeL_HSX"] = this.modeL_HSX;
        data["modeL_DMNL"] = this.modeL_DMNL;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMODELXE_DTO {
    modeL_ID: string | undefined;
    modeL_CODE: string | undefined;
    modeL_NAME: string | undefined;
    modeL_TYPE: string | undefined;
    modeL_HSX: string | undefined;
    modeL_DMNL: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class NHACUNGUNG_DTO implements INHACUNGUNG_DTO {
    ncU_ID!: string | undefined;
    ncU_MA_NCU!: string | undefined;
    ncU_TEN!: string | undefined;
    ncU_DIA_CHI!: string | undefined;
    ncU_SDT!: string | undefined;
    ncU_MA_SO_THUE!: string | undefined;
    ncU_FAX!: string | undefined;
    ncU_TEN_NGUOI_LIEN_HE!: string | undefined;
    ncU_EMAIL_NGUOI_LIEN_HE!: string | undefined;
    ncU_SDT_NGUOI_LIEN_HE!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_CREATE!: string | undefined;

    constructor(data?: INHACUNGUNG_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ncU_ID = data["ncU_ID"];
            this.ncU_MA_NCU = data["ncU_MA_NCU"];
            this.ncU_TEN = data["ncU_TEN"];
            this.ncU_DIA_CHI = data["ncU_DIA_CHI"];
            this.ncU_SDT = data["ncU_SDT"];
            this.ncU_MA_SO_THUE = data["ncU_MA_SO_THUE"];
            this.ncU_FAX = data["ncU_FAX"];
            this.ncU_TEN_NGUOI_LIEN_HE = data["ncU_TEN_NGUOI_LIEN_HE"];
            this.ncU_EMAIL_NGUOI_LIEN_HE = data["ncU_EMAIL_NGUOI_LIEN_HE"];
            this.ncU_SDT_NGUOI_LIEN_HE = data["ncU_SDT_NGUOI_LIEN_HE"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CREATE = data["brancH_CREATE"];
        }
    }

    static fromJS(data: any): NHACUNGUNG_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new NHACUNGUNG_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ncU_ID"] = this.ncU_ID;
        data["ncU_MA_NCU"] = this.ncU_MA_NCU;
        data["ncU_TEN"] = this.ncU_TEN;
        data["ncU_DIA_CHI"] = this.ncU_DIA_CHI;
        data["ncU_SDT"] = this.ncU_SDT;
        data["ncU_MA_SO_THUE"] = this.ncU_MA_SO_THUE;
        data["ncU_FAX"] = this.ncU_FAX;
        data["ncU_TEN_NGUOI_LIEN_HE"] = this.ncU_TEN_NGUOI_LIEN_HE;
        data["ncU_EMAIL_NGUOI_LIEN_HE"] = this.ncU_EMAIL_NGUOI_LIEN_HE;
        data["ncU_SDT_NGUOI_LIEN_HE"] = this.ncU_SDT_NGUOI_LIEN_HE;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CREATE"] = this.brancH_CREATE;
        return data; 
    }
}

export interface INHACUNGUNG_DTO {
    ncU_ID: string | undefined;
    ncU_MA_NCU: string | undefined;
    ncU_TEN: string | undefined;
    ncU_DIA_CHI: string | undefined;
    ncU_SDT: string | undefined;
    ncU_MA_SO_THUE: string | undefined;
    ncU_FAX: string | undefined;
    ncU_TEN_NGUOI_LIEN_HE: string | undefined;
    ncU_EMAIL_NGUOI_LIEN_HE: string | undefined;
    ncU_SDT_NGUOI_LIEN_HE: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CREATE: string | undefined;
}

export class PagedResultDtoOfNHACUNGUNG_DTO implements IPagedResultDtoOfNHACUNGUNG_DTO {
    totalCount!: number | undefined;
    items!: NHACUNGUNG_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfNHACUNGUNG_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NHACUNGUNG_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNHACUNGUNG_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNHACUNGUNG_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNHACUNGUNG_DTO {
    totalCount: number | undefined;
    items: NHACUNGUNG_DTO[] | undefined;
}

export class NHA_CUNG_UNG_DTO implements INHA_CUNG_UNG_DTO {
    ncU_ID!: string | undefined;
    ncU_MA_NCU!: string | undefined;
    ncU_TEN!: string | undefined;
    ncU_DIA_CHI!: string | undefined;
    ncU_SDT!: string | undefined;
    ncU_MA_SO_THUE!: string | undefined;
    ncU_FAX!: string | undefined;
    ncU_TEN_NGUOI_LIEN_HE!: string | undefined;
    ncU_EMAIL_NGUOI_LIEN_HE!: string | undefined;
    ncU_SDT_NGUOI_LIEN_HE!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_CREATE!: string | undefined;

    constructor(data?: INHA_CUNG_UNG_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ncU_ID = data["ncU_ID"];
            this.ncU_MA_NCU = data["ncU_MA_NCU"];
            this.ncU_TEN = data["ncU_TEN"];
            this.ncU_DIA_CHI = data["ncU_DIA_CHI"];
            this.ncU_SDT = data["ncU_SDT"];
            this.ncU_MA_SO_THUE = data["ncU_MA_SO_THUE"];
            this.ncU_FAX = data["ncU_FAX"];
            this.ncU_TEN_NGUOI_LIEN_HE = data["ncU_TEN_NGUOI_LIEN_HE"];
            this.ncU_EMAIL_NGUOI_LIEN_HE = data["ncU_EMAIL_NGUOI_LIEN_HE"];
            this.ncU_SDT_NGUOI_LIEN_HE = data["ncU_SDT_NGUOI_LIEN_HE"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CREATE = data["brancH_CREATE"];
        }
    }

    static fromJS(data: any): NHA_CUNG_UNG_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new NHA_CUNG_UNG_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ncU_ID"] = this.ncU_ID;
        data["ncU_MA_NCU"] = this.ncU_MA_NCU;
        data["ncU_TEN"] = this.ncU_TEN;
        data["ncU_DIA_CHI"] = this.ncU_DIA_CHI;
        data["ncU_SDT"] = this.ncU_SDT;
        data["ncU_MA_SO_THUE"] = this.ncU_MA_SO_THUE;
        data["ncU_FAX"] = this.ncU_FAX;
        data["ncU_TEN_NGUOI_LIEN_HE"] = this.ncU_TEN_NGUOI_LIEN_HE;
        data["ncU_EMAIL_NGUOI_LIEN_HE"] = this.ncU_EMAIL_NGUOI_LIEN_HE;
        data["ncU_SDT_NGUOI_LIEN_HE"] = this.ncU_SDT_NGUOI_LIEN_HE;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CREATE"] = this.brancH_CREATE;
        return data; 
    }
}

export interface INHA_CUNG_UNG_DTO {
    ncU_ID: string | undefined;
    ncU_MA_NCU: string | undefined;
    ncU_TEN: string | undefined;
    ncU_DIA_CHI: string | undefined;
    ncU_SDT: string | undefined;
    ncU_MA_SO_THUE: string | undefined;
    ncU_FAX: string | undefined;
    ncU_TEN_NGUOI_LIEN_HE: string | undefined;
    ncU_EMAIL_NGUOI_LIEN_HE: string | undefined;
    ncU_SDT_NGUOI_LIEN_HE: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CREATE: string | undefined;
}

export class NHANVIEN_DTO implements INHANVIEN_DTO {
    nV_ID!: number | undefined;
    nV_MA_NV!: string | undefined;
    nV_TEN!: string | undefined;
    nV_PHONG_BAN!: string | undefined;
    nV_TEN_PHONG_BAN!: string | undefined;
    nV_CHUC_VU!: string | undefined;
    nV_SDT!: string | undefined;
    nV_TRANG_THAI!: number | undefined;
    nV_CMND!: string | undefined;
    nV_NGAY_CAP_CMND!: moment.Moment | undefined;
    nV_NOI_CAP_CMND!: string | undefined;
    nV_MA_SO_THUE!: string | undefined;
    nV_EMAIL!: string | undefined;
    nV_DIA_CHI!: string | undefined;
    nV_MO_TA!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_CREATE!: string | undefined;

    constructor(data?: INHANVIEN_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nV_ID = data["nV_ID"];
            this.nV_MA_NV = data["nV_MA_NV"];
            this.nV_TEN = data["nV_TEN"];
            this.nV_PHONG_BAN = data["nV_PHONG_BAN"];
            this.nV_TEN_PHONG_BAN = data["nV_TEN_PHONG_BAN"];
            this.nV_CHUC_VU = data["nV_CHUC_VU"];
            this.nV_SDT = data["nV_SDT"];
            this.nV_TRANG_THAI = data["nV_TRANG_THAI"];
            this.nV_CMND = data["nV_CMND"];
            this.nV_NGAY_CAP_CMND = data["nV_NGAY_CAP_CMND"] ? moment(data["nV_NGAY_CAP_CMND"].toString()) : <any>undefined;
            this.nV_NOI_CAP_CMND = data["nV_NOI_CAP_CMND"];
            this.nV_MA_SO_THUE = data["nV_MA_SO_THUE"];
            this.nV_EMAIL = data["nV_EMAIL"];
            this.nV_DIA_CHI = data["nV_DIA_CHI"];
            this.nV_MO_TA = data["nV_MO_TA"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CREATE = data["brancH_CREATE"];
        }
    }

    static fromJS(data: any): NHANVIEN_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new NHANVIEN_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nV_ID"] = this.nV_ID;
        data["nV_MA_NV"] = this.nV_MA_NV;
        data["nV_TEN"] = this.nV_TEN;
        data["nV_PHONG_BAN"] = this.nV_PHONG_BAN;
        data["nV_TEN_PHONG_BAN"] = this.nV_TEN_PHONG_BAN;
        data["nV_CHUC_VU"] = this.nV_CHUC_VU;
        data["nV_SDT"] = this.nV_SDT;
        data["nV_TRANG_THAI"] = this.nV_TRANG_THAI;
        data["nV_CMND"] = this.nV_CMND;
        data["nV_NGAY_CAP_CMND"] = this.nV_NGAY_CAP_CMND ? this.nV_NGAY_CAP_CMND.toISOString() : <any>undefined;
        data["nV_NOI_CAP_CMND"] = this.nV_NOI_CAP_CMND;
        data["nV_MA_SO_THUE"] = this.nV_MA_SO_THUE;
        data["nV_EMAIL"] = this.nV_EMAIL;
        data["nV_DIA_CHI"] = this.nV_DIA_CHI;
        data["nV_MO_TA"] = this.nV_MO_TA;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CREATE"] = this.brancH_CREATE;
        return data; 
    }
}

export interface INHANVIEN_DTO {
    nV_ID: number | undefined;
    nV_MA_NV: string | undefined;
    nV_TEN: string | undefined;
    nV_PHONG_BAN: string | undefined;
    nV_TEN_PHONG_BAN: string | undefined;
    nV_CHUC_VU: string | undefined;
    nV_SDT: string | undefined;
    nV_TRANG_THAI: number | undefined;
    nV_CMND: string | undefined;
    nV_NGAY_CAP_CMND: moment.Moment | undefined;
    nV_NOI_CAP_CMND: string | undefined;
    nV_MA_SO_THUE: string | undefined;
    nV_EMAIL: string | undefined;
    nV_DIA_CHI: string | undefined;
    nV_MO_TA: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CREATE: string | undefined;
}

export class NHANVIEN_DEP_NAME_DTO implements INHANVIEN_DEP_NAME_DTO {
    deP_CODE!: string | undefined;
    deP_NAME!: string | undefined;

    constructor(data?: INHANVIEN_DEP_NAME_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deP_CODE = data["deP_CODE"];
            this.deP_NAME = data["deP_NAME"];
        }
    }

    static fromJS(data: any): NHANVIEN_DEP_NAME_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new NHANVIEN_DEP_NAME_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deP_CODE"] = this.deP_CODE;
        data["deP_NAME"] = this.deP_NAME;
        return data; 
    }
}

export interface INHANVIEN_DEP_NAME_DTO {
    deP_CODE: string | undefined;
    deP_NAME: string | undefined;
}

export class NHANVIEN_FILTER implements INHANVIEN_FILTER {
    maNV!: string | undefined;
    tenNhanVien!: string | undefined;
    phongBan!: string | undefined;
    trangThai!: number | undefined;
    orderBy!: string | undefined;
    desc!: boolean | undefined;
    skip!: number | undefined;
    take!: number | undefined;

    constructor(data?: INHANVIEN_FILTER) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maNV = data["maNV"];
            this.tenNhanVien = data["tenNhanVien"];
            this.phongBan = data["phongBan"];
            this.trangThai = data["trangThai"];
            this.orderBy = data["orderBy"];
            this.desc = data["desc"];
            this.skip = data["skip"];
            this.take = data["take"];
        }
    }

    static fromJS(data: any): NHANVIEN_FILTER {
        data = typeof data === 'object' ? data : {};
        let result = new NHANVIEN_FILTER();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maNV"] = this.maNV;
        data["tenNhanVien"] = this.tenNhanVien;
        data["phongBan"] = this.phongBan;
        data["trangThai"] = this.trangThai;
        data["orderBy"] = this.orderBy;
        data["desc"] = this.desc;
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface INHANVIEN_FILTER {
    maNV: string | undefined;
    tenNhanVien: string | undefined;
    phongBan: string | undefined;
    trangThai: number | undefined;
    orderBy: string | undefined;
    desc: boolean | undefined;
    skip: number | undefined;
    take: number | undefined;
}

export class PagedResultDtoOfNHANVIEN_DTO implements IPagedResultDtoOfNHANVIEN_DTO {
    totalCount!: number | undefined;
    items!: NHANVIEN_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfNHANVIEN_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NHANVIEN_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNHANVIEN_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNHANVIEN_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNHANVIEN_DTO {
    totalCount: number | undefined;
    items: NHANVIEN_DTO[] | undefined;
}

export class NSX_DTO implements INSX_DTO {
    nsX_ID!: string | undefined;
    nsX_CODE!: string | undefined;
    nsX_NAME!: string | undefined;
    nsX_FROM!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: INSX_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nsX_ID = data["nsX_ID"];
            this.nsX_CODE = data["nsX_CODE"];
            this.nsX_NAME = data["nsX_NAME"];
            this.nsX_FROM = data["nsX_FROM"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NSX_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new NSX_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nsX_ID"] = this.nsX_ID;
        data["nsX_CODE"] = this.nsX_CODE;
        data["nsX_NAME"] = this.nsX_NAME;
        data["nsX_FROM"] = this.nsX_FROM;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface INSX_DTO {
    nsX_ID: string | undefined;
    nsX_CODE: string | undefined;
    nsX_NAME: string | undefined;
    nsX_FROM: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfNSX_DTO implements IPagedResultDtoOfNSX_DTO {
    totalCount!: number | undefined;
    items!: NSX_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfNSX_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NSX_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNSX_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNSX_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNSX_DTO {
    totalCount: number | undefined;
    items: NSX_DTO[] | undefined;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number | undefined;
    totalCount!: number | undefined;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number | undefined;
    state!: UserNotificationState | undefined;
    notification!: TenantNotification | undefined;
    id!: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData | undefined;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: TenantNotificationSeverity | undefined;
    creationTime!: moment.Moment | undefined;
    id!: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            if (data["entityId"]) {
                this.entityId = {};
                for (let key in data["entityId"]) {
                    if (data["entityId"].hasOwnProperty(key))
                        this.entityId[key] = data["entityId"][key];
                }
            }
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        if (this.entityId) {
            data["entityId"] = {};
            for (let key in this.entityId) {
                if (this.entityId.hasOwnProperty(key))
                    data["entityId"][key] = this.entityId[key];
            }
        }
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: TenantNotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    type!: string | undefined;
    properties!: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class CM_NSX_DTO implements ICM_NSX_DTO {
    nsX_ID!: string | undefined;
    nsX_CODE!: string | undefined;
    nsX_NAME!: string | undefined;
    nsX_FROM!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_CREATE!: string | undefined;

    constructor(data?: ICM_NSX_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nsX_ID = data["nsX_ID"];
            this.nsX_CODE = data["nsX_CODE"];
            this.nsX_NAME = data["nsX_NAME"];
            this.nsX_FROM = data["nsX_FROM"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CREATE = data["brancH_CREATE"];
        }
    }

    static fromJS(data: any): CM_NSX_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new CM_NSX_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nsX_ID"] = this.nsX_ID;
        data["nsX_CODE"] = this.nsX_CODE;
        data["nsX_NAME"] = this.nsX_NAME;
        data["nsX_FROM"] = this.nsX_FROM;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CREATE"] = this.brancH_CREATE;
        return data; 
    }
}

export interface ICM_NSX_DTO {
    nsX_ID: string | undefined;
    nsX_CODE: string | undefined;
    nsX_NAME: string | undefined;
    nsX_FROM: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CREATE: string | undefined;
}

export class PagedResultDtoOfCM_NSX_DTO implements IPagedResultDtoOfCM_NSX_DTO {
    totalCount!: number | undefined;
    items!: CM_NSX_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_NSX_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CM_NSX_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_NSX_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_NSX_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_NSX_DTO {
    totalCount: number | undefined;
    items: CM_NSX_DTO[] | undefined;
}

export class NguoiThueXe_DTO implements INguoiThueXe_DTO {
    ntX_ID!: string | undefined;
    ntX_CODE!: string | undefined;
    ntX_NAME!: string | undefined;
    ntX_ADDRESS!: string | undefined;
    ntX_GENDER!: string | undefined;
    ntX_BIRTHDAY!: moment.Moment | undefined;
    ntX_ID_CARD!: string | undefined;
    ntX_LICENSE!: string | undefined;
    ntX_NOTES!: string | undefined;
    xE_ID!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    createD_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: INguoiThueXe_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ntX_ID = data["ntX_ID"];
            this.ntX_CODE = data["ntX_CODE"];
            this.ntX_NAME = data["ntX_NAME"];
            this.ntX_ADDRESS = data["ntX_ADDRESS"];
            this.ntX_GENDER = data["ntX_GENDER"];
            this.ntX_BIRTHDAY = data["ntX_BIRTHDAY"] ? moment(data["ntX_BIRTHDAY"].toString()) : <any>undefined;
            this.ntX_ID_CARD = data["ntX_ID_CARD"];
            this.ntX_LICENSE = data["ntX_LICENSE"];
            this.ntX_NOTES = data["ntX_NOTES"];
            this.xE_ID = data["xE_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.createD_DT = data["createD_DT"] ? moment(data["createD_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NguoiThueXe_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new NguoiThueXe_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ntX_ID"] = this.ntX_ID;
        data["ntX_CODE"] = this.ntX_CODE;
        data["ntX_NAME"] = this.ntX_NAME;
        data["ntX_ADDRESS"] = this.ntX_ADDRESS;
        data["ntX_GENDER"] = this.ntX_GENDER;
        data["ntX_BIRTHDAY"] = this.ntX_BIRTHDAY ? this.ntX_BIRTHDAY.toISOString() : <any>undefined;
        data["ntX_ID_CARD"] = this.ntX_ID_CARD;
        data["ntX_LICENSE"] = this.ntX_LICENSE;
        data["ntX_NOTES"] = this.ntX_NOTES;
        data["xE_ID"] = this.xE_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["createD_DT"] = this.createD_DT ? this.createD_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface INguoiThueXe_DTO {
    ntX_ID: string | undefined;
    ntX_CODE: string | undefined;
    ntX_NAME: string | undefined;
    ntX_ADDRESS: string | undefined;
    ntX_GENDER: string | undefined;
    ntX_BIRTHDAY: moment.Moment | undefined;
    ntX_ID_CARD: string | undefined;
    ntX_LICENSE: string | undefined;
    ntX_NOTES: string | undefined;
    xE_ID: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createD_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfNguoiThueXe_DTO implements IPagedResultDtoOfNguoiThueXe_DTO {
    totalCount!: number | undefined;
    items!: NguoiThueXe_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfNguoiThueXe_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NguoiThueXe_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNguoiThueXe_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNguoiThueXe_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNguoiThueXe_DTO {
    totalCount: number | undefined;
    items: NguoiThueXe_DTO[] | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number | undefined;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number | undefined;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto | undefined;
    additionalPrice!: number | undefined;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean | undefined;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number | undefined;
    editionPaymentType!: CreatePaymentDtoEditionPaymentType | undefined;
    paymentPeriodType!: CreatePaymentDtoPaymentPeriodType | undefined;
    subscriptionPaymentGatewayType!: CreatePaymentDtoSubscriptionPaymentGatewayType | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: CreatePaymentDtoEditionPaymentType | undefined;
    paymentPeriodType: CreatePaymentDtoPaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: CreatePaymentDtoSubscriptionPaymentGatewayType | undefined;
}

export class ExecutePaymentDto implements IExecutePaymentDto {
    gateway!: ExecutePaymentDtoGateway | undefined;
    editionPaymentType!: ExecutePaymentDtoEditionPaymentType | undefined;
    editionId!: number | undefined;
    paymentPeriodType!: ExecutePaymentDtoPaymentPeriodType | undefined;
    additionalData!: { [key: string] : string; } | undefined;

    constructor(data?: IExecutePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.editionPaymentType = data["editionPaymentType"];
            this.editionId = data["editionId"];
            this.paymentPeriodType = data["paymentPeriodType"];
            if (data["additionalData"]) {
                this.additionalData = {};
                for (let key in data["additionalData"]) {
                    if (data["additionalData"].hasOwnProperty(key))
                        this.additionalData[key] = data["additionalData"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExecutePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExecutePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["editionPaymentType"] = this.editionPaymentType;
        data["editionId"] = this.editionId;
        data["paymentPeriodType"] = this.paymentPeriodType;
        if (this.additionalData) {
            data["additionalData"] = {};
            for (let key in this.additionalData) {
                if (this.additionalData.hasOwnProperty(key))
                    data["additionalData"][key] = this.additionalData[key];
            }
        }
        return data; 
    }
}

export interface IExecutePaymentDto {
    gateway: ExecutePaymentDtoGateway | undefined;
    editionPaymentType: ExecutePaymentDtoEditionPaymentType | undefined;
    editionId: number | undefined;
    paymentPeriodType: ExecutePaymentDtoPaymentPeriodType | undefined;
    additionalData: { [key: string] : string; } | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number | undefined;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: string | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number | undefined;
    invoiceNo!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number | undefined;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class PCPTBVT_DTO implements IPCPTBVT_DTO {
    pcptbvT_ID!: string | undefined;
    pcptbvT_MA_PCP!: string | undefined;
    pcptbvT_DEP_ID!: string | undefined;
    pcptbvT_DEP_NAME!: string | undefined;
    pcptbvT_GHI_CHU!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_CREATE!: string | undefined;

    constructor(data?: IPCPTBVT_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pcptbvT_ID = data["pcptbvT_ID"];
            this.pcptbvT_MA_PCP = data["pcptbvT_MA_PCP"];
            this.pcptbvT_DEP_ID = data["pcptbvT_DEP_ID"];
            this.pcptbvT_DEP_NAME = data["pcptbvT_DEP_NAME"];
            this.pcptbvT_GHI_CHU = data["pcptbvT_GHI_CHU"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CREATE = data["brancH_CREATE"];
        }
    }

    static fromJS(data: any): PCPTBVT_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PCPTBVT_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pcptbvT_ID"] = this.pcptbvT_ID;
        data["pcptbvT_MA_PCP"] = this.pcptbvT_MA_PCP;
        data["pcptbvT_DEP_ID"] = this.pcptbvT_DEP_ID;
        data["pcptbvT_DEP_NAME"] = this.pcptbvT_DEP_NAME;
        data["pcptbvT_GHI_CHU"] = this.pcptbvT_GHI_CHU;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CREATE"] = this.brancH_CREATE;
        return data; 
    }
}

export interface IPCPTBVT_DTO {
    pcptbvT_ID: string | undefined;
    pcptbvT_MA_PCP: string | undefined;
    pcptbvT_DEP_ID: string | undefined;
    pcptbvT_DEP_NAME: string | undefined;
    pcptbvT_GHI_CHU: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CREATE: string | undefined;
}

export class PagedResultDtoOfPCPTBVT_DTO implements IPagedResultDtoOfPCPTBVT_DTO {
    totalCount!: number | undefined;
    items!: PCPTBVT_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfPCPTBVT_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PCPTBVT_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPCPTBVT_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPCPTBVT_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPCPTBVT_DTO {
    totalCount: number | undefined;
    items: PCPTBVT_DTO[] | undefined;
}

export class PCPTBVT_SEARCH_DTO implements IPCPTBVT_SEARCH_DTO {
    pcptbvT_MA_PCP!: string | undefined;
    pcptbvT_DEP_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    creatE_DT_START!: moment.Moment | undefined;
    creatE_DT_END!: moment.Moment | undefined;

    constructor(data?: IPCPTBVT_SEARCH_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pcptbvT_MA_PCP = data["pcptbvT_MA_PCP"];
            this.pcptbvT_DEP_ID = data["pcptbvT_DEP_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.creatE_DT_START = data["creatE_DT_START"] ? moment(data["creatE_DT_START"].toString()) : <any>undefined;
            this.creatE_DT_END = data["creatE_DT_END"] ? moment(data["creatE_DT_END"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PCPTBVT_SEARCH_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PCPTBVT_SEARCH_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pcptbvT_MA_PCP"] = this.pcptbvT_MA_PCP;
        data["pcptbvT_DEP_ID"] = this.pcptbvT_DEP_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["creatE_DT_START"] = this.creatE_DT_START ? this.creatE_DT_START.toISOString() : <any>undefined;
        data["creatE_DT_END"] = this.creatE_DT_END ? this.creatE_DT_END.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPCPTBVT_SEARCH_DTO {
    pcptbvT_MA_PCP: string | undefined;
    pcptbvT_DEP_ID: string | undefined;
    autH_STATUS: string | undefined;
    creatE_DT_START: moment.Moment | undefined;
    creatE_DT_END: moment.Moment | undefined;
}

export class PCPTBVT_INSERT_DTO implements IPCPTBVT_INSERT_DTO {
    pcptbvT_MA_PCP!: string | undefined;
    pcptbvT_DEP_ID!: string | undefined;
    pcptbvT_GHI_CHU!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    brancH_CREATE!: string | undefined;

    constructor(data?: IPCPTBVT_INSERT_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pcptbvT_MA_PCP = data["pcptbvT_MA_PCP"];
            this.pcptbvT_DEP_ID = data["pcptbvT_DEP_ID"];
            this.pcptbvT_GHI_CHU = data["pcptbvT_GHI_CHU"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.brancH_CREATE = data["brancH_CREATE"];
        }
    }

    static fromJS(data: any): PCPTBVT_INSERT_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PCPTBVT_INSERT_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pcptbvT_MA_PCP"] = this.pcptbvT_MA_PCP;
        data["pcptbvT_DEP_ID"] = this.pcptbvT_DEP_ID;
        data["pcptbvT_GHI_CHU"] = this.pcptbvT_GHI_CHU;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["brancH_CREATE"] = this.brancH_CREATE;
        return data; 
    }
}

export interface IPCPTBVT_INSERT_DTO {
    pcptbvT_MA_PCP: string | undefined;
    pcptbvT_DEP_ID: string | undefined;
    pcptbvT_GHI_CHU: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    brancH_CREATE: string | undefined;
}

export class PCPTBVT_UPDATE_DTO implements IPCPTBVT_UPDATE_DTO {
    pcptbvT_MA_PCP!: string | undefined;
    pcptbvT_DEP_ID!: string | undefined;
    pcptbvT_GHI_CHU!: string | undefined;

    constructor(data?: IPCPTBVT_UPDATE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pcptbvT_MA_PCP = data["pcptbvT_MA_PCP"];
            this.pcptbvT_DEP_ID = data["pcptbvT_DEP_ID"];
            this.pcptbvT_GHI_CHU = data["pcptbvT_GHI_CHU"];
        }
    }

    static fromJS(data: any): PCPTBVT_UPDATE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PCPTBVT_UPDATE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pcptbvT_MA_PCP"] = this.pcptbvT_MA_PCP;
        data["pcptbvT_DEP_ID"] = this.pcptbvT_DEP_ID;
        data["pcptbvT_GHI_CHU"] = this.pcptbvT_GHI_CHU;
        return data; 
    }
}

export interface IPCPTBVT_UPDATE_DTO {
    pcptbvT_MA_PCP: string | undefined;
    pcptbvT_DEP_ID: string | undefined;
    pcptbvT_GHI_CHU: string | undefined;
}

export class PCPTBVT_APPROVE_DTO implements IPCPTBVT_APPROVE_DTO {
    pcptbvT_MA_PCP!: string | undefined;
    checkeR_ID!: string | undefined;

    constructor(data?: IPCPTBVT_APPROVE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pcptbvT_MA_PCP = data["pcptbvT_MA_PCP"];
            this.checkeR_ID = data["checkeR_ID"];
        }
    }

    static fromJS(data: any): PCPTBVT_APPROVE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PCPTBVT_APPROVE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pcptbvT_MA_PCP"] = this.pcptbvT_MA_PCP;
        data["checkeR_ID"] = this.checkeR_ID;
        return data; 
    }
}

export interface IPCPTBVT_APPROVE_DTO {
    pcptbvT_MA_PCP: string | undefined;
    checkeR_ID: string | undefined;
}

export class PTX_DTO implements IPTX_DTO {
    ptX_ID!: string | undefined;
    ptX_CODE!: string | undefined;
    ptX_RENT_DT!: moment.Moment | undefined;
    ptX_EXP_DT!: moment.Moment | undefined;
    ptX_RETURN_DT!: moment.Moment | undefined;
    ptX_PRICE!: number | undefined;
    ptX_NOTE!: string | undefined;
    xE_ID!: string | undefined;
    ntX_ID!: string | undefined;
    createD_DT!: moment.Moment | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IPTX_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ptX_ID = data["ptX_ID"];
            this.ptX_CODE = data["ptX_CODE"];
            this.ptX_RENT_DT = data["ptX_RENT_DT"] ? moment(data["ptX_RENT_DT"].toString()) : <any>undefined;
            this.ptX_EXP_DT = data["ptX_EXP_DT"] ? moment(data["ptX_EXP_DT"].toString()) : <any>undefined;
            this.ptX_RETURN_DT = data["ptX_RETURN_DT"] ? moment(data["ptX_RETURN_DT"].toString()) : <any>undefined;
            this.ptX_PRICE = data["ptX_PRICE"];
            this.ptX_NOTE = data["ptX_NOTE"];
            this.xE_ID = data["xE_ID"];
            this.ntX_ID = data["ntX_ID"];
            this.createD_DT = data["createD_DT"] ? moment(data["createD_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PTX_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PTX_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ptX_ID"] = this.ptX_ID;
        data["ptX_CODE"] = this.ptX_CODE;
        data["ptX_RENT_DT"] = this.ptX_RENT_DT ? this.ptX_RENT_DT.toISOString() : <any>undefined;
        data["ptX_EXP_DT"] = this.ptX_EXP_DT ? this.ptX_EXP_DT.toISOString() : <any>undefined;
        data["ptX_RETURN_DT"] = this.ptX_RETURN_DT ? this.ptX_RETURN_DT.toISOString() : <any>undefined;
        data["ptX_PRICE"] = this.ptX_PRICE;
        data["ptX_NOTE"] = this.ptX_NOTE;
        data["xE_ID"] = this.xE_ID;
        data["ntX_ID"] = this.ntX_ID;
        data["createD_DT"] = this.createD_DT ? this.createD_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPTX_DTO {
    ptX_ID: string | undefined;
    ptX_CODE: string | undefined;
    ptX_RENT_DT: moment.Moment | undefined;
    ptX_EXP_DT: moment.Moment | undefined;
    ptX_RETURN_DT: moment.Moment | undefined;
    ptX_PRICE: number | undefined;
    ptX_NOTE: string | undefined;
    xE_ID: string | undefined;
    ntX_ID: string | undefined;
    createD_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfPTX_DTO implements IPagedResultDtoOfPTX_DTO {
    totalCount!: number | undefined;
    items!: PTX_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfPTX_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PTX_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPTX_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPTX_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPTX_DTO {
    totalCount: number | undefined;
    items: PTX_DTO[] | undefined;
}

export class AppUser implements IAppUser {
    brancH_ID!: string | undefined;

    constructor(data?: IAppUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brancH_ID = data["brancH_ID"];
        }
    }

    static fromJS(data: any): AppUser {
        data = typeof data === 'object' ? data : {};
        let result = new AppUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brancH_ID"] = this.brancH_ID;
        return data; 
    }
}

export interface IAppUser {
    brancH_ID: string | undefined;
}

export class CM_PHONGBAN_DTO implements ICM_PHONGBAN_DTO {
    deP_ID!: string | undefined;
    deP_CODE!: string | undefined;
    deP_NAME!: string | undefined;
    daO_CODE!: string | undefined;
    daO_NAME!: string | undefined;
    brancH_ID!: string | undefined;
    grouP_ID!: string | undefined;
    tel!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_NAME!: string | undefined;

    constructor(data?: ICM_PHONGBAN_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deP_ID = data["deP_ID"];
            this.deP_CODE = data["deP_CODE"];
            this.deP_NAME = data["deP_NAME"];
            this.daO_CODE = data["daO_CODE"];
            this.daO_NAME = data["daO_NAME"];
            this.brancH_ID = data["brancH_ID"];
            this.grouP_ID = data["grouP_ID"];
            this.tel = data["tel"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_NAME = data["brancH_NAME"];
        }
    }

    static fromJS(data: any): CM_PHONGBAN_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new CM_PHONGBAN_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deP_ID"] = this.deP_ID;
        data["deP_CODE"] = this.deP_CODE;
        data["deP_NAME"] = this.deP_NAME;
        data["daO_CODE"] = this.daO_CODE;
        data["daO_NAME"] = this.daO_NAME;
        data["brancH_ID"] = this.brancH_ID;
        data["grouP_ID"] = this.grouP_ID;
        data["tel"] = this.tel;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_NAME"] = this.brancH_NAME;
        return data; 
    }
}

export interface ICM_PHONGBAN_DTO {
    deP_ID: string | undefined;
    deP_CODE: string | undefined;
    deP_NAME: string | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    brancH_ID: string | undefined;
    grouP_ID: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_NAME: string | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean | undefined;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileName!: string;
    x!: number | undefined;
    y!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileName: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class PagedResultDtoOfPhieuThueXe_DTO implements IPagedResultDtoOfPhieuThueXe_DTO {
    totalCount!: number | undefined;
    items!: PhieuThueXe_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfPhieuThueXe_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PhieuThueXe_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPhieuThueXe_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPhieuThueXe_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPhieuThueXe_DTO {
    totalCount: number | undefined;
    items: PhieuThueXe_DTO[] | undefined;
}

export class PhieuThueXe_DTO implements IPhieuThueXe_DTO {
    ptX_ID!: string | undefined;
    ptX_CODE!: string | undefined;
    ptX_RENT_DT!: moment.Moment | undefined;
    ptX_EXP_DT!: moment.Moment | undefined;
    ptX_RETURN_DT!: moment.Moment | undefined;
    ptX_PRICE!: number | undefined;
    ptX_NOTE!: string | undefined;
    xE_ID!: string | undefined;
    ntX_ID!: string | undefined;
    createD_DT!: moment.Moment | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IPhieuThueXe_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ptX_ID = data["ptX_ID"];
            this.ptX_CODE = data["ptX_CODE"];
            this.ptX_RENT_DT = data["ptX_RENT_DT"] ? moment(data["ptX_RENT_DT"].toString()) : <any>undefined;
            this.ptX_EXP_DT = data["ptX_EXP_DT"] ? moment(data["ptX_EXP_DT"].toString()) : <any>undefined;
            this.ptX_RETURN_DT = data["ptX_RETURN_DT"] ? moment(data["ptX_RETURN_DT"].toString()) : <any>undefined;
            this.ptX_PRICE = data["ptX_PRICE"];
            this.ptX_NOTE = data["ptX_NOTE"];
            this.xE_ID = data["xE_ID"];
            this.ntX_ID = data["ntX_ID"];
            this.createD_DT = data["createD_DT"] ? moment(data["createD_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PhieuThueXe_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PhieuThueXe_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ptX_ID"] = this.ptX_ID;
        data["ptX_CODE"] = this.ptX_CODE;
        data["ptX_RENT_DT"] = this.ptX_RENT_DT ? this.ptX_RENT_DT.toISOString() : <any>undefined;
        data["ptX_EXP_DT"] = this.ptX_EXP_DT ? this.ptX_EXP_DT.toISOString() : <any>undefined;
        data["ptX_RETURN_DT"] = this.ptX_RETURN_DT ? this.ptX_RETURN_DT.toISOString() : <any>undefined;
        data["ptX_PRICE"] = this.ptX_PRICE;
        data["ptX_NOTE"] = this.ptX_NOTE;
        data["xE_ID"] = this.xE_ID;
        data["ntX_ID"] = this.ntX_ID;
        data["createD_DT"] = this.createD_DT ? this.createD_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IPhieuThueXe_DTO {
    ptX_ID: string | undefined;
    ptX_CODE: string | undefined;
    ptX_RENT_DT: moment.Moment | undefined;
    ptX_EXP_DT: moment.Moment | undefined;
    ptX_RETURN_DT: moment.Moment | undefined;
    ptX_PRICE: number | undefined;
    ptX_NOTE: string | undefined;
    xE_ID: string | undefined;
    ntX_ID: string | undefined;
    createD_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ResidentApproveRequest implements IResidentApproveRequest {
    residenT_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;

    constructor(data?: IResidentApproveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.residenT_ID = data["residenT_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
        }
    }

    static fromJS(data: any): ResidentApproveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResidentApproveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["residenT_ID"] = this.residenT_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        return data; 
    }
}

export interface IResidentApproveRequest {
    residenT_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
}

export class ResidentCreateRequest implements IResidentCreateRequest {
    residenT_CODE!: string | undefined;
    residenT_NAME!: string | undefined;
    residenT_PHONE!: string | undefined;
    residenT_BIRTH!: moment.Moment | undefined;
    residenT_IDCARD!: string | undefined;
    cuR_APARTMENT!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IResidentCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.residenT_CODE = data["residenT_CODE"];
            this.residenT_NAME = data["residenT_NAME"];
            this.residenT_PHONE = data["residenT_PHONE"];
            this.residenT_BIRTH = data["residenT_BIRTH"] ? moment(data["residenT_BIRTH"].toString()) : <any>undefined;
            this.residenT_IDCARD = data["residenT_IDCARD"];
            this.cuR_APARTMENT = data["cuR_APARTMENT"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResidentCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResidentCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["residenT_CODE"] = this.residenT_CODE;
        data["residenT_NAME"] = this.residenT_NAME;
        data["residenT_PHONE"] = this.residenT_PHONE;
        data["residenT_BIRTH"] = this.residenT_BIRTH ? this.residenT_BIRTH.toISOString() : <any>undefined;
        data["residenT_IDCARD"] = this.residenT_IDCARD;
        data["cuR_APARTMENT"] = this.cuR_APARTMENT;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IResidentCreateRequest {
    residenT_CODE: string | undefined;
    residenT_NAME: string | undefined;
    residenT_PHONE: string | undefined;
    residenT_BIRTH: moment.Moment | undefined;
    residenT_IDCARD: string | undefined;
    cuR_APARTMENT: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ResidentTableDTO implements IResidentTableDTO {
    residenT_ID!: string | undefined;
    residenT_CODE!: string | undefined;
    residenT_NAME!: string | undefined;
    residenT_PHONE!: string | undefined;
    residenT_BIRTH!: moment.Moment | undefined;
    residenT_IDCARD!: string | undefined;
    cuR_APARTMENT!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IResidentTableDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.residenT_ID = data["residenT_ID"];
            this.residenT_CODE = data["residenT_CODE"];
            this.residenT_NAME = data["residenT_NAME"];
            this.residenT_PHONE = data["residenT_PHONE"];
            this.residenT_BIRTH = data["residenT_BIRTH"] ? moment(data["residenT_BIRTH"].toString()) : <any>undefined;
            this.residenT_IDCARD = data["residenT_IDCARD"];
            this.cuR_APARTMENT = data["cuR_APARTMENT"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResidentTableDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResidentTableDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["residenT_ID"] = this.residenT_ID;
        data["residenT_CODE"] = this.residenT_CODE;
        data["residenT_NAME"] = this.residenT_NAME;
        data["residenT_PHONE"] = this.residenT_PHONE;
        data["residenT_BIRTH"] = this.residenT_BIRTH ? this.residenT_BIRTH.toISOString() : <any>undefined;
        data["residenT_IDCARD"] = this.residenT_IDCARD;
        data["cuR_APARTMENT"] = this.cuR_APARTMENT;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IResidentTableDTO {
    residenT_ID: string | undefined;
    residenT_CODE: string | undefined;
    residenT_NAME: string | undefined;
    residenT_PHONE: string | undefined;
    residenT_BIRTH: moment.Moment | undefined;
    residenT_IDCARD: string | undefined;
    cuR_APARTMENT: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class PagedResultDtoOfResidentPagingSearchDTO implements IPagedResultDtoOfResidentPagingSearchDTO {
    totalCount!: number | undefined;
    items!: ResidentPagingSearchDTO[] | undefined;

    constructor(data?: IPagedResultDtoOfResidentPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ResidentPagingSearchDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfResidentPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfResidentPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfResidentPagingSearchDTO {
    totalCount: number | undefined;
    items: ResidentPagingSearchDTO[] | undefined;
}

export class ResidentPagingSearchDTO implements IResidentPagingSearchDTO {
    totalRows!: number | undefined;
    residenT_ID!: string | undefined;
    residenT_CODE!: string | undefined;
    residenT_NAME!: string | undefined;
    residenT_PHONE!: string | undefined;
    residenT_BIRTH!: moment.Moment | undefined;
    residenT_IDCARD!: string | undefined;
    cuR_APARTMENT!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IResidentPagingSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalRows = data["totalRows"];
            this.residenT_ID = data["residenT_ID"];
            this.residenT_CODE = data["residenT_CODE"];
            this.residenT_NAME = data["residenT_NAME"];
            this.residenT_PHONE = data["residenT_PHONE"];
            this.residenT_BIRTH = data["residenT_BIRTH"] ? moment(data["residenT_BIRTH"].toString()) : <any>undefined;
            this.residenT_IDCARD = data["residenT_IDCARD"];
            this.cuR_APARTMENT = data["cuR_APARTMENT"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResidentPagingSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResidentPagingSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRows"] = this.totalRows;
        data["residenT_ID"] = this.residenT_ID;
        data["residenT_CODE"] = this.residenT_CODE;
        data["residenT_NAME"] = this.residenT_NAME;
        data["residenT_PHONE"] = this.residenT_PHONE;
        data["residenT_BIRTH"] = this.residenT_BIRTH ? this.residenT_BIRTH.toISOString() : <any>undefined;
        data["residenT_IDCARD"] = this.residenT_IDCARD;
        data["cuR_APARTMENT"] = this.cuR_APARTMENT;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IResidentPagingSearchDTO {
    totalRows: number | undefined;
    residenT_ID: string | undefined;
    residenT_CODE: string | undefined;
    residenT_NAME: string | undefined;
    residenT_PHONE: string | undefined;
    residenT_BIRTH: moment.Moment | undefined;
    residenT_IDCARD: string | undefined;
    cuR_APARTMENT: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ResidentUpdateRequest implements IResidentUpdateRequest {
    residenT_ID!: string | undefined;
    residenT_CODE!: string | undefined;
    residenT_NAME!: string | undefined;
    residenT_PHONE!: string | undefined;
    residenT_BIRTH!: moment.Moment | undefined;
    residenT_IDCARD!: string | undefined;
    cuR_APARTMENT!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IResidentUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.residenT_ID = data["residenT_ID"];
            this.residenT_CODE = data["residenT_CODE"];
            this.residenT_NAME = data["residenT_NAME"];
            this.residenT_PHONE = data["residenT_PHONE"];
            this.residenT_BIRTH = data["residenT_BIRTH"] ? moment(data["residenT_BIRTH"].toString()) : <any>undefined;
            this.residenT_IDCARD = data["residenT_IDCARD"];
            this.cuR_APARTMENT = data["cuR_APARTMENT"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResidentUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResidentUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["residenT_ID"] = this.residenT_ID;
        data["residenT_CODE"] = this.residenT_CODE;
        data["residenT_NAME"] = this.residenT_NAME;
        data["residenT_PHONE"] = this.residenT_PHONE;
        data["residenT_BIRTH"] = this.residenT_BIRTH ? this.residenT_BIRTH.toISOString() : <any>undefined;
        data["residenT_IDCARD"] = this.residenT_IDCARD;
        data["cuR_APARTMENT"] = this.cuR_APARTMENT;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IResidentUpdateRequest {
    residenT_ID: string | undefined;
    residenT_CODE: string | undefined;
    residenT_NAME: string | undefined;
    residenT_PHONE: string | undefined;
    residenT_BIRTH: moment.Moment | undefined;
    residenT_IDCARD: string | undefined;
    cuR_APARTMENT: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean | undefined;
    isDefault!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto | undefined;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class PagedResultDtoOfServiceSearchDTO implements IPagedResultDtoOfServiceSearchDTO {
    totalCount!: number | undefined;
    items!: ServiceSearchDTO[] | undefined;

    constructor(data?: IPagedResultDtoOfServiceSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ServiceSearchDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfServiceSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfServiceSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfServiceSearchDTO {
    totalCount: number | undefined;
    items: ServiceSearchDTO[] | undefined;
}

export class ServiceSearchDTO implements IServiceSearchDTO {
    totalRows!: number | undefined;
    servicE_ID!: string | undefined;
    servicE_CODE!: string | undefined;
    servicE_NAME!: string | undefined;
    servicE_UNIT!: string | undefined;
    recorD_STATUS!: string | undefined;

    constructor(data?: IServiceSearchDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalRows = data["totalRows"];
            this.servicE_ID = data["servicE_ID"];
            this.servicE_CODE = data["servicE_CODE"];
            this.servicE_NAME = data["servicE_NAME"];
            this.servicE_UNIT = data["servicE_UNIT"];
            this.recorD_STATUS = data["recorD_STATUS"];
        }
    }

    static fromJS(data: any): ServiceSearchDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceSearchDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRows"] = this.totalRows;
        data["servicE_ID"] = this.servicE_ID;
        data["servicE_CODE"] = this.servicE_CODE;
        data["servicE_NAME"] = this.servicE_NAME;
        data["servicE_UNIT"] = this.servicE_UNIT;
        data["recorD_STATUS"] = this.recorD_STATUS;
        return data; 
    }
}

export interface IServiceSearchDTO {
    totalRows: number | undefined;
    servicE_ID: string | undefined;
    servicE_CODE: string | undefined;
    servicE_NAME: string | undefined;
    servicE_UNIT: string | undefined;
    recorD_STATUS: string | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto | undefined;
    tenant!: TenantLoginInfoDto | undefined;
    application!: ApplicationInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    edition!: EditionInfoDto | undefined;
    creationTime!: moment.Moment | undefined;
    paymentPeriodType!: TenantLoginInfoDtoPaymentPeriodType | undefined;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: TenantLoginInfoDtoPaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment | undefined;
    features!: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean | undefined;
    isFree!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number | undefined;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number | undefined;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [];
                for (let item of data["memberActivities"])
                    this.memberActivities.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number | undefined;
    closed!: number | undefined;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number | undefined;
    newFeedbacks!: number | undefined;
    newOrders!: number | undefined;
    newUsers!: number | undefined;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number | undefined;
    revenue!: number | undefined;
    expenses!: number | undefined;
    growth!: number | undefined;
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [];
                for (let item of data["dailySales"])
                    this.dailySales.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [];
                for (let item of data["profitShares"])
                    this.profitShares.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number | undefined;
    profit!: number | undefined;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stats"] && data["stats"].constructor === Array) {
                this.stats = [];
                for (let item of data["stats"])
                    this.stats.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stats && this.stats.constructor === Array) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number | undefined;
    change!: number[] | undefined;
    averagePrice!: number | undefined;
    totalPrice!: number | undefined;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (data["change"] && data["change"].constructor === Array) {
                this.change = [];
                for (let item of data["change"])
                    this.change.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (this.change && this.change.constructor === Array) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: RegisterTenantInputSubscriptionStartType | undefined;
    gateway!: RegisterTenantInputGateway | undefined;
    editionId!: number | undefined;
    paymentId!: string | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.gateway = data["gateway"];
            this.editionId = data["editionId"];
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["gateway"] = this.gateway;
        data["editionId"] = this.editionId;
        data["paymentId"] = this.paymentId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: RegisterTenantInputSubscriptionStartType | undefined;
    gateway: RegisterTenantInputGateway | undefined;
    editionId: number | undefined;
    paymentId: string | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean | undefined;
    isActive!: boolean | undefined;
    isEmailConfirmationRequired!: boolean | undefined;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;
    tenantEditionId!: number | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [];
                for (let item of data["allFeatures"])
                    this.allFeatures.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [];
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType | undefined;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto | undefined;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;
}

export class IInputType implements IIInputType {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator | undefined;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto | undefined;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto | undefined;
    ldap!: LdapSettingsEditDto | undefined;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredUserActiveByDefault!: boolean | undefined;
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean | undefined;
    isEnabled!: boolean | undefined;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class THIET_BI_DTO implements ITHIET_BI_DTO {
    tB_ID!: string | undefined;
    tB_TEN!: string | undefined;
    tB_TT_HOAT_DONG!: string | undefined;
    tB_DV_QL!: string | undefined;
    tB_CHU_KY_BAO_DUONG!: string | undefined;
    tB_NGAY_MUA!: moment.Moment | undefined;
    tB_NGAY_BH!: moment.Moment | undefined;
    tB_NGAY_HET_BH!: moment.Moment | undefined;
    tB_MO_TA!: string | undefined;
    tB_NSX!: string | undefined;
    tB_Nam_SX!: number | undefined;
    tB_SERIAL!: string | undefined;
    tB_TEN_DV!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: ITHIET_BI_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tB_ID = data["tB_ID"];
            this.tB_TEN = data["tB_TEN"];
            this.tB_TT_HOAT_DONG = data["tB_TT_HOAT_DONG"];
            this.tB_DV_QL = data["tB_DV_QL"];
            this.tB_CHU_KY_BAO_DUONG = data["tB_CHU_KY_BAO_DUONG"];
            this.tB_NGAY_MUA = data["tB_NGAY_MUA"] ? moment(data["tB_NGAY_MUA"].toString()) : <any>undefined;
            this.tB_NGAY_BH = data["tB_NGAY_BH"] ? moment(data["tB_NGAY_BH"].toString()) : <any>undefined;
            this.tB_NGAY_HET_BH = data["tB_NGAY_HET_BH"] ? moment(data["tB_NGAY_HET_BH"].toString()) : <any>undefined;
            this.tB_MO_TA = data["tB_MO_TA"];
            this.tB_NSX = data["tB_NSX"];
            this.tB_Nam_SX = data["tB_Nam_SX"];
            this.tB_SERIAL = data["tB_SERIAL"];
            this.tB_TEN_DV = data["tB_TEN_DV"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): THIET_BI_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new THIET_BI_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tB_ID"] = this.tB_ID;
        data["tB_TEN"] = this.tB_TEN;
        data["tB_TT_HOAT_DONG"] = this.tB_TT_HOAT_DONG;
        data["tB_DV_QL"] = this.tB_DV_QL;
        data["tB_CHU_KY_BAO_DUONG"] = this.tB_CHU_KY_BAO_DUONG;
        data["tB_NGAY_MUA"] = this.tB_NGAY_MUA ? this.tB_NGAY_MUA.toISOString() : <any>undefined;
        data["tB_NGAY_BH"] = this.tB_NGAY_BH ? this.tB_NGAY_BH.toISOString() : <any>undefined;
        data["tB_NGAY_HET_BH"] = this.tB_NGAY_HET_BH ? this.tB_NGAY_HET_BH.toISOString() : <any>undefined;
        data["tB_MO_TA"] = this.tB_MO_TA;
        data["tB_NSX"] = this.tB_NSX;
        data["tB_Nam_SX"] = this.tB_Nam_SX;
        data["tB_SERIAL"] = this.tB_SERIAL;
        data["tB_TEN_DV"] = this.tB_TEN_DV;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITHIET_BI_DTO {
    tB_ID: string | undefined;
    tB_TEN: string | undefined;
    tB_TT_HOAT_DONG: string | undefined;
    tB_DV_QL: string | undefined;
    tB_CHU_KY_BAO_DUONG: string | undefined;
    tB_NGAY_MUA: moment.Moment | undefined;
    tB_NGAY_BH: moment.Moment | undefined;
    tB_NGAY_HET_BH: moment.Moment | undefined;
    tB_MO_TA: string | undefined;
    tB_NSX: string | undefined;
    tB_Nam_SX: number | undefined;
    tB_SERIAL: string | undefined;
    tB_TEN_DV: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class THIETBIVATTU_DTO implements ITHIETBIVATTU_DTO {
    tbvT_ID!: string | undefined;
    tbvT_MA_TBVT!: string | undefined;
    tbvT_TEN!: string | undefined;
    tbvT_SERIAL!: string | undefined;
    tbvT_LOAI!: string | undefined;
    tbvT_NGAY_MUA!: moment.Moment | undefined;
    tbvT_DVT!: string | undefined;
    tbvT_TEN_DVT!: string | undefined;
    tbvT_NHAP_THEO_LO!: string | undefined;
    tbvT_SL_THEO_LO!: string | undefined;
    tbvT_HANG_SX!: string | undefined;
    tbvT_NAM_SX!: string | undefined;
    tbvT_NGAY_TINH_BAO_HANH!: moment.Moment | undefined;
    tbvT_NGAY_KET_THUC_BAO_HANH!: moment.Moment | undefined;
    tbvT_NHA_CUNG_CAP!: string | undefined;
    tbvT_TINH_TRANG_THIET_BI!: string | undefined;
    tbvT_GHI_CHU_TINH_TRANG!: string | undefined;
    tbvT_CAN_BAO_DUONG!: string | undefined;
    tbvT_CHU_KY_BAO_DUONG!: string | undefined;
    tbvT_NOI_DUNG_BAO_DUONG!: string | undefined;
    tbvT_TI_LE_HAO_MON!: string | undefined;
    tbvT_TINH_TRANG_TBTBVT!: string | undefined;
    tbvT_PHU_KIEN_TEN!: string | undefined;
    tbvT_PHU_KIEN_DVT!: string | undefined;
    tbvT_PHU_KIEN_SO_LUONG!: number | undefined;
    tbvT_PHU_KIEN_GHI_CHU!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_CREATE!: string | undefined;
    tbvT_PCPTBVT_ID!: string | undefined;

    constructor(data?: ITHIETBIVATTU_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tbvT_ID = data["tbvT_ID"];
            this.tbvT_MA_TBVT = data["tbvT_MA_TBVT"];
            this.tbvT_TEN = data["tbvT_TEN"];
            this.tbvT_SERIAL = data["tbvT_SERIAL"];
            this.tbvT_LOAI = data["tbvT_LOAI"];
            this.tbvT_NGAY_MUA = data["tbvT_NGAY_MUA"] ? moment(data["tbvT_NGAY_MUA"].toString()) : <any>undefined;
            this.tbvT_DVT = data["tbvT_DVT"];
            this.tbvT_TEN_DVT = data["tbvT_TEN_DVT"];
            this.tbvT_NHAP_THEO_LO = data["tbvT_NHAP_THEO_LO"];
            this.tbvT_SL_THEO_LO = data["tbvT_SL_THEO_LO"];
            this.tbvT_HANG_SX = data["tbvT_HANG_SX"];
            this.tbvT_NAM_SX = data["tbvT_NAM_SX"];
            this.tbvT_NGAY_TINH_BAO_HANH = data["tbvT_NGAY_TINH_BAO_HANH"] ? moment(data["tbvT_NGAY_TINH_BAO_HANH"].toString()) : <any>undefined;
            this.tbvT_NGAY_KET_THUC_BAO_HANH = data["tbvT_NGAY_KET_THUC_BAO_HANH"] ? moment(data["tbvT_NGAY_KET_THUC_BAO_HANH"].toString()) : <any>undefined;
            this.tbvT_NHA_CUNG_CAP = data["tbvT_NHA_CUNG_CAP"];
            this.tbvT_TINH_TRANG_THIET_BI = data["tbvT_TINH_TRANG_THIET_BI"];
            this.tbvT_GHI_CHU_TINH_TRANG = data["tbvT_GHI_CHU_TINH_TRANG"];
            this.tbvT_CAN_BAO_DUONG = data["tbvT_CAN_BAO_DUONG"];
            this.tbvT_CHU_KY_BAO_DUONG = data["tbvT_CHU_KY_BAO_DUONG"];
            this.tbvT_NOI_DUNG_BAO_DUONG = data["tbvT_NOI_DUNG_BAO_DUONG"];
            this.tbvT_TI_LE_HAO_MON = data["tbvT_TI_LE_HAO_MON"];
            this.tbvT_TINH_TRANG_TBTBVT = data["tbvT_TINH_TRANG_TBTBVT"];
            this.tbvT_PHU_KIEN_TEN = data["tbvT_PHU_KIEN_TEN"];
            this.tbvT_PHU_KIEN_DVT = data["tbvT_PHU_KIEN_DVT"];
            this.tbvT_PHU_KIEN_SO_LUONG = data["tbvT_PHU_KIEN_SO_LUONG"];
            this.tbvT_PHU_KIEN_GHI_CHU = data["tbvT_PHU_KIEN_GHI_CHU"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CREATE = data["brancH_CREATE"];
            this.tbvT_PCPTBVT_ID = data["tbvT_PCPTBVT_ID"];
        }
    }

    static fromJS(data: any): THIETBIVATTU_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new THIETBIVATTU_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tbvT_ID"] = this.tbvT_ID;
        data["tbvT_MA_TBVT"] = this.tbvT_MA_TBVT;
        data["tbvT_TEN"] = this.tbvT_TEN;
        data["tbvT_SERIAL"] = this.tbvT_SERIAL;
        data["tbvT_LOAI"] = this.tbvT_LOAI;
        data["tbvT_NGAY_MUA"] = this.tbvT_NGAY_MUA ? this.tbvT_NGAY_MUA.toISOString() : <any>undefined;
        data["tbvT_DVT"] = this.tbvT_DVT;
        data["tbvT_TEN_DVT"] = this.tbvT_TEN_DVT;
        data["tbvT_NHAP_THEO_LO"] = this.tbvT_NHAP_THEO_LO;
        data["tbvT_SL_THEO_LO"] = this.tbvT_SL_THEO_LO;
        data["tbvT_HANG_SX"] = this.tbvT_HANG_SX;
        data["tbvT_NAM_SX"] = this.tbvT_NAM_SX;
        data["tbvT_NGAY_TINH_BAO_HANH"] = this.tbvT_NGAY_TINH_BAO_HANH ? this.tbvT_NGAY_TINH_BAO_HANH.toISOString() : <any>undefined;
        data["tbvT_NGAY_KET_THUC_BAO_HANH"] = this.tbvT_NGAY_KET_THUC_BAO_HANH ? this.tbvT_NGAY_KET_THUC_BAO_HANH.toISOString() : <any>undefined;
        data["tbvT_NHA_CUNG_CAP"] = this.tbvT_NHA_CUNG_CAP;
        data["tbvT_TINH_TRANG_THIET_BI"] = this.tbvT_TINH_TRANG_THIET_BI;
        data["tbvT_GHI_CHU_TINH_TRANG"] = this.tbvT_GHI_CHU_TINH_TRANG;
        data["tbvT_CAN_BAO_DUONG"] = this.tbvT_CAN_BAO_DUONG;
        data["tbvT_CHU_KY_BAO_DUONG"] = this.tbvT_CHU_KY_BAO_DUONG;
        data["tbvT_NOI_DUNG_BAO_DUONG"] = this.tbvT_NOI_DUNG_BAO_DUONG;
        data["tbvT_TI_LE_HAO_MON"] = this.tbvT_TI_LE_HAO_MON;
        data["tbvT_TINH_TRANG_TBTBVT"] = this.tbvT_TINH_TRANG_TBTBVT;
        data["tbvT_PHU_KIEN_TEN"] = this.tbvT_PHU_KIEN_TEN;
        data["tbvT_PHU_KIEN_DVT"] = this.tbvT_PHU_KIEN_DVT;
        data["tbvT_PHU_KIEN_SO_LUONG"] = this.tbvT_PHU_KIEN_SO_LUONG;
        data["tbvT_PHU_KIEN_GHI_CHU"] = this.tbvT_PHU_KIEN_GHI_CHU;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CREATE"] = this.brancH_CREATE;
        data["tbvT_PCPTBVT_ID"] = this.tbvT_PCPTBVT_ID;
        return data; 
    }
}

export interface ITHIETBIVATTU_DTO {
    tbvT_ID: string | undefined;
    tbvT_MA_TBVT: string | undefined;
    tbvT_TEN: string | undefined;
    tbvT_SERIAL: string | undefined;
    tbvT_LOAI: string | undefined;
    tbvT_NGAY_MUA: moment.Moment | undefined;
    tbvT_DVT: string | undefined;
    tbvT_TEN_DVT: string | undefined;
    tbvT_NHAP_THEO_LO: string | undefined;
    tbvT_SL_THEO_LO: string | undefined;
    tbvT_HANG_SX: string | undefined;
    tbvT_NAM_SX: string | undefined;
    tbvT_NGAY_TINH_BAO_HANH: moment.Moment | undefined;
    tbvT_NGAY_KET_THUC_BAO_HANH: moment.Moment | undefined;
    tbvT_NHA_CUNG_CAP: string | undefined;
    tbvT_TINH_TRANG_THIET_BI: string | undefined;
    tbvT_GHI_CHU_TINH_TRANG: string | undefined;
    tbvT_CAN_BAO_DUONG: string | undefined;
    tbvT_CHU_KY_BAO_DUONG: string | undefined;
    tbvT_NOI_DUNG_BAO_DUONG: string | undefined;
    tbvT_TI_LE_HAO_MON: string | undefined;
    tbvT_TINH_TRANG_TBTBVT: string | undefined;
    tbvT_PHU_KIEN_TEN: string | undefined;
    tbvT_PHU_KIEN_DVT: string | undefined;
    tbvT_PHU_KIEN_SO_LUONG: number | undefined;
    tbvT_PHU_KIEN_GHI_CHU: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CREATE: string | undefined;
    tbvT_PCPTBVT_ID: string | undefined;
}

export class PagedResultDtoOfTHIETBIVATTU_DTO implements IPagedResultDtoOfTHIETBIVATTU_DTO {
    totalCount!: number | undefined;
    items!: THIETBIVATTU_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfTHIETBIVATTU_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(THIETBIVATTU_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTHIETBIVATTU_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTHIETBIVATTU_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTHIETBIVATTU_DTO {
    totalCount: number | undefined;
    items: THIETBIVATTU_DTO[] | undefined;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean | undefined;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number | undefined;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    waitingForActivation!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;
}

export class TTYCSC_DTO implements ITTYCSC_DTO {
    ttycsC_ID!: string | undefined;
    ttycsC_CODE!: string | undefined;
    ttycsC_NAME!: string | undefined;
    ttycsC_DESC!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    typE_APPROVE!: string | undefined;

    constructor(data?: ITTYCSC_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ttycsC_ID = data["ttycsC_ID"];
            this.ttycsC_CODE = data["ttycsC_CODE"];
            this.ttycsC_NAME = data["ttycsC_NAME"];
            this.ttycsC_DESC = data["ttycsC_DESC"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.typE_APPROVE = data["typE_APPROVE"];
        }
    }

    static fromJS(data: any): TTYCSC_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new TTYCSC_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ttycsC_ID"] = this.ttycsC_ID;
        data["ttycsC_CODE"] = this.ttycsC_CODE;
        data["ttycsC_NAME"] = this.ttycsC_NAME;
        data["ttycsC_DESC"] = this.ttycsC_DESC;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["typE_APPROVE"] = this.typE_APPROVE;
        return data; 
    }
}

export interface ITTYCSC_DTO {
    ttycsC_ID: string | undefined;
    ttycsC_CODE: string | undefined;
    ttycsC_NAME: string | undefined;
    ttycsC_DESC: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    typE_APPROVE: string | undefined;
}

export class UiCustomizationSettingsEditDto implements IUiCustomizationSettingsEditDto {
    layout!: UiCustomizationLayoutSettingsEditDto | undefined;
    header!: UiCustomizationHeaderSettingsEditDto | undefined;
    menu!: UiCustomizationMenuSettingsEditDto | undefined;
    footer!: UiCustomizationFooterSettingsEditDto | undefined;

    constructor(data?: IUiCustomizationSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layout = data["layout"] ? UiCustomizationLayoutSettingsEditDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? UiCustomizationHeaderSettingsEditDto.fromJS(data["header"]) : <any>undefined;
            this.menu = data["menu"] ? UiCustomizationMenuSettingsEditDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? UiCustomizationFooterSettingsEditDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UiCustomizationSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUiCustomizationSettingsEditDto {
    layout: UiCustomizationLayoutSettingsEditDto | undefined;
    header: UiCustomizationHeaderSettingsEditDto | undefined;
    menu: UiCustomizationMenuSettingsEditDto | undefined;
    footer: UiCustomizationFooterSettingsEditDto | undefined;
}

export class UiCustomizationLayoutSettingsEditDto implements IUiCustomizationLayoutSettingsEditDto {
    layoutType!: string | undefined;
    contentSkin!: string | undefined;
    theme!: string | undefined;

    constructor(data?: IUiCustomizationLayoutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
            this.contentSkin = data["contentSkin"];
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): UiCustomizationLayoutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationLayoutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["contentSkin"] = this.contentSkin;
        data["theme"] = this.theme;
        return data; 
    }
}

export interface IUiCustomizationLayoutSettingsEditDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    theme: string | undefined;
}

export class UiCustomizationHeaderSettingsEditDto implements IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader!: boolean | undefined;
    desktopMinimizeMode!: string | undefined;
    mobileFixedHeader!: boolean | undefined;
    headerSkin!: string | undefined;
    displaySubmenuArrowDesktop!: boolean | undefined;

    constructor(data?: IUiCustomizationHeaderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.desktopMinimizeMode = data["desktopMinimizeMode"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
            this.displaySubmenuArrowDesktop = data["displaySubmenuArrowDesktop"];
        }
    }

    static fromJS(data: any): UiCustomizationHeaderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationHeaderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["desktopMinimizeMode"] = this.desktopMinimizeMode;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["displaySubmenuArrowDesktop"] = this.displaySubmenuArrowDesktop;
        return data; 
    }
}

export interface IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader: boolean | undefined;
    desktopMinimizeMode: string | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;
    displaySubmenuArrowDesktop: boolean | undefined;
}

export class UiCustomizationMenuSettingsEditDto implements IUiCustomizationMenuSettingsEditDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean | undefined;
    allowAsideMinimizing!: boolean | undefined;
    defaultMinimizedAside!: boolean | undefined;
    allowAsideHiding!: boolean | undefined;
    defaultHiddenAside!: boolean | undefined;
    submenuToggle!: string | undefined;
    dropdownSubmenuSkin!: string | undefined;
    dropdownSubmenuArrow!: boolean | undefined;

    constructor(data?: IUiCustomizationMenuSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.allowAsideHiding = data["allowAsideHiding"];
            this.defaultHiddenAside = data["defaultHiddenAside"];
            this.submenuToggle = data["submenuToggle"];
            this.dropdownSubmenuSkin = data["dropdownSubmenuSkin"];
            this.dropdownSubmenuArrow = data["dropdownSubmenuArrow"];
        }
    }

    static fromJS(data: any): UiCustomizationMenuSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationMenuSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["allowAsideHiding"] = this.allowAsideHiding;
        data["defaultHiddenAside"] = this.defaultHiddenAside;
        data["submenuToggle"] = this.submenuToggle;
        data["dropdownSubmenuSkin"] = this.dropdownSubmenuSkin;
        data["dropdownSubmenuArrow"] = this.dropdownSubmenuArrow;
        return data; 
    }
}

export interface IUiCustomizationMenuSettingsEditDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    allowAsideHiding: boolean | undefined;
    defaultHiddenAside: boolean | undefined;
    submenuToggle: string | undefined;
    dropdownSubmenuSkin: string | undefined;
    dropdownSubmenuArrow: boolean | undefined;
}

export class UiCustomizationFooterSettingsEditDto implements IUiCustomizationFooterSettingsEditDto {
    fixedFooter!: boolean | undefined;

    constructor(data?: IUiCustomizationFooterSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): UiCustomizationFooterSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationFooterSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IUiCustomizationFooterSettingsEditDto {
    fixedFooter: boolean | undefined;
}

export class Use_DichVuInsertRequest implements IUse_DichVuInsertRequest {
    canhO_ID!: string | undefined;
    dichvU_ID!: string | undefined;
    nG_START!: moment.Moment | undefined;
    nG_END!: moment.Moment | undefined;
    gT_DAU!: number | undefined;
    gT_CUOI!: number | undefined;
    doN_GIA!: number | undefined;

    constructor(data?: IUse_DichVuInsertRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canhO_ID = data["canhO_ID"];
            this.dichvU_ID = data["dichvU_ID"];
            this.nG_START = data["nG_START"] ? moment(data["nG_START"].toString()) : <any>undefined;
            this.nG_END = data["nG_END"] ? moment(data["nG_END"].toString()) : <any>undefined;
            this.gT_DAU = data["gT_DAU"];
            this.gT_CUOI = data["gT_CUOI"];
            this.doN_GIA = data["doN_GIA"];
        }
    }

    static fromJS(data: any): Use_DichVuInsertRequest {
        data = typeof data === 'object' ? data : {};
        let result = new Use_DichVuInsertRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canhO_ID"] = this.canhO_ID;
        data["dichvU_ID"] = this.dichvU_ID;
        data["nG_START"] = this.nG_START ? this.nG_START.toISOString() : <any>undefined;
        data["nG_END"] = this.nG_END ? this.nG_END.toISOString() : <any>undefined;
        data["gT_DAU"] = this.gT_DAU;
        data["gT_CUOI"] = this.gT_CUOI;
        data["doN_GIA"] = this.doN_GIA;
        return data; 
    }
}

export interface IUse_DichVuInsertRequest {
    canhO_ID: string | undefined;
    dichvU_ID: string | undefined;
    nG_START: moment.Moment | undefined;
    nG_END: moment.Moment | undefined;
    gT_DAU: number | undefined;
    gT_CUOI: number | undefined;
    doN_GIA: number | undefined;
}

export class PagedResultDtoOfUse_DichVuSearchDTOs implements IPagedResultDtoOfUse_DichVuSearchDTOs {
    totalCount!: number | undefined;
    items!: Use_DichVuSearchDTOs[] | undefined;

    constructor(data?: IPagedResultDtoOfUse_DichVuSearchDTOs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Use_DichVuSearchDTOs.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUse_DichVuSearchDTOs {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUse_DichVuSearchDTOs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUse_DichVuSearchDTOs {
    totalCount: number | undefined;
    items: Use_DichVuSearchDTOs[] | undefined;
}

export class Use_DichVuSearchDTOs implements IUse_DichVuSearchDTOs {
    totalRows!: number | undefined;
    canhO_ID!: string | undefined;
    dichvU_ID!: string | undefined;
    nG_START!: moment.Moment | undefined;
    nG_END!: moment.Moment | undefined;
    gT_DAU!: number | undefined;
    gT_CUOI!: number | undefined;
    doN_GIA!: number | undefined;
    tong!: number | undefined;
    recorD_STATUS!: string | undefined;

    constructor(data?: IUse_DichVuSearchDTOs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalRows = data["totalRows"];
            this.canhO_ID = data["canhO_ID"];
            this.dichvU_ID = data["dichvU_ID"];
            this.nG_START = data["nG_START"] ? moment(data["nG_START"].toString()) : <any>undefined;
            this.nG_END = data["nG_END"] ? moment(data["nG_END"].toString()) : <any>undefined;
            this.gT_DAU = data["gT_DAU"];
            this.gT_CUOI = data["gT_CUOI"];
            this.doN_GIA = data["doN_GIA"];
            this.tong = data["tong"];
            this.recorD_STATUS = data["recorD_STATUS"];
        }
    }

    static fromJS(data: any): Use_DichVuSearchDTOs {
        data = typeof data === 'object' ? data : {};
        let result = new Use_DichVuSearchDTOs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalRows"] = this.totalRows;
        data["canhO_ID"] = this.canhO_ID;
        data["dichvU_ID"] = this.dichvU_ID;
        data["nG_START"] = this.nG_START ? this.nG_START.toISOString() : <any>undefined;
        data["nG_END"] = this.nG_END ? this.nG_END.toISOString() : <any>undefined;
        data["gT_DAU"] = this.gT_DAU;
        data["gT_CUOI"] = this.gT_CUOI;
        data["doN_GIA"] = this.doN_GIA;
        data["tong"] = this.tong;
        data["recorD_STATUS"] = this.recorD_STATUS;
        return data; 
    }
}

export interface IUse_DichVuSearchDTOs {
    totalRows: number | undefined;
    canhO_ID: string | undefined;
    dichvU_ID: string | undefined;
    nG_START: moment.Moment | undefined;
    nG_END: moment.Moment | undefined;
    gT_DAU: number | undefined;
    gT_CUOI: number | undefined;
    doN_GIA: number | undefined;
    tong: number | undefined;
    recorD_STATUS: string | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number | undefined;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean | undefined;
    roles!: UserListRoleDto[] | undefined;
    lastLoginTime!: moment.Moment | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto | undefined;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [];
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [];
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number | undefined;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean | undefined;
    setRandomPassword!: boolean | undefined;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [];
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number | undefined;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    lastLoginTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [];
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class CM_XE_DTO implements ICM_XE_DTO {
    xE_ID!: string | undefined;
    xE_CODE!: string | undefined;
    xE_NAME!: string | undefined;
    xE_COLOR!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: ICM_XE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.xE_ID = data["xE_ID"];
            this.xE_CODE = data["xE_CODE"];
            this.xE_NAME = data["xE_NAME"];
            this.xE_COLOR = data["xE_COLOR"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_XE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new CM_XE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xE_ID"] = this.xE_ID;
        data["xE_CODE"] = this.xE_CODE;
        data["xE_NAME"] = this.xE_NAME;
        data["xE_COLOR"] = this.xE_COLOR;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICM_XE_DTO {
    xE_ID: string | undefined;
    xE_CODE: string | undefined;
    xE_NAME: string | undefined;
    xE_COLOR: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class XE_DTO implements IXE_DTO {
    xE_ID!: string | undefined;
    xE_CODE!: string | undefined;
    xE_NAME!: string | undefined;
    xE_COLOR!: string | undefined;
    xE_SEATS!: number | undefined;
    xE_MODEL!: string | undefined;
    xE_LICENSE_PLATE!: string | undefined;
    xE_PRICE!: number | undefined;
    xE_CONSUMPTION!: number | undefined;
    xE_NOTES!: string | undefined;
    xE_MAX_SPEED!: number | undefined;
    xE_MANUFACTURER!: string | undefined;
    xE_MANUFACTURE_YEAR!: number | undefined;
    xE_STATUS!: string | undefined;
    createD_DT!: moment.Moment | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    xE_TOTAL_KM!: number | undefined;
    xE_NEED_MAINTENANCE!: string | undefined;
    xE_LAST_TOTAL_KM!: number | undefined;
    xE_LAST_DISTANCE!: number | undefined;

    constructor(data?: IXE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.xE_ID = data["xE_ID"];
            this.xE_CODE = data["xE_CODE"];
            this.xE_NAME = data["xE_NAME"];
            this.xE_COLOR = data["xE_COLOR"];
            this.xE_SEATS = data["xE_SEATS"];
            this.xE_MODEL = data["xE_MODEL"];
            this.xE_LICENSE_PLATE = data["xE_LICENSE_PLATE"];
            this.xE_PRICE = data["xE_PRICE"];
            this.xE_CONSUMPTION = data["xE_CONSUMPTION"];
            this.xE_NOTES = data["xE_NOTES"];
            this.xE_MAX_SPEED = data["xE_MAX_SPEED"];
            this.xE_MANUFACTURER = data["xE_MANUFACTURER"];
            this.xE_MANUFACTURE_YEAR = data["xE_MANUFACTURE_YEAR"];
            this.xE_STATUS = data["xE_STATUS"];
            this.createD_DT = data["createD_DT"] ? moment(data["createD_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.xE_TOTAL_KM = data["xE_TOTAL_KM"];
            this.xE_NEED_MAINTENANCE = data["xE_NEED_MAINTENANCE"];
            this.xE_LAST_TOTAL_KM = data["xE_LAST_TOTAL_KM"];
            this.xE_LAST_DISTANCE = data["xE_LAST_DISTANCE"];
        }
    }

    static fromJS(data: any): XE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new XE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xE_ID"] = this.xE_ID;
        data["xE_CODE"] = this.xE_CODE;
        data["xE_NAME"] = this.xE_NAME;
        data["xE_COLOR"] = this.xE_COLOR;
        data["xE_SEATS"] = this.xE_SEATS;
        data["xE_MODEL"] = this.xE_MODEL;
        data["xE_LICENSE_PLATE"] = this.xE_LICENSE_PLATE;
        data["xE_PRICE"] = this.xE_PRICE;
        data["xE_CONSUMPTION"] = this.xE_CONSUMPTION;
        data["xE_NOTES"] = this.xE_NOTES;
        data["xE_MAX_SPEED"] = this.xE_MAX_SPEED;
        data["xE_MANUFACTURER"] = this.xE_MANUFACTURER;
        data["xE_MANUFACTURE_YEAR"] = this.xE_MANUFACTURE_YEAR;
        data["xE_STATUS"] = this.xE_STATUS;
        data["createD_DT"] = this.createD_DT ? this.createD_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["xE_TOTAL_KM"] = this.xE_TOTAL_KM;
        data["xE_NEED_MAINTENANCE"] = this.xE_NEED_MAINTENANCE;
        data["xE_LAST_TOTAL_KM"] = this.xE_LAST_TOTAL_KM;
        data["xE_LAST_DISTANCE"] = this.xE_LAST_DISTANCE;
        return data; 
    }
}

export interface IXE_DTO {
    xE_ID: string | undefined;
    xE_CODE: string | undefined;
    xE_NAME: string | undefined;
    xE_COLOR: string | undefined;
    xE_SEATS: number | undefined;
    xE_MODEL: string | undefined;
    xE_LICENSE_PLATE: string | undefined;
    xE_PRICE: number | undefined;
    xE_CONSUMPTION: number | undefined;
    xE_NOTES: string | undefined;
    xE_MAX_SPEED: number | undefined;
    xE_MANUFACTURER: string | undefined;
    xE_MANUFACTURE_YEAR: number | undefined;
    xE_STATUS: string | undefined;
    createD_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    xE_TOTAL_KM: number | undefined;
    xE_NEED_MAINTENANCE: string | undefined;
    xE_LAST_TOTAL_KM: number | undefined;
    xE_LAST_DISTANCE: number | undefined;
}

export class PagedResultDtoOfXE_DTO implements IPagedResultDtoOfXE_DTO {
    totalCount!: number | undefined;
    items!: XE_DTO[] | undefined;

    constructor(data?: IPagedResultDtoOfXE_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(XE_DTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfXE_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfXE_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfXE_DTO {
    totalCount: number | undefined;
    items: XE_DTO[] | undefined;
}

export class YEU_CAU_SUA_CHUA_DTO implements IYEU_CAU_SUA_CHUA_DTO {
    ycsC_ID!: string | undefined;
    ycsC_MA_YCSC!: string | undefined;
    ycsC_NGUOILAP!: string | undefined;
    ycsC_TBVT_ID!: string | undefined;
    ycsC_DEP_ID!: string | undefined;
    ycsC_MOTA_SUCO!: string | undefined;
    ycsC_MOTA_NGUYENNHAN!: string | undefined;
    ycsC_NHANVIEN_SUACHUA!: string | undefined;
    ycsC_YKIEN_LANHDAO!: string | undefined;
    ycsC_NGAYYC!: moment.Moment | undefined;
    ycsC_NGAYKT!: moment.Moment | undefined;
    ycsC_NGAYHT!: moment.Moment | undefined;
    ycsC_KQTINHTRANG!: string | undefined;
    ycsC_TINHTRANG_DUYET!: number | undefined;
    ycsC_NGUOIDUYET!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    makeR_ID!: string | undefined;
    recorD_STATUS!: string | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: IYEU_CAU_SUA_CHUA_DTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ycsC_ID = data["ycsC_ID"];
            this.ycsC_MA_YCSC = data["ycsC_MA_YCSC"];
            this.ycsC_NGUOILAP = data["ycsC_NGUOILAP"];
            this.ycsC_TBVT_ID = data["ycsC_TBVT_ID"];
            this.ycsC_DEP_ID = data["ycsC_DEP_ID"];
            this.ycsC_MOTA_SUCO = data["ycsC_MOTA_SUCO"];
            this.ycsC_MOTA_NGUYENNHAN = data["ycsC_MOTA_NGUYENNHAN"];
            this.ycsC_NHANVIEN_SUACHUA = data["ycsC_NHANVIEN_SUACHUA"];
            this.ycsC_YKIEN_LANHDAO = data["ycsC_YKIEN_LANHDAO"];
            this.ycsC_NGAYYC = data["ycsC_NGAYYC"] ? moment(data["ycsC_NGAYYC"].toString()) : <any>undefined;
            this.ycsC_NGAYKT = data["ycsC_NGAYKT"] ? moment(data["ycsC_NGAYKT"].toString()) : <any>undefined;
            this.ycsC_NGAYHT = data["ycsC_NGAYHT"] ? moment(data["ycsC_NGAYHT"].toString()) : <any>undefined;
            this.ycsC_KQTINHTRANG = data["ycsC_KQTINHTRANG"];
            this.ycsC_TINHTRANG_DUYET = data["ycsC_TINHTRANG_DUYET"];
            this.ycsC_NGUOIDUYET = data["ycsC_NGUOIDUYET"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.makeR_ID = data["makeR_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): YEU_CAU_SUA_CHUA_DTO {
        data = typeof data === 'object' ? data : {};
        let result = new YEU_CAU_SUA_CHUA_DTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ycsC_ID"] = this.ycsC_ID;
        data["ycsC_MA_YCSC"] = this.ycsC_MA_YCSC;
        data["ycsC_NGUOILAP"] = this.ycsC_NGUOILAP;
        data["ycsC_TBVT_ID"] = this.ycsC_TBVT_ID;
        data["ycsC_DEP_ID"] = this.ycsC_DEP_ID;
        data["ycsC_MOTA_SUCO"] = this.ycsC_MOTA_SUCO;
        data["ycsC_MOTA_NGUYENNHAN"] = this.ycsC_MOTA_NGUYENNHAN;
        data["ycsC_NHANVIEN_SUACHUA"] = this.ycsC_NHANVIEN_SUACHUA;
        data["ycsC_YKIEN_LANHDAO"] = this.ycsC_YKIEN_LANHDAO;
        data["ycsC_NGAYYC"] = this.ycsC_NGAYYC ? this.ycsC_NGAYYC.toISOString() : <any>undefined;
        data["ycsC_NGAYKT"] = this.ycsC_NGAYKT ? this.ycsC_NGAYKT.toISOString() : <any>undefined;
        data["ycsC_NGAYHT"] = this.ycsC_NGAYHT ? this.ycsC_NGAYHT.toISOString() : <any>undefined;
        data["ycsC_KQTINHTRANG"] = this.ycsC_KQTINHTRANG;
        data["ycsC_TINHTRANG_DUYET"] = this.ycsC_TINHTRANG_DUYET;
        data["ycsC_NGUOIDUYET"] = this.ycsC_NGUOIDUYET;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["makeR_ID"] = this.makeR_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IYEU_CAU_SUA_CHUA_DTO {
    ycsC_ID: string | undefined;
    ycsC_MA_YCSC: string | undefined;
    ycsC_NGUOILAP: string | undefined;
    ycsC_TBVT_ID: string | undefined;
    ycsC_DEP_ID: string | undefined;
    ycsC_MOTA_SUCO: string | undefined;
    ycsC_MOTA_NGUYENNHAN: string | undefined;
    ycsC_NHANVIEN_SUACHUA: string | undefined;
    ycsC_YKIEN_LANHDAO: string | undefined;
    ycsC_NGAYYC: moment.Moment | undefined;
    ycsC_NGAYKT: moment.Moment | undefined;
    ycsC_NGAYHT: moment.Moment | undefined;
    ycsC_KQTINHTRANG: string | undefined;
    ycsC_TINHTRANG_DUYET: number | undefined;
    ycsC_NGUOIDUYET: string | undefined;
    creatE_DT: moment.Moment | undefined;
    makeR_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export enum IncomeStatisticsDateInterval {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum IncomeStatisticsDateInterval2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum IncomeStatisticsDateInterval3 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum State {
    _0 = 0, 
    _1 = 1, 
}

export enum SalesSummaryDatePeriod {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum SalesSummaryDatePeriod2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum DefaultTimezoneScope {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _7 = 7, 
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum EntityChangeListDtoChangeType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum FriendDtoState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoSide {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReceiverReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum UserNotificationState {
    _0 = 0, 
    _1 = 1, 
}

export enum TenantNotificationSeverity {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string] : string; } | undefined;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {};
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal[key] = data["Paypal"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string] : string; } | undefined;
}

export enum CreatePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum CreatePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum CreatePaymentDtoSubscriptionPaymentGatewayType {
    _1 = 1, 
}

export enum ExecutePaymentDtoGateway {
    _1 = 1, 
}

export enum ExecutePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ExecutePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum TenantLoginInfoDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum RegisterTenantInputSubscriptionStartType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum RegisterTenantInputGateway {
    _1 = 1, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}